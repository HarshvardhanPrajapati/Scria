[
    {
        "id": "ContractA_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ContractA.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MainContract \n{\n    address currentBidder;\n    uint256 public currentBid;\n\n    function bid() public payable\n    {\n        require(msg.value >= address(this).balance);\n        payable(currentBidder).transfer(address(this).balance);\n        currentBidder = msg.sender; \n        currentBid = msg.value;\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "bid"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC1155_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC1155.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "supportsInterface",
                "uri",
                "balanceOf",
                "balanceOfBatch",
                "setApprovalForAll",
                "isApprovedForAll",
                "safeTransferFrom",
                "safeBatchTransferFrom",
                "_safeTransferFrom",
                "_safeBatchTransferFrom",
                "_setURI",
                "_mint",
                "_mintBatch",
                "_burn",
                "_burnBatch",
                "_setApprovalForAll",
                "_beforeTokenTransfer",
                "_afterTokenTransfer",
                "_doSafeTransferAcceptanceCheck",
                "_doSafeBatchTransferAcceptanceCheck",
                "_asSingletonArray"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC1155_singleTokenSafeTransferFromSafeBatchTransferFromEquivalence",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceof/safebatchtransferfrom/safetransferfrom",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n",
        "formal_property": "rule singleTokenSafeTransferFromSafeBatchTransferFromEquivalence {\n    storage beforeTransfer = lastStorage;\n    env e;\n\n    address holder; address recipient;\n    uint256 token; uint256 transferAmount; bytes data;\n    uint256[] tokens; uint256[] transferAmounts;\n\n    mathint holderStartingBalance = balanceOf(holder, token);\n    mathint recipientStartingBalance = balanceOf(recipient, token);\n\n    require tokens.length == 1; require transferAmounts.length == 1;\n    require tokens[0] == token; require transferAmounts[0] == transferAmount;\n\n    // transferring via safeTransferFrom\n    safeTransferFrom(e, holder, recipient, token, transferAmount, data) at beforeTransfer;\n    mathint holderSafeTransferFromBalanceChange = holderStartingBalance - balanceOf(holder, token);\n    mathint recipientSafeTransferFromBalanceChange = balanceOf(recipient, token) - recipientStartingBalance;\n\n    // transferring via safeBatchTransferFrom\n    safeBatchTransferFrom(e, holder, recipient, tokens, transferAmounts, data) at beforeTransfer;\n    mathint holderSafeBatchTransferFromBalanceChange = holderStartingBalance - balanceOf(holder, token);\n    mathint recipientSafeBatchTransferFromBalanceChange = balanceOf(recipient, token) - recipientStartingBalance;\n\n    assert holderSafeTransferFromBalanceChange == holderSafeBatchTransferFromBalanceChange\n        && recipientSafeTransferFromBalanceChange == recipientSafeBatchTransferFromBalanceChange, \n        \"Transferring a single token via safeTransferFrom or safeBatchTransferFrom must be equivalent\";\n}   \n\n/// The results of transferring multiple tokens must be equivalent whether done \n/// separately via safeTransferFrom or together via safeBatchTransferFrom.\nrule multipleTokenSafeTransferFromSafeBatchTransferFromEquivalence {\n    storage beforeTransfers = lastStorage;\n    env e;\n\n    address holder; address recipient; bytes data;\n    uint256 tokenA; uint256 tokenB; uint256 tokenC;\n    uint256 transferAmountA; uint256 transferAmountB; uint256 transferAmountC;\n    uint256[] tokens; uint256[] transferAmounts;\n\n    mathint holderStartingBalanceA = balanceOf(holder, tokenA);\n    mathint holderStartingBalanceB = balanceOf(holder, tokenB);\n    mathint holderStartingBalanceC = balanceOf(holder, tokenC);\n    mathint recipientStartingBalanceA = balanceOf(recipient, tokenA);\n    mathint recipientStartingBalanceB = balanceOf(recipient, tokenB);\n    mathint recipientStartingBalanceC = balanceOf(recipient, tokenC);\n\n    require tokens.length == 3; require transferAmounts.length == 3;\n    require tokens[0] == tokenA; require transferAmounts[0] == transferAmountA;\n    require tokens[1] == tokenB; require transferAmounts[1] == transferAmountB;\n    require tokens[2] == tokenC; require transferAmounts[2] == transferAmountC;\n\n    // transferring via safeTransferFrom\n    safeTransferFrom(e, holder, recipient, tokenA, transferAmountA, data) at beforeTransfers;\n    safeTransferFrom(e, holder, recipient, tokenB, transferAmountB, data);\n    safeTransferFrom(e, holder, recipient, tokenC, transferAmountC, data);\n    mathint holderSafeTransferFromBalanceChangeA = holderStartingBalanceA - balanceOf(holder, tokenA);\n    mathint holderSafeTransferFromBalanceChangeB = holderStartingBalanceB - balanceOf(holder, tokenB);\n    mathint holderSafeTransferFromBalanceChangeC = holderStartingBalanceC - balanceOf(holder, tokenC);\n    mathint recipientSafeTransferFromBalanceChangeA = balanceOf(recipient, tokenA) - recipientStartingBalanceA;\n    mathint recipientSafeTransferFromBalanceChangeB = balanceOf(recipient, tokenB) - recipientStartingBalanceB;\n    mathint recipientSafeTransferFromBalanceChangeC = balanceOf(recipient, tokenC) - recipientStartingBalanceC;\n\n    // transferring via safeBatchTransferFrom\n    safeBatchTransferFrom(e, holder, recipient, tokens, transferAmounts, data) at beforeTransfers;\n    mathint holderSafeBatchTransferFromBalanceChangeA = holderStartingBalanceA - balanceOf(holder, tokenA);\n    mathint holderSafeBatchTransferFromBalanceChangeB = holderStartingBalanceB - balanceOf(holder, tokenB);\n    mathint holderSafeBatchTransferFromBalanceChangeC = holderStartingBalanceC - balanceOf(holder, tokenC);\n    mathint recipientSafeBatchTransferFromBalanceChangeA = balanceOf(recipient, tokenA) - recipientStartingBalanceA;\n    mathint recipientSafeBatchTransferFromBalanceChangeB = balanceOf(recipient, tokenB) - recipientStartingBalanceB;\n    mathint recipientSafeBatchTransferFromBalanceChangeC = balanceOf(recipient, tokenC) - recipientStartingBalanceC;\n\n    assert holderSafeTransferFromBalanceChangeA == holderSafeBatchTransferFromBalanceChangeA\n        && holderSafeTransferFromBalanceChangeB == holderSafeBatchTransferFromBalanceChangeB\n        && holderSafeTransferFromBalanceChangeC == holderSafeBatchTransferFromBalanceChangeC\n        && recipientSafeTransferFromBalanceChangeA == recipientSafeBatchTransferFromBalanceChangeA\n        && recipientSafeTransferFromBalanceChangeB == recipientSafeBatchTransferFromBalanceChangeB\n        && recipientSafeTransferFromBalanceChangeC == recipientSafeBatchTransferFromBalanceChangeC, \n        \"Transferring multiple tokens via safeTransferFrom or safeBatchTransferFrom must be equivalent\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "singleTokenSafeTransferFromSafeBatchTransferFromEquivalence",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155_transfersHaveSameLengthInputArrays",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "safebatchtransferfrom",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n",
        "formal_property": "rule transfersHaveSameLengthInputArrays {\n    env e;\n\n    address recipient; bytes data;\n    uint256[] tokens; uint256[] transferAmounts;\n    uint max_int = 0xffffffffffffffffffffffffffffffff;\n\n    require tokens.length >= 0 && tokens.length <= max_int;\n    require transferAmounts.length >= 0 && transferAmounts.length <= max_int;\n\n    safeBatchTransferFrom(e, _, recipient, tokens, transferAmounts, data);\n\n    uint256 tokensLength = tokens.length;\n    uint256 transferAmountsLength = transferAmounts.length;\n\n    assert tokens.length == transferAmounts.length, \n        \"If transfer methods do not revert, the input arrays must be the same length\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transfersHaveSameLengthInputArrays",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC20Votes_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC20Votes.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"./draft-ERC20Permit.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../governance/utils/IVotes.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\nabstract contract ERC20Votes is IVotes, ERC20Permit {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n    bytes32 private constant _DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));\n        }\n    }\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "checkpoints",
                "numCheckpoints",
                "delegates",
                "getVotes",
                "getPastVotes",
                "getPastTotalSupply",
                "_checkpointsLookup",
                "delegate",
                "delegateBySig",
                "_maxSupply",
                "_mint",
                "_burn",
                "_afterTokenTransfer",
                "_delegate",
                "_moveVotingPower",
                "_writeCheckpoint",
                "_add",
                "_subtract"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC20Votes_votes_solvency",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Votes.sol",
        "target_function": "_burn/checkpoints/numcheckpoints",
        "text_chunk": "function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }",
        "formal_property": "invariant votes_solvency()\n    totalSupply() >= to_uint256(totalVotes())\nfiltered { f -> f.selector != _burn(address, uint256).selector}\n{ preserved with(env e) {\n    require forall address account. numCheckpoints(account) < 1000000;",
        "nl_summary": "",
        "metadata": {
            "rule_name": "votes_solvency",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "ERC20Votes_blockNum_constrains_fromBlock",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Votes.sol",
        "target_function": "checkpoints/numcheckpoints",
        "text_chunk": "function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }",
        "formal_property": "invariant blockNum_constrains_fromBlock(address account, uint32 index, env e)\n    ckptFromBlock(account, index) < e.block.number\n    filtered { f -> !f.isView }\n{\n    preserved {\n        require index < numCheckpoints(account);",
        "nl_summary": "",
        "metadata": {
            "rule_name": "blockNum_constrains_fromBlock",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "ERC20Votes_maxInt_constrains_numBlocks",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Votes.sol",
        "target_function": "checkpoints/numcheckpoints",
        "text_chunk": "function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }",
        "formal_property": "invariant maxInt_constrains_numBlocks(address account)\n//     numCheckpoints(account) < 4294967295 // 2^32\n\n// can't have more checkpoints for a given account than the last from block\n// passes\ninvariant fromBlock_constrains_numBlocks(address account)\n    numCheckpoints(account) <= ckptFromBlock(account, numCheckpoints(account) - 1)\n    filtered { f -> !f.isView }\n{ preserved with(env e) {\n    require e.block.number >= ckptFromBlock(account, numCheckpoints(account) - 1);",
        "nl_summary": "",
        "metadata": {
            "rule_name": "maxInt_constrains_numBlocks",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "ERC20Votes_fromBlock_greaterThanEq_pos",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Votes.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"./draft-ERC20Permit.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../governance/utils/IVotes.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\nabstract contract ERC20Votes is IVotes, ERC20Permit {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n    bytes32 private constant _DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));\n        }\n    }\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n}",
        "formal_property": "invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)\n    ckptFromBlock(account, pos) >= pos\n    filtered { f -> !f.isView }\n\n// a larger index must have a larger fromBlock\n// passes + rule sanity\ninvariant fromBlock_increasing(address account, uint32 pos, uint32 pos2)\n    pos > pos2 => ckptFromBlock(account, pos) > ckptFromBlock(account, pos2)\n    filtered { f -> !f.isView }\n\n\n// converted from an invariant to a rule to slightly change the logic\n// if the fromBlock is the same as before, then the number of checkpoints stays the same\n// however if the fromBlock is new than the number of checkpoints increases\n// passes, fails rule sanity because tautology check seems to be bugged\nrule unique_checkpoints_rule(method f) {\n    env e;",
        "nl_summary": "",
        "metadata": {
            "rule_name": "fromBlock_greaterThanEq_pos",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "ERC20Wrapper_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC20Wrapper.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/ERC20Wrapper.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../utils/SafeERC20.sol\";\n\nabstract contract ERC20Wrapper is ERC20 {\n    IERC20 public immutable underlying;\n\n    constructor(IERC20 underlyingToken) {\n        underlying = underlyingToken;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        try IERC20Metadata(address(underlying)).decimals() returns (uint8 value) {\n            return value;\n        } catch {\n            return super.decimals();\n        }\n    }\n    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);\n        _mint(account, amount);\n        return true;\n    }\n    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\n        _burn(_msgSender(), amount);\n        SafeERC20.safeTransfer(underlying, account, amount);\n        return true;\n    }\n    function _recover(address account) internal virtual returns (uint256) {\n        uint256 value = underlying.balanceOf(address(this)) - totalSupply();\n        _mint(account, value);\n        return value;\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "decimals",
                "depositFor",
                "withdrawTo",
                "_recover"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC20Wrapper_whatAboutTotal",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Wrapper.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/ERC20Wrapper.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../utils/SafeERC20.sol\";\n\nabstract contract ERC20Wrapper is ERC20 {\n    IERC20 public immutable underlying;\n\n    constructor(IERC20 underlyingToken) {\n        underlying = underlyingToken;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        try IERC20Metadata(address(underlying)).decimals() returns (uint8 value) {\n            return value;\n        } catch {\n            return super.decimals();\n        }\n    }\n    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);\n        _mint(account, amount);\n        return true;\n    }\n    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\n        _burn(_msgSender(), amount);\n        SafeERC20.safeTransfer(underlying, account, amount);\n        return true;\n    }\n    function _recover(address account) internal virtual returns (uint256) {\n        uint256 value = underlying.balanceOf(address(this)) - totalSupply();\n        _mint(account, value);\n        return value;\n    }\n}\n",
        "formal_property": "invariant whatAboutTotal(env e)\n    totalSupply(e) <= underlyingTotalSupply()\n    filtered { f -> f.selector != certorafallback_0().selector && !f.isView}\n    {\n        preserved {\n            require underlyingBalanceOf(currentContract) <= underlyingTotalSupply();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "whatAboutTotal",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "ERC20Wrapper_underTotalAndContractBalanceOfCorrelation",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Wrapper.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/ERC20Wrapper.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../utils/SafeERC20.sol\";\n\nabstract contract ERC20Wrapper is ERC20 {\n    IERC20 public immutable underlying;\n\n    constructor(IERC20 underlyingToken) {\n        underlying = underlyingToken;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        try IERC20Metadata(address(underlying)).decimals() returns (uint8 value) {\n            return value;\n        } catch {\n            return super.decimals();\n        }\n    }\n    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);\n        _mint(account, amount);\n        return true;\n    }\n    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\n        _burn(_msgSender(), amount);\n        SafeERC20.safeTransfer(underlying, account, amount);\n        return true;\n    }\n    function _recover(address account) internal virtual returns (uint256) {\n        uint256 value = underlying.balanceOf(address(this)) - totalSupply();\n        _mint(account, value);\n        return value;\n    }\n}\n",
        "formal_property": "invariant underTotalAndContractBalanceOfCorrelation(env e)\n    totalSupply(e) <= underlyingBalanceOf(currentContract)\n    {\n        preserved with (env e2) {\n            require underlying() != currentContract;",
        "nl_summary": "",
        "metadata": {
            "rule_name": "underTotalAndContractBalanceOfCorrelation",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "Vat_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "Vat.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.13;\n\ncontract Vat {\n    mapping (address => uint256) public wards;\n    mapping(address => mapping (address => uint256)) public can;\n    struct Ilk {\n        uint256 Art; \n        uint256 rate;\n        uint256 spot;\n        uint256 line;\n        uint256 dust;\n    }\n    struct Urn {\n        uint256 ink;\n        uint256 art;\n    }\n    mapping (bytes32 => Ilk) public ilks;\n    mapping (bytes32 => mapping (address => Urn )) public urns;\n    mapping (bytes32 => mapping (address => uint)) public gem;\n    mapping (address => uint256) public dai;\n    mapping (address => uint256) public sin;\n    uint256 public debt;\n    uint256 public vice;\n    uint256 public Line;\n    uint256 public live;\n\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n    event Init(bytes32 indexed ilk);\n    event File(bytes32 indexed what, uint256 data);\n    event File(bytes32 indexed ilk, bytes32 indexed what, uint256 data);\n    event Cage();\n    event Hope(address indexed from, address indexed to);\n    event Nope(address indexed from, address indexed to);\n    event Slip(bytes32 indexed ilk, address indexed usr, int256 wad);\n    event Flux(bytes32 indexed ilk, address indexed src, address indexed dst, uint256 wad);\n    event Move(address indexed src, address indexed dst, uint256 rad);\n    event Frob(bytes32 indexed i, address indexed u, address v, address w, int256 dink, int256 dart);\n    event Fork(bytes32 indexed ilk, address indexed src, address indexed dst, int256 dink, int256 dart);\n    event Grab(bytes32 indexed i, address indexed u, address v, address w, int256 dink, int256 dart);\n    event Heal(address indexed u, uint256 rad);\n    event Suck(address indexed u, address indexed v, uint256 rad);\n    event Fold(bytes32 indexed i, address indexed u, int256 rate);\n\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Vat/not-authorized\");\n        _;\n    }\n\n    function wish(address bit, address usr) internal view returns (bool) {\n        return either(bit == usr, can[bit][usr] == 1);\n    }\n\n    constructor() {\n        wards[msg.sender] = 1;\n        live = 1;\n        emit Rely(msg.sender);\n    }\n\n    function _add(uint256 x, int256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + uint256(y);\n        }\n        require(y >= 0 || z <= x);\n        require(y <= 0 || z >= x);\n    }\n\n    function _sub(uint256 x, int256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - uint256(y);\n        }\n        require(y <= 0 || z <= x);\n        require(y >= 0 || z >= x);\n    }\n\n    function _int256(uint256 x) internal pure returns (int256 y) {\n        require((y = int256(x)) >= 0);\n    }\n\n    function rely(address usr) external auth {\n        require(live == 1, \"Vat/not-live\");\n        wards[usr] = 1;\n        emit Rely(usr);\n    }\n\n    function deny(address usr) external auth {\n        require(live == 1, \"Vat/not-live\");\n        wards[usr] = 0;\n        emit Deny(usr);\n    }\n\n    function init(bytes32 ilk) external auth {\n        require(ilks[ilk].rate == 0, \"Vat/ilk-already-init\");\n        ilks[ilk].rate = 10 ** 27;\n        emit Init(ilk);\n    }\n\n    function file(bytes32 what, uint256 data) external auth {\n        require(live == 1, \"Vat/not-live\");\n        if (what == \"Line\") Line = data;\n        else revert(\"Vat/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    function file(bytes32 ilk, bytes32 what, uint256 data) external auth {\n        require(live == 1, \"Vat/not-live\");\n        if (what == \"spot\") ilks[ilk].spot = data;\n        else if (what == \"line\") ilks[ilk].line = data;\n        else if (what == \"dust\") ilks[ilk].dust = data;\n        else revert(\"Vat/file-unrecognized-param\");\n        emit File(ilk, what, data);\n    }\n\n    function cage() external auth {\n        live = 0;\n        emit Cage();\n    }\n\n    function Art(bytes32 ilk) external view returns (uint256 Art_) {\n        Art_ = ilks[ilk].Art;\n    }\n\n    function rate(bytes32 ilk) external view returns (uint256 rate_) {\n        rate_ = ilks[ilk].rate;\n    }\n\n    function spot(bytes32 ilk) external view returns (uint256 spot_) {\n        spot_ = ilks[ilk].spot;\n    }\n\n    function line(bytes32 ilk) external view returns (uint256 line_) {\n        line_ = ilks[ilk].line;\n    }\n\n    function dust(bytes32 ilk) external view returns (uint256 dust_) {\n        dust_ = ilks[ilk].dust;\n    }\n\n    function ink(bytes32 ilk, address urn) external view returns (uint256 ink_) {\n        ink_ = urns[ilk][urn].ink;\n    }\n\n    function art(bytes32 ilk, address urn) external view returns (uint256 art_) {\n        art_ = urns[ilk][urn].art;\n    }\n\n    function hope(address usr) external {\n        can[msg.sender][usr] = 1;\n        emit Hope(msg.sender, usr);\n    }\n\n    function nope(address usr) external {\n        can[msg.sender][usr] = 0;\n        emit Nope(msg.sender, usr);\n    }\n\n    function slip(bytes32 ilk, address usr, int256 wad) external auth {\n        gem[ilk][usr] = _add(gem[ilk][usr], wad);\n        emit Slip(ilk, usr, wad);\n    }\n\n    function flux(bytes32 ilk, address src, address dst, uint256 wad) external {\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\n        gem[ilk][src] = gem[ilk][src] - wad;\n        gem[ilk][dst] = gem[ilk][dst] + wad;\n        emit Flux(ilk, src, dst, wad);\n    }\n\n    function move(address src, address dst, uint256 rad) external {\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\n        dai[src] = dai[src] - rad;\n        dai[dst] = dai[dst] + rad;\n        emit Move(src, dst, rad);\n    }\n\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    function frob(bytes32 i, address u, address v, address w, int256 dink, int256 dart) external {\n        require(live == 1, \"Vat/not-live\");\n\n        Urn memory urn = urns[i][u];\n        Ilk memory ilk = ilks[i];\n        require(ilk.rate != 0, \"Vat/ilk-not-init\");\n\n        urn.ink = _add(urn.ink, dink);\n        urn.art = _add(urn.art, dart);\n        ilk.Art = _add(ilk.Art, dart);\n\n        int256 dtab = _int256(ilk.rate) * dart;\n        uint256 tab = ilk.rate * urn.art;\n        debt     = _add(debt, dtab);\n\n        require(either(dart <= 0, both(ilk.Art * ilk.rate <= ilk.line, debt <= Line)), \"Vat/ceiling-exceeded\");\n        require(either(both(dart <= 0, dink >= 0), tab <= urn.ink * ilk.spot), \"Vat/not-safe\");\n\n        require(either(both(dart <= 0, dink >= 0), wish(u, msg.sender)), \"Vat/not-allowed-u\");\n        require(either(dink <= 0, wish(v, msg.sender)), \"Vat/not-allowed-v\");\n        require(either(dart >= 0, wish(w, msg.sender)), \"Vat/not-allowed-w\");\n\n        require(either(urn.art == 0, tab >= ilk.dust), \"Vat/dust\");\n\n        gem[i][v] = _sub(gem[i][v], dink);\n        dai[w]    = _add(dai[w],    dtab);\n\n        urns[i][u] = urn;\n        ilks[i]    = ilk;\n\n        emit Frob(i, u, v, w, dink, dart);\n    }\n\n    function fork(bytes32 ilk, address src, address dst, int256 dink, int256 dart) external {\n        Urn storage u = urns[ilk][src];\n        Urn storage v = urns[ilk][dst];\n        Ilk storage i = ilks[ilk];\n\n        u.ink = _sub(u.ink, dink);\n        u.art = _sub(u.art, dart);\n        v.ink = _add(v.ink, dink);\n        v.art = _add(v.art, dart);\n\n        uint256 utab = u.art * i.rate;\n        uint256 vtab = v.art * i.rate;\n\n        require(both(wish(src, msg.sender), wish(dst, msg.sender)), \"Vat/not-allowed\");\n\n        require(utab <= u.ink * i.spot, \"Vat/not-safe-src\");\n        require(vtab <= v.ink * i.spot, \"Vat/not-safe-dst\");\n\n        require(either(utab >= i.dust, u.art == 0), \"Vat/dust-src\");\n        require(either(vtab >= i.dust, v.art == 0), \"Vat/dust-dst\");\n\n        emit Fork(ilk, src, dst, dink, dart);\n    }\n\n    function grab(bytes32 i, address u, address v, address w, int256 dink, int256 dart) external auth {\n        Urn storage urn = urns[i][u];\n        Ilk storage ilk = ilks[i];\n\n        urn.ink = _add(urn.ink, dink);\n        urn.art = _add(urn.art, dart);\n        ilk.Art = _add(ilk.Art, dart);\n\n        int256 dtab = _int256(ilk.rate) * dart;\n\n        gem[i][v] = _sub(gem[i][v], dink);\n        sin[w]    = _sub(sin[w],    dtab);\n        vice      = _sub(vice,      dtab);\n\n        emit Grab(i, u, v, w, dink, dart);\n    }\n\n    function heal(uint256 rad) external {\n        address u = msg.sender;\n        sin[u] = sin[u] - rad;\n        dai[u] = dai[u] - rad;\n        vice   = vice   - rad;\n        debt   = debt   - rad;\n\n        emit Heal(msg.sender, rad);\n    }\n\n    function suck(address u, address v, uint256 rad) external auth {\n        sin[u] = sin[u] + rad;\n        dai[v] = dai[v] + rad;\n        vice   = vice   + rad;\n        debt   = debt   + rad;\n\n        emit Suck(u, v, rad);\n    }\n\n    function fold(bytes32 i, address u, int256 rate_) external auth {\n        require(live == 1, \"Vat/not-live\");\n        Ilk storage ilk = ilks[i];\n        ilk.rate    = _add(ilk.rate, rate_);\n        int256 rad  = _int256(ilk.Art) * rate_;\n        dai[u]      = _add(dai[u], rad);\n        debt        = _add(debt,   rad);\n\n        emit Fold(i, u, rate_);\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "wish",
                "_add",
                "_sub",
                "_int256",
                "rely",
                "deny",
                "init",
                "file",
                "cage",
                "Art",
                "rate",
                "spot",
                "line",
                "dust",
                "ink",
                "art",
                "hope",
                "nope",
                "slip",
                "flux",
                "move",
                "either",
                "both",
                "frob",
                "fork",
                "grab",
                "heal",
                "suck",
                "fold"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC1155Supply_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC1155Supply.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                _totalSupply[ids[i]] += amounts[i];\n            }\n        }\n\n        if (to == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 id = ids[i];\n                uint256 amount = amounts[i];\n                uint256 supply = _totalSupply[id];\n                require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");\n                unchecked {\n                    _totalSupply[id] = supply - amount;\n                }\n            }\n        }\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "totalSupply",
                "exists",
                "_beforeTokenTransfer"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC1155Supply_held_tokens_should_exist",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Supply.sol",
        "target_function": "totalsupply",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                _totalSupply[ids[i]] += amounts[i];\n            }\n        }\n\n        if (to == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 id = ids[i];\n                uint256 amount = amounts[i];\n                uint256 supply = _totalSupply[id];\n                require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");\n                unchecked {\n                    _totalSupply[id] = supply - amount;\n                }\n            }\n        }\n    }\n}\n",
        "formal_property": "rule held_tokens_should_exist {\n    address user; uint256 token;\n\n    requireInvariant balanceOfZeroAddressIsZero(token);\n\n    // This assumption is safe because of total_supply_is_sum_of_balances\n    require balanceOf(user, token) <= totalSupply(token);\n\n    // note: `exists_wrapper` just calls `exists`\n    assert balanceOf(user, token) > 0 => exists_wrapper(token),\n        \"if a user's balance for a token is positive, the token must exist\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "held_tokens_should_exist",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155Supply_sanity",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Supply.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                _totalSupply[ids[i]] += amounts[i];\n            }\n        }\n\n        if (to == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 id = ids[i];\n                uint256 amount = amounts[i];\n                uint256 supply = _totalSupply[id];\n                require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");\n                unchecked {\n                    _totalSupply[id] = supply - amount;\n                }\n            }\n        }\n    }\n}\n",
        "formal_property": "rule sanity {\n    method f; env e; calldataarg args;\n\n    f(e, args);\n\n    assert false;\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sanity",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155Supply_total_supply_is_sum_of_balances",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC1155Supply.sol",
        "target_function": "totalsupply",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                _totalSupply[ids[i]] += amounts[i];\n            }\n        }\n\n        if (to == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 id = ids[i];\n                uint256 amount = amounts[i];\n                uint256 supply = _totalSupply[id];\n                require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");\n                unchecked {\n                    _totalSupply[id] = supply - amount;\n                }\n            }\n        }\n    }\n}\n",
        "formal_property": "invariant total_supply_is_sum_of_balances(uint256 token)\n    sumOfBalances[token] == totalSupply(token)\n    {\n        preserved {\n            requireInvariant balanceOfZeroAddressIsZero(token);",
        "nl_summary": "",
        "metadata": {
            "rule_name": "total_supply_is_sum_of_balances",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "ERC1155Supply_balanceOfZeroAddressIsZero",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC1155Supply.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                _totalSupply[ids[i]] += amounts[i];\n            }\n        }\n\n        if (to == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 id = ids[i];\n                uint256 amount = amounts[i];\n                uint256 supply = _totalSupply[id];\n                require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");\n                unchecked {\n                    _totalSupply[id] = supply - amount;\n                }\n            }\n        }\n    }\n}\n",
        "formal_property": "invariant balanceOfZeroAddressIsZero(uint256 token)\n    balanceOf(0, token) == 0\n\n/// If a user has a token, then the token should exist.\nrule held_tokens_should_exist {\n    address user;",
        "nl_summary": "",
        "metadata": {
            "rule_name": "balanceOfZeroAddressIsZero",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "ERC1155Burnable_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "burn",
                "burnBatch"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC1155Burnable_burnAmountProportionalToBalanceReduction",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burn",
        "text_chunk": "function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }",
        "formal_property": "rule burnAmountProportionalToBalanceReduction {\n    storage beforeBurn = lastStorage;\n    env e;\n    \n    address holder; uint256 token;\n    mathint startingBalance = balanceOf(holder, token);\n    uint256 smallBurn; uint256 largeBurn;\n    require smallBurn < largeBurn;\n\n    // smaller burn amount\n    burn(e, holder, token, smallBurn) at beforeBurn;\n    mathint smallBurnBalanceChange = startingBalance - balanceOf(holder, token);\n\n    // larger burn amount\n    burn(e, holder, token, largeBurn) at beforeBurn;\n    mathint largeBurnBalanceChange = startingBalance - balanceOf(holder, token);\n\n    assert smallBurnBalanceChange < largeBurnBalanceChange, \n        \"A larger burn must lead to a larger decrease in balance\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burnAmountProportionalToBalanceReduction",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155Burnable_sequentialBurnsEquivalentToSingleBurnOfSum",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burn",
        "text_chunk": "function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }",
        "formal_property": "rule sequentialBurnsEquivalentToSingleBurnOfSum {\n    storage beforeBurns = lastStorage;\n    env e;\n\n    address holder; uint256 token;\n    mathint startingBalance = balanceOf(holder, token);\n    uint256 firstBurn; uint256 secondBurn; uint256 sumBurn;\n    require sumBurn == firstBurn + secondBurn;\n\n    // sequential burns\n    burn(e, holder, token, firstBurn) at beforeBurns;\n    burn(e, holder, token, secondBurn);\n    mathint sequentialBurnsBalanceChange = startingBalance - balanceOf(holder, token);\n\n    // burn of sum of sequential burns\n    burn(e, holder, token, sumBurn) at beforeBurns;\n    mathint sumBurnBalanceChange = startingBalance - balanceOf(holder, token);\n\n    assert sequentialBurnsBalanceChange == sumBurnBalanceChange, \n        \"Sequential burns must be equivalent to a burn of their sum\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sequentialBurnsEquivalentToSingleBurnOfSum",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155Burnable_singleTokenBurnBurnBatchEquivalence",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burn/burnbatch",
        "text_chunk": "function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }",
        "formal_property": "rule singleTokenBurnBurnBatchEquivalence {\n    storage beforeBurn = lastStorage;\n    env e;\n\n    address holder;\n    uint256 token; uint256 burnAmount;\n    uint256[] tokens; uint256[] burnAmounts;\n\n    mathint startingBalance = balanceOf(holder, token);\n\n    require tokens.length == 1; require burnAmounts.length == 1;\n    require tokens[0] == token; require burnAmounts[0] == burnAmount;\n\n    // burning via burn\n    burn(e, holder, token, burnAmount) at beforeBurn;\n    mathint burnBalanceChange = startingBalance - balanceOf(holder, token);\n\n    // burning via burnBatch\n    burnBatch(e, holder, tokens, burnAmounts) at beforeBurn;\n    mathint burnBatchBalanceChange = startingBalance - balanceOf(holder, token);\n\n    assert burnBalanceChange == burnBatchBalanceChange, \n        \"Burning a single token via burn or burnBatch must be equivalent\";\n}   \n\n/// The results of burning multiple tokens must be equivalent whether done \n/// separately via burn or together via burnBatch.\nrule multipleTokenBurnBurnBatchEquivalence {\n    storage beforeBurns = lastStorage;\n    env e;\n\n    address holder;\n    uint256 tokenA; uint256 tokenB; uint256 tokenC;\n    uint256 burnAmountA; uint256 burnAmountB; uint256 burnAmountC;\n    uint256[] tokens; uint256[] burnAmounts;\n\n    mathint startingBalanceA = balanceOf(holder, tokenA);\n    mathint startingBalanceB = balanceOf(holder, tokenB);\n    mathint startingBalanceC = balanceOf(holder, tokenC);\n\n    require tokens.length == 3; require burnAmounts.length == 3;\n    require tokens[0] == tokenA; require burnAmounts[0] == burnAmountA;\n    require tokens[1] == tokenB; require burnAmounts[1] == burnAmountB;\n    require tokens[2] == tokenC; require burnAmounts[2] == burnAmountC;\n\n    // burning via burn\n    burn(e, holder, tokenA, burnAmountA) at beforeBurns;\n    burn(e, holder, tokenB, burnAmountB);\n    burn(e, holder, tokenC, burnAmountC);\n    mathint burnBalanceChangeA = startingBalanceA - balanceOf(holder, tokenA);\n    mathint burnBalanceChangeB = startingBalanceB - balanceOf(holder, tokenB);\n    mathint burnBalanceChangeC = startingBalanceC - balanceOf(holder, tokenC);\n\n    // burning via burnBatch\n    burnBatch(e, holder, tokens, burnAmounts) at beforeBurns;\n    mathint burnBatchBalanceChangeA = startingBalanceA - balanceOf(holder, tokenA);\n    mathint burnBatchBalanceChangeB = startingBalanceB - balanceOf(holder, tokenB);\n    mathint burnBatchBalanceChangeC = startingBalanceC - balanceOf(holder, tokenC);\n\n    assert burnBalanceChangeA == burnBatchBalanceChangeA\n        && burnBalanceChangeB == burnBatchBalanceChangeB\n        && burnBalanceChangeC == burnBatchBalanceChangeC, \n        \"Burning multiple tokens via burn or burnBatch must be equivalent\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "singleTokenBurnBurnBatchEquivalence",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155Burnable_burnBatchOnEmptyArraysChangesNothing",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burnbatch",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n",
        "formal_property": "rule burnBatchOnEmptyArraysChangesNothing {\n    uint256 token; address nonHolderA; address nonHolderB;\n\n    uint256 startingBalance = balanceOf(nonHolderA, token);\n    bool startingPermission = isApprovedForAll(nonHolderA, nonHolderB);\n\n    env e; address holder; uint256[] noTokens; uint256[] noBurnAmounts;\n    require noTokens.length == 0; require noBurnAmounts.length == 0;\n\n    burnBatch(e, holder, noTokens, noBurnAmounts);\n    \n    uint256 endingBalance = balanceOf(nonHolderA, token);\n    bool endingPermission = isApprovedForAll(nonHolderA, nonHolderB);\n\n    assert startingBalance == endingBalance, \n        \"burnBatch must not change token balances if passed empty arrays\";\n    assert startingPermission == endingPermission, \n        \"burnBatch must not change account permissions if passed empty arrays\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burnBatchOnEmptyArraysChangesNothing",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155Burnable_sanity",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n",
        "formal_property": "rule sanity {\n    method f; env e; calldataarg args;\n\n    f(e, args);\n\n    assert false, \n        \"This rule should always fail\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sanity",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155Pausable_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "_beforeTokenTransfer"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC1155Pausable_pauseMethodPausesContract",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": "rule pauseMethodPausesContract {\n    require !paused();\n\n    env e;\n    pause(e);\n\n    assert paused(), \n        \"Calling pause must pause an unpaused contract\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "pauseMethodPausesContract",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155Pausable_unpauseMethodUnpausesContract",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": "rule unpauseMethodUnpausesContract {\n    require paused();\n\n    env e;\n    unpause(e);\n\n    assert !paused(), \n        \"Calling unpause must unpause a paused contract\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "unpauseMethodUnpausesContract",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155Pausable_cannotPauseWhilePaused",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": "rule cannotPauseWhilePaused {\n    require paused();\n\n    env e;\n    pause@withrevert(e);\n\n    assert lastReverted, \n        \"A call to pause when already paused must revert\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cannotPauseWhilePaused",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155Pausable_cannotUnpauseWhileUnpaused",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": "rule cannotUnpauseWhileUnpaused {\n    require !paused();\n\n    env e;\n    unpause@withrevert(e);\n\n    assert lastReverted, \n        \"A call to unpause when already unpaused must revert\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cannotUnpauseWhileUnpaused",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155Pausable_whenNotPausedModifierCausesRevertIfPaused",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": "rule whenNotPausedModifierCausesRevertIfPaused {\n    require paused();\n\n    env e; calldataarg args;\n    onlyWhenNotPausedMethod@withrevert(e, args);\n\n    assert lastReverted, \n        \"Functions with the whenNotPaused modifier must revert if the contract is paused\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "whenNotPausedModifierCausesRevertIfPaused",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155Pausable_whenPausedModifierCausesRevertIfUnpaused",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": "rule whenPausedModifierCausesRevertIfUnpaused {\n    require !paused();\n\n    env e; calldataarg args;\n    onlyWhenPausedMethod@withrevert(e, args);\n\n    assert lastReverted, \n        \"Functions with the whenPaused modifier must revert if the contract is not paused\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "whenPausedModifierCausesRevertIfUnpaused",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155Pausable_sanity",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": "rule sanity {\n    method f; env e; calldataarg args;\n\n    f(e, args);\n\n    assert false, \n        \"This rule should always fail\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sanity",
            "rule_type": "RULE"
        }
    },
    {
        "id": "AccessControl_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "AccessControl.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "supportsInterface",
                "hasRole",
                "_checkRole",
                "getRoleAdmin",
                "grantRole",
                "revokeRole",
                "renounceRole",
                "_setupRole",
                "_setRoleAdmin",
                "_grantRole",
                "_revokeRole"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "Auction_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "Auction.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\ncontract AuctionFixed \n{\n    event BidEvent(address from);\n    function bid() public\n    {\n        emitBidEvent(msg.sender);\n    }\n\n    function emitBidEvent(address from) internal\n    {\n        emit BidEvent(from);\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "bid",
                "emitBidEvent"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC20broken_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC20broken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ContractsAndProperties/IERC20.sol\";\nimport \"../ContractsAndProperties/IERC20Metadata.sol\";\n\ncontract ERC20 is IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    address public _owner;\n\n    constructor() {\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender);\n        _;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return \"\";\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return \"\";\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        ); \n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        ); \n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n    function mint(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function burn(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function deposit() external payable {\n        _balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount <= _balances[msg.sender]);\n        _balances[msg.sender] -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success);\n    }\n\n    function addAmount(uint256 amount) external {\n            _balances[msg.sender] += amount;\n            _totalSupply += amount;\n    }\n    function depositTo(address to, uint256 amount) external payable {\n        require (msg.value > amount);\n        unchecked {\n            _balances[to] += amount;\n            _balances[msg.sender] += msg.value - amount;\n            _totalSupply += msg.value;\n        }\n    }\n\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "name",
                "symbol",
                "decimals",
                "totalSupply",
                "balanceOf",
                "transfer",
                "allowance",
                "approve",
                "transferFrom",
                "increaseAllowance",
                "decreaseAllowance",
                "_transfer",
                "mint",
                "burn",
                "_approve",
                "_beforeTokenTransfer",
                "_afterTokenTransfer",
                "deposit",
                "withdraw",
                "addAmount",
                "depositTo"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC20broken_transferSpec",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20broken.sol",
        "target_function": "balanceof/transfer",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ContractsAndProperties/IERC20.sol\";\nimport \"../ContractsAndProperties/IERC20Metadata.sol\";\n\ncontract ERC20 is IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    address public _owner;\n\n    constructor() {\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender);\n        _;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return \"\";\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return \"\";\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        ); \n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        ); \n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n    function mint(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function burn(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function deposit() external payable {\n        _balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount <= _balances[msg.sender]);\n        _balances[msg.sender] -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success);\n    }\n\n    function addAmount(uint256 amount) external {\n            _balances[msg.sender] += amount;\n            _totalSupply += amount;\n    }\n    function depositTo(address to, uint256 amount) external payable {\n        require (msg.value > amount);\n        unchecked {\n            _balances[to] += amount;\n            _balances[msg.sender] += msg.value - amount;\n            _totalSupply += msg.value;\n        }\n    }\n\n}",
        "formal_property": "rule transferSpec {\n    address sender; address recip; uint amount;\n\n    env e;\n    require e.msg.sender == sender;\n\n    mathint balance_sender_before = balanceOf(sender);\n    mathint balance_recip_before = balanceOf(recip);\n\n    transfer(e, recip, amount);\n\n    mathint balance_sender_after = balanceOf(sender);\n    mathint balance_recip_after = balanceOf(recip);\n\n    require sender != recip;\n\n    assert balance_sender_after == balance_sender_before - amount,\n        \"transfer must decrease sender's balance by amount\";\n\n    assert balance_recip_after == balance_recip_before + amount,\n        \"transfer must increase recipient's balance by amount\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferSpec",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC20broken_transferReverts",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20broken.sol",
        "target_function": "balanceof/transfer",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ContractsAndProperties/IERC20.sol\";\nimport \"../ContractsAndProperties/IERC20Metadata.sol\";\n\ncontract ERC20 is IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    address public _owner;\n\n    constructor() {\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender);\n        _;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return \"\";\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return \"\";\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        ); \n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        ); \n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n    function mint(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function burn(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function deposit() external payable {\n        _balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount <= _balances[msg.sender]);\n        _balances[msg.sender] -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success);\n    }\n\n    function addAmount(uint256 amount) external {\n            _balances[msg.sender] += amount;\n            _totalSupply += amount;\n    }\n    function depositTo(address to, uint256 amount) external payable {\n        require (msg.value > amount);\n        unchecked {\n            _balances[to] += amount;\n            _balances[msg.sender] += msg.value - amount;\n            _totalSupply += msg.value;\n        }\n    }\n\n}",
        "formal_property": "rule transferReverts {\n    env e; address recip; uint amount;\n\n    require balanceOf(e.msg.sender) < amount;\n\n    transfer@withrevert(e, recip, amount);\n\n    assert lastReverted,\n        \"transfer(recip,amount) must revert if sender's balance is less than `amount`\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferReverts",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC20broken_transferDoesntRevert",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20broken.sol",
        "target_function": "balanceof/transfer",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ContractsAndProperties/IERC20.sol\";\nimport \"../ContractsAndProperties/IERC20Metadata.sol\";\n\ncontract ERC20 is IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    address public _owner;\n\n    constructor() {\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender);\n        _;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return \"\";\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return \"\";\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        ); \n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        ); \n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n    function mint(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function burn(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function deposit() external payable {\n        _balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount <= _balances[msg.sender]);\n        _balances[msg.sender] -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success);\n    }\n\n    function addAmount(uint256 amount) external {\n            _balances[msg.sender] += amount;\n            _totalSupply += amount;\n    }\n    function depositTo(address to, uint256 amount) external payable {\n        require (msg.value > amount);\n        unchecked {\n            _balances[to] += amount;\n            _balances[msg.sender] += msg.value - amount;\n            _totalSupply += msg.value;\n        }\n    }\n\n}",
        "formal_property": "rule transferDoesntRevert {\n    env e; address recipient; uint amount;\n\n    require balanceOf(e.msg.sender) > amount;\n    require e.msg.value == 0;\n    require balanceOf(recipient) + amount < max_uint;\n    require e.msg.sender != 0;\n    require recipient != 0;\n\n    transfer@withrevert(e, recipient, amount);\n    assert !lastReverted;\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferDoesntRevert",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC20broken_onlyHolderCanChangeAllowance",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20broken.sol",
        "target_function": "allowance/approve/increaseallowance",
        "text_chunk": "function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }",
        "formal_property": "rule onlyHolderCanChangeAllowance {\n    address holder; address spender;\n\n    mathint allowance_before = allowance(holder, spender);\n\n    method f; env e; calldataarg args; // was: env e; uint256 amount;\n    f(e, args);                        // was: approve(e, spender, amount);\n\n    mathint allowance_after = allowance(holder, spender);\n\n    assert allowance_after > allowance_before => e.msg.sender == holder,\n        \"approve must only change the sender's allowance\";\n\n    assert allowance_after > allowance_before =>\n        (f.selector == sig:approve(address,uint).selector || f.selector == sig:increaseAllowance(address,uint).selector),\n        \"only approve and increaseAllowance can increase allowances\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "onlyHolderCanChangeAllowance",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC20broken_onlyApproveIncreasesAllowance",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20broken.sol",
        "target_function": "allowance/approve",
        "text_chunk": "function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }",
        "formal_property": "rule onlyApproveIncreasesAllowance {\n    address holder; address spender;\n\n    mathint allowance_before = allowance(holder, spender);\n\n    method f; env e; calldataarg args; \n    f(e, args);                        \n\n    mathint allowance_after = allowance(holder, spender);\n\n    satisfy allowance_after > allowance_before =>\n        (f.selector == sig:approve(address,uint).selector),\n        \"only approve and increaseAllowance can increase allowances\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "onlyApproveIncreasesAllowance",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC20broken_balancesBoundedByTotalSupply",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20broken.sol",
        "target_function": "balanceof/totalsupply/transfer",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ContractsAndProperties/IERC20.sol\";\nimport \"../ContractsAndProperties/IERC20Metadata.sol\";\n\ncontract ERC20 is IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    address public _owner;\n\n    constructor() {\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender);\n        _;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return \"\";\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return \"\";\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        ); \n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        ); \n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n    function mint(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function burn(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function deposit() external payable {\n        _balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount <= _balances[msg.sender]);\n        _balances[msg.sender] -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success);\n    }\n\n    function addAmount(uint256 amount) external {\n            _balances[msg.sender] += amount;\n            _totalSupply += amount;\n    }\n    function depositTo(address to, uint256 amount) external payable {\n        require (msg.value > amount);\n        unchecked {\n            _balances[to] += amount;\n            _balances[msg.sender] += msg.value - amount;\n            _totalSupply += msg.value;\n        }\n    }\n\n}",
        "formal_property": "invariant balancesBoundedByTotalSupply(address alice, address bob)\n    balanceOf(alice) + balanceOf(bob) <= totalSupply()\n{\n    preserved transfer(address recip, uint256 amount) with (env e) {\n        require recip        == alice || recip        == bob;",
        "nl_summary": "",
        "metadata": {
            "rule_name": "balancesBoundedByTotalSupply",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "ERC20broken_totalSupplyIsSumOfBalances",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20broken.sol",
        "target_function": "totalsupply",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ContractsAndProperties/IERC20.sol\";\nimport \"../ContractsAndProperties/IERC20Metadata.sol\";\n\ncontract ERC20 is IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    address public _owner;\n\n    constructor() {\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender);\n        _;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return \"\";\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return \"\";\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        ); \n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        ); \n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n    function mint(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function burn(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function deposit() external payable {\n        _balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount <= _balances[msg.sender]);\n        _balances[msg.sender] -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success);\n    }\n\n    function addAmount(uint256 amount) external {\n            _balances[msg.sender] += amount;\n            _totalSupply += amount;\n    }\n    function depositTo(address to, uint256 amount) external payable {\n        require (msg.value > amount);\n        unchecked {\n            _balances[to] += amount;\n            _balances[msg.sender] += msg.value - amount;\n            _totalSupply += msg.value;\n        }\n    }\n\n}",
        "formal_property": "invariant totalSupplyIsSumOfBalances()\n    totalSupply() == sum_of_balances;",
        "nl_summary": "",
        "metadata": {
            "rule_name": "totalSupplyIsSumOfBalances",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "ERC20FlashMint_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC20FlashMint.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../../../interfaces/IERC3156FlashBorrower.sol\";\nimport \"../../../interfaces/IERC3156FlashLender.sol\";\nimport \"../ERC20.sol\";\n\nabstract contract ERC20FlashMint is ERC20, IERC3156FlashLender {\n    bytes32 private constant _RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    function maxFlashLoan(address token) public view virtual override returns (uint256) {\n        return token == address(this) ? type(uint256).max - ERC20.totalSupply() : 0;\n    }\n\n    function flashFee(address token, uint256 amount) public view virtual override returns (uint256) {\n        require(token == address(this), \"ERC20FlashMint: wrong token\");\n        amount;\n        return 0;\n    }\n\n    function _flashFeeReceiver() internal view virtual returns (address) {\n        return address(0);\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override returns (bool) {\n        require(amount <= maxFlashLoan(token), \"ERC20FlashMint: amount exceeds maxFlashLoan\");\n        uint256 fee = flashFee(token, amount);\n        _mint(address(receiver), amount);\n        require(\n            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == _RETURN_VALUE,\n            \"ERC20FlashMint: invalid return value\"\n        );\n        address flashFeeReceiver = _flashFeeReceiver();\n        _spendAllowance(address(receiver), address(this), amount + fee);\n        if (fee == 0 || flashFeeReceiver == address(0)) {\n            _burn(address(receiver), amount + fee);\n        } else {\n            _burn(address(receiver), amount);\n            _transfer(address(receiver), flashFeeReceiver, fee);\n        }\n        return true;\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "maxFlashLoan",
                "flashFee",
                "_flashFeeReceiver",
                "flashLoan"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "PreciseBitwiseOps_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "PreciseBitwiseOps.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\ncontract PreciseBitwiseOps{\n    uint16 public constant MAX_RESERVES_COUNT = 128;\n    string public constant INVALID_RESERVE_INDEX = '74'; // 'Invalid reserve index'\n    uint256 public data;\n\n    constructor(){\n        data = 0;\n    }\n\n    function setBorrowing(\n    uint256 reserveIndex,\n    bool borrowing\n  ) public {\n    unchecked {\n      require(reserveIndex < MAX_RESERVES_COUNT, INVALID_RESERVE_INDEX);\n      uint256 bit = 1 << (reserveIndex << 1);\n      if (borrowing) {\n        data |= bit;\n      } else {\n        data &= ~bit;\n      }\n    }\n  }\n\n  function isBorrowing(\n    uint256 reserveIndex\n  ) public view returns (bool) {\n    unchecked {\n      require(reserveIndex < MAX_RESERVES_COUNT, INVALID_RESERVE_INDEX);\n      return (data >> (reserveIndex << 1)) & 1 != 0;\n    }\n  }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "setBorrowing",
                "isBorrowing"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "GovernorPreventLateQuorum_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "GovernorPreventLateQuorum.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../../utils/math/Math.sol\";\n\nabstract contract GovernorPreventLateQuorum is Governor {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    uint64 private _voteExtension;\n    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;\n\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n\n    constructor(uint64 initialVoteExtension) {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }\n\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());\n    }\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        uint256 result = super._castVote(proposalId, account, support, reason, params);\n\n        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];\n\n        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {\n            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();\n\n            if (extendedDeadlineValue > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadlineValue);\n            }\n\n            extendedDeadline.setDeadline(extendedDeadlineValue);\n        }\n\n        return result;\n    }\n\n    function lateQuorumVoteExtension() public view virtual returns (uint64) {\n        return _voteExtension;\n    }\n\n    function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }\n\n    function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {\n        emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension);\n        _voteExtension = newVoteExtension;\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "proposalDeadline",
                "_castVote",
                "lateQuorumVoteExtension",
                "setLateQuorumVoteExtension",
                "_setLateQuorumVoteExtension"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "GovernorPreventLateQuorum_quorumReachedEffect",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GovernorPreventLateQuorum.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../../utils/math/Math.sol\";\n\nabstract contract GovernorPreventLateQuorum is Governor {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    uint64 private _voteExtension;\n    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;\n\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n\n    constructor(uint64 initialVoteExtension) {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }\n\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());\n    }\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        uint256 result = super._castVote(proposalId, account, support, reason, params);\n\n        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];\n\n        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {\n            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();\n\n            if (extendedDeadlineValue > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadlineValue);\n            }\n\n            extendedDeadline.setDeadline(extendedDeadlineValue);\n        }\n\n        return result;\n    }\n\n    function lateQuorumVoteExtension() public view virtual returns (uint64) {\n        return _voteExtension;\n    }\n\n    function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }\n\n    function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {\n        emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension);\n        _voteExtension = newVoteExtension;\n    }\n}",
        "formal_property": "invariant quorumReachedEffect(env e, uint256 pId)\n    quorumReached(e, pId) => proposalCreated(pId) // bug: 0 supply 0 votes => quorumReached\n    // filtered { f -> f.selector != updateQuorumNumerator(uint256).selector } // * fails for this function\n\n/*\n * I2: A non-existant proposal must meet the definition of one.\n * INVARIANT NOT PASSING // fails for updateQuorumNumerator and in the initial state when voting token total supply is 0 (causes quoromReached to return true)\n * ADVANCED SANITY NOT RAN\n */\ninvariant proposalNotCreatedEffects(env e, uint256 pId)\n    !proposalCreated(pId) => proposalNotCreated(e, pId)\n    // filtered { f -> f.selector != updateQuorumNumerator(uint256).selector } // * fails for this function\n\n/*\n * I3: A created propsal must be in state deadlineExtendable or deadlineExtended.\n * INVARIANT NOT PASSING // fails for updateQuorumNumerator and in the initial state when voting token total supply is 0 (causes quoromReached to return true)\n * ADVANCED SANITY NOT RAN \n */\ninvariant proposalInOneState(env e, uint256 pId) \n    proposalNotCreated(e, pId) || deadlineExtendable(e, pId) || deadlineExtended(e, pId)\n    // filtered { f -> f.selector != updateQuorumNumerator(uint256).selector } // * fails for this function\n    { preserved { requireInvariant proposalNotCreatedEffects(e, pId);",
        "nl_summary": "",
        "metadata": {
            "rule_name": "quorumReachedEffect",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "GovernorCountingSimple_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\n\nabstract contract GovernorCountingSimple is Governor {\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    function proposalVotes(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);\n    }\n\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= proposalvote.forVotes + proposalvote.abstainVotes;\n    }\n\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return proposalvote.forVotes > proposalvote.againstVotes;\n    }\n\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory\n    ) internal virtual override {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        require(!proposalvote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");\n        proposalvote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalvote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalvote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalvote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "COUNTING_MODE",
                "hasVoted",
                "proposalVotes",
                "_quorumReached",
                "_voteSucceeded",
                "_countVote"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "GovernorCountingSimple_SumOfVotesCastEqualSumOfPowerOfVotedPerProposal",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\n\nabstract contract GovernorCountingSimple is Governor {\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    function proposalVotes(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);\n    }\n\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= proposalvote.forVotes + proposalvote.abstainVotes;\n    }\n\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return proposalvote.forVotes > proposalvote.againstVotes;\n    }\n\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory\n    ) internal virtual override {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        require(!proposalvote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");\n        proposalvote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalvote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalvote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalvote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n}",
        "formal_property": "invariant SumOfVotesCastEqualSumOfPowerOfVotedPerProposal(uint256 pId) \n\ttracked_weight(pId) == ghost_sum_vote_power_by_id(pId)\n\n\n/*\n * sum of all votes casted is equal to the sum of voting power of those who voted\n */\ninvariant SumOfVotesCastEqualSumOfPowerOfVoted() \n\tsum_tracked_weight() == sum_all_votes_power()\n\n\n/*\n* sum of all votes casted is greater or equal to the sum of voting power of those who voted at a specific proposal\n*/\ninvariant OneIsNotMoreThanAll(uint256 pId) \n\tsum_all_votes_power() >= tracked_weight(pId)\n\n\n//////////////////////////////////////////////////////////////////////////////\n///////////////////////////////// RULES //////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////\n\n\n/*\n * Only sender's voting status can be changed by execution of any cast vote function\n */\n// Checked for castVote only. all 3 castVote functions call _castVote, so the completeness of the verification is counted on\n // the fact that the 3 functions themselves makes no changes, but rather call an internal function to execute.\n // That means that we do not check those 3 functions directly, however for castVote & castVoteWithReason it is quite trivial\n // to understand why this is ok. For castVoteBySig we basically assume that the signature referendum is correct without checking it.\n // We could check each function separately and pass the rule, but that would have uglyfied the code with no concrete \n // benefit, as it is evident that nothing is happening in the first 2 functions (calling a view function), and we do not desire to check the signature verification.\nrule noVoteForSomeoneElse(uint256 pId, uint8 sup, method f) {\n    env e;",
        "nl_summary": "",
        "metadata": {
            "rule_name": "SumOfVotesCastEqualSumOfPowerOfVotedPerProposal",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "ERC20fixed_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC20fixed.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ContractsAndProperties/IERC20.sol\";\nimport \"../ContractsAndProperties/IERC20Metadata.sol\";\n\ncontract ERC20Fixed is IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    address public _owner;\n    constructor() {\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender);\n        _;\n    }\n    function name() public view virtual override returns (string memory) {\n        return \"\";\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return \"\";\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        ); \n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        ); \n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n    function mint(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function burn(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function deposit() external payable {\n        _balances[msg.sender] += msg.value;\n        _totalSupply += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount <= _balances[msg.sender]);\n        _balances[msg.sender] -= amount;\n        _totalSupply -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success);\n    }\n\n\n    function addAmount(uint256 amount) external {\n            _balances[msg.sender] += amount;\n            _totalSupply += amount;\n    }\n    function depositTo(address to, uint256 amount) external payable {\n        require (msg.value > amount);\n        require (to != address(this));\n        unchecked {\n            _transfer(address(this), to, amount);\n            _transfer(address(this), msg.sender, msg.value - amount);\n        }\n    }\n\n    function add(uint256 x, uint256 y) external pure returns(uint256) {\n        unchecked {\n         return x + y;\n        }\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "name",
                "symbol",
                "decimals",
                "totalSupply",
                "balanceOf",
                "transfer",
                "allowance",
                "approve",
                "transferFrom",
                "increaseAllowance",
                "decreaseAllowance",
                "_transfer",
                "mint",
                "burn",
                "_approve",
                "_beforeTokenTransfer",
                "_afterTokenTransfer",
                "deposit",
                "withdraw",
                "addAmount",
                "depositTo",
                "add"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC20fixed_transferSpec",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20fixed.sol",
        "target_function": "balanceof/transfer",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ContractsAndProperties/IERC20.sol\";\nimport \"../ContractsAndProperties/IERC20Metadata.sol\";\n\ncontract ERC20Fixed is IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    address public _owner;\n    constructor() {\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender);\n        _;\n    }\n    function name() public view virtual override returns (string memory) {\n        return \"\";\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return \"\";\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        ); \n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        ); \n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n    function mint(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function burn(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function deposit() external payable {\n        _balances[msg.sender] += msg.value;\n        _totalSupply += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount <= _balances[msg.sender]);\n        _balances[msg.sender] -= amount;\n        _totalSupply -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success);\n    }\n\n\n    function addAmount(uint256 amount) external {\n            _balances[msg.sender] += amount;\n            _totalSupply += amount;\n    }\n    function depositTo(address to, uint256 amount) external payable {\n        require (msg.value > amount);\n        require (to != address(this));\n        unchecked {\n            _transfer(address(this), to, amount);\n            _transfer(address(this), msg.sender, msg.value - amount);\n        }\n    }\n\n    function add(uint256 x, uint256 y) external pure returns(uint256) {\n        unchecked {\n         return x + y;\n        }\n    }\n}",
        "formal_property": "rule transferSpec {\n    address sender; address recip; uint amount;\n\n    env e;\n    require e.msg.sender == sender;\n\n    mathint balance_sender_before = balanceOf(sender);\n    mathint balance_recip_before = balanceOf(recip);\n\n    transfer(e, recip, amount);\n\n    mathint balance_sender_after = balanceOf(sender);\n    mathint balance_recip_after = balanceOf(recip);\n\n    require sender != recip;\n\n    assert balance_sender_after == balance_sender_before - amount,\n        \"transfer must decrease sender's balance by amount\";\n\n    assert balance_recip_after == balance_recip_before + amount,\n        \"transfer must increase recipient's balance by amount\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferSpec",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC20fixed_transferReverts",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20fixed.sol",
        "target_function": "balanceof/transfer",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ContractsAndProperties/IERC20.sol\";\nimport \"../ContractsAndProperties/IERC20Metadata.sol\";\n\ncontract ERC20Fixed is IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    address public _owner;\n    constructor() {\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender);\n        _;\n    }\n    function name() public view virtual override returns (string memory) {\n        return \"\";\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return \"\";\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        ); \n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        ); \n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n    function mint(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function burn(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function deposit() external payable {\n        _balances[msg.sender] += msg.value;\n        _totalSupply += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount <= _balances[msg.sender]);\n        _balances[msg.sender] -= amount;\n        _totalSupply -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success);\n    }\n\n\n    function addAmount(uint256 amount) external {\n            _balances[msg.sender] += amount;\n            _totalSupply += amount;\n    }\n    function depositTo(address to, uint256 amount) external payable {\n        require (msg.value > amount);\n        require (to != address(this));\n        unchecked {\n            _transfer(address(this), to, amount);\n            _transfer(address(this), msg.sender, msg.value - amount);\n        }\n    }\n\n    function add(uint256 x, uint256 y) external pure returns(uint256) {\n        unchecked {\n         return x + y;\n        }\n    }\n}",
        "formal_property": "rule transferReverts {\n    env e; address recip; uint amount;\n\n    require balanceOf(e.msg.sender) < amount;\n\n    transfer@withrevert(e, recip, amount);\n\n    assert lastReverted,\n        \"transfer(recip,amount) must revert if sender's balance is less than `amount`\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferReverts",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC20fixed_transferDoesntRevert",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20fixed.sol",
        "target_function": "balanceof/transfer",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ContractsAndProperties/IERC20.sol\";\nimport \"../ContractsAndProperties/IERC20Metadata.sol\";\n\ncontract ERC20Fixed is IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    address public _owner;\n    constructor() {\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender);\n        _;\n    }\n    function name() public view virtual override returns (string memory) {\n        return \"\";\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return \"\";\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        ); \n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        ); \n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n    function mint(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function burn(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function deposit() external payable {\n        _balances[msg.sender] += msg.value;\n        _totalSupply += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount <= _balances[msg.sender]);\n        _balances[msg.sender] -= amount;\n        _totalSupply -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success);\n    }\n\n\n    function addAmount(uint256 amount) external {\n            _balances[msg.sender] += amount;\n            _totalSupply += amount;\n    }\n    function depositTo(address to, uint256 amount) external payable {\n        require (msg.value > amount);\n        require (to != address(this));\n        unchecked {\n            _transfer(address(this), to, amount);\n            _transfer(address(this), msg.sender, msg.value - amount);\n        }\n    }\n\n    function add(uint256 x, uint256 y) external pure returns(uint256) {\n        unchecked {\n         return x + y;\n        }\n    }\n}",
        "formal_property": "rule transferDoesntRevert {\n    env e; address recipient; uint amount;\n\n    require balanceOf(e.msg.sender) > amount;\n    require e.msg.value == 0;\n    require balanceOf(recipient) + amount < max_uint;\n    require e.msg.sender != 0;\n    require recipient != 0;\n\n    transfer@withrevert(e, recipient, amount);\n    assert !lastReverted;\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferDoesntRevert",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC20fixed_onlyHolderCanChangeAllowance",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20fixed.sol",
        "target_function": "allowance/approve/increaseallowance",
        "text_chunk": "function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }",
        "formal_property": "rule onlyHolderCanChangeAllowance {\n    address holder; address spender;\n\n    mathint allowance_before = allowance(holder, spender);\n    method f; env e; calldataarg args; // was: env e; uint256 amount;\n    f(e, args);                        // was: approve(e, spender, amount);\n\n    mathint allowance_after = allowance(holder, spender);\n\n    assert allowance_after > allowance_before => e.msg.sender == holder,\n        \"approve must only change the sender's allowance\";\n\n    assert allowance_after > allowance_before =>\n        (f.selector == sig:approve(address,uint).selector || f.selector == sig:increaseAllowance(address,uint).selector),\n        \"only approve and increaseAllowance can increase allowances\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "onlyHolderCanChangeAllowance",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC20fixed_totalSupplyIsSumOfBalances",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20fixed.sol",
        "target_function": "totalsupply",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ContractsAndProperties/IERC20.sol\";\nimport \"../ContractsAndProperties/IERC20Metadata.sol\";\n\ncontract ERC20Fixed is IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    address public _owner;\n    constructor() {\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender);\n        _;\n    }\n    function name() public view virtual override returns (string memory) {\n        return \"\";\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return \"\";\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        ); \n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        ); \n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n    function mint(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function burn(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function deposit() external payable {\n        _balances[msg.sender] += msg.value;\n        _totalSupply += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount <= _balances[msg.sender]);\n        _balances[msg.sender] -= amount;\n        _totalSupply -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success);\n    }\n\n\n    function addAmount(uint256 amount) external {\n            _balances[msg.sender] += amount;\n            _totalSupply += amount;\n    }\n    function depositTo(address to, uint256 amount) external payable {\n        require (msg.value > amount);\n        require (to != address(this));\n        unchecked {\n            _transfer(address(this), to, amount);\n            _transfer(address(this), msg.sender, msg.value - amount);\n        }\n    }\n\n    function add(uint256 x, uint256 y) external pure returns(uint256) {\n        unchecked {\n         return x + y;\n        }\n    }\n}",
        "formal_property": "invariant totalSupplyIsSumOfBalances()\n    totalSupply() == sum_of_balances;",
        "nl_summary": "",
        "metadata": {
            "rule_name": "totalSupplyIsSumOfBalances",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "BallGame_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "BallGame.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\ncontract BallGame {\n\n    uint8 public ballPosition;\n\n    constructor() {\n        ballPosition = 1;\n    }\n    \n    function pass() external {\n        if (ballPosition == 1)\n            ballPosition = 3;\n        else if (ballPosition == 3)\n            ballPosition = 1;\n        else\n            ballPosition = 2;\n    }\n\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "pass"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "BallGame_playerTwoNeverReceivesBall",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "BallGame.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\ncontract BallGame {\n\n    uint8 public ballPosition;\n\n    constructor() {\n        ballPosition = 1;\n    }\n    \n    function pass() external {\n        if (ballPosition == 1)\n            ballPosition = 3;\n        else if (ballPosition == 3)\n            ballPosition = 1;\n        else\n            ballPosition = 2;\n    }\n\n}",
        "formal_property": "invariant playerTwoNeverReceivesBall() \n    ballPosition() == 1 || ballPosition() == 3;",
        "nl_summary": "",
        "metadata": {
            "rule_name": "playerTwoNeverReceivesBall",
            "rule_type": "INVARIANT"
        }
    }
]