[
    {
        "id": "ContractA_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ContractA.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MainContract \n{\n    address currentBidder;\n    uint256 public currentBid;\n\n    function bid() public payable\n    {\n        require(msg.value >= address(this).balance);\n        payable(currentBidder).transfer(address(this).balance);\n        currentBidder = msg.sender; \n        currentBid = msg.value;\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "bid"
            ],
            "state_variables": [
                "currentBid",
                "currentBidder"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ContractA_demonstrates_047ee7a9",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ContractA.sol",
        "target_function": "bid",
        "text_chunk": "    function bid() public payable\n    {\n        require(msg.value >= address(this).balance);\n        payable(currentBidder).transfer(address(this).balance);\n        currentBidder = msg.sender; \n        currentBid = msg.value;\n    }\n",
        "formal_property": " This rule demonstrates how the source of amount transferred affects the balance of the current contract.\n This rule fails for `Auction.sol` because:\n 1. The balance of `currentContract` is increased by `msg.value` at the entrance to `bid()`.\n 2. the sender changes to `currentContract` in internal `bid()` and all his balance is transferred, so his balance does not increase.\n This rule passes for `AuctionFixed.sol` because only `currentBid` is transferred.\n */\nrule bidIncreasesAssets() {\n    env e;\n    require(e.msg.sender != currentContract);\n    require(e.msg.value > currentBid() );\n    uint256 balanceBefore = nativeBalances[currentContract];\n    bid(e);\n    assert nativeBalances[currentContract] > balanceBefore;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "demonstrates",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 14,
            "end_line": 27,
            "block_hash": "047ee7a9126e99901af47b69ed754d37"
        }
    },
    {
        "id": "ContractA_demonstrates_374a49ed",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ContractA.sol",
        "target_function": "bid",
        "text_chunk": "    function bid() public payable\n    {\n        require(msg.value >= address(this).balance);\n        payable(currentBidder).transfer(address(this).balance);\n        currentBidder = msg.sender; \n        currentBid = msg.value;\n    }\n",
        "formal_property": " This rule demonstrates how the source of amount transferred affects the balance of the current contract.\n This rule passes vacuously for `Auction.sol` because of the `require e.msg.value > nativeBalances[currentContract]` in the spec\n and `require msg.value >= msg.value + nativeBalances[currentContract]` in the code where `nativeBalances[currentContract] > 0`.\n It passes non-vacuously for AuctionFixed.sol because the amount transferred is `currentBid` for which `msg.value >= currentBid`\n can hold.\n */\nrule bidSuccessfullyExpectVacuous() {\n    env e;\n    uint256 balanceBefore = nativeBalances[currentContract];\n    require(e.msg.sender != currentContract);\n    require(e.msg.value > 0 &&  e.msg.value > balanceBefore);\n    require (balanceBefore > 0);\n    bid(e);\n    assert nativeBalances[currentContract] >= balanceBefore;\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "demonstrates",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 30,
            "end_line": 44,
            "block_hash": "374a49edf1c90de66acef92839dad734"
        }
    },
    {
        "id": "ERC1155_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC1155.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "supportsInterface",
                "uri",
                "balanceOf",
                "balanceOfBatch",
                "setApprovalForAll",
                "isApprovedForAll",
                "safeTransferFrom",
                "safeBatchTransferFrom",
                "_safeTransferFrom",
                "_safeBatchTransferFrom",
                "_setURI",
                "_mint",
                "_mintBatch",
                "_burn",
                "_burnBatch",
                "_setApprovalForAll",
                "_beforeTokenTransfer",
                "_afterTokenTransfer",
                "_doSafeTransferAcceptanceCheck",
                "_doSafeBatchTransferAcceptanceCheck",
                "_asSingletonArray"
            ],
            "state_variables": [
                "_operatorApprovals",
                "_uri",
                "_balances"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC1155_unexpectedAllowanceChange_0bde3929",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "setApprovalForAll",
        "text_chunk": "    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n",
        "formal_property": "rule unexpectedAllowanceChange(method f, env e) filtered { f -> f.selector != setApprovalForAll(address, bool).selector } {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "unexpectedAllowanceChange",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "setApprovalForAll"
            ],
            "start_line": 26,
            "end_line": 26,
            "block_hash": "0bde392927f548e556424b5c450ebaa0"
        }
    },
    {
        "id": "ERC1155_onlyOwnerCanApprove_cd2edc65",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "isApprovedForAll/setApprovalForAll",
        "text_chunk": "    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n",
        "formal_property": "rule onlyOwnerCanApprove(env e){\n    address owner; address operator; bool approved;\n\n    bool aprovalBefore = isApprovedForAll(owner, operator);\n    setApprovalForAll(e, operator, approved);\n    bool aprovalAfter = isApprovedForAll(owner, operator);\n    assert aprovalBefore != aprovalAfter => owner == e.msg.sender, \"There should be only one owner\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "onlyOwnerCanApprove",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "isApprovedForAll",
                "setApprovalForAll"
            ],
            "start_line": 41,
            "end_line": 51,
            "block_hash": "cd2edc6596cb537d52fbdf5a9454ed16"
        }
    },
    {
        "id": "ERC1155_approvalRevertCases_d19dcd11",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "isApprovedForAll",
        "text_chunk": "    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n",
        "formal_property": "rule approvalRevertCases(env e){\n    address account; address operator;\n    isApprovedForAll@withrevert(account, operator);\n    assert !lastReverted, \"Houston, we have a problem\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "approvalRevertCases",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "isApprovedForAll"
            ],
            "start_line": 56,
            "end_line": 60,
            "block_hash": "d19dcd11755086dd48aad45a065a0425"
        }
    },
    {
        "id": "ERC1155_onlyOneAllowanceChange_7f750b76",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "isApprovedForAll/setApprovalForAll",
        "text_chunk": "    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n",
        "formal_property": "rule onlyOneAllowanceChange(method f, env e) {\n    address owner; address operator; address user; \n    bool approved;\n\n    bool userApproveBefore = isApprovedForAll(owner, user);\n    setApprovalForAll(e, operator, approved);\n    bool userApproveAfter = isApprovedForAll(owner, user);\n    assert userApproveBefore != userApproveAfter => (e.msg.sender == owner && operator == user), \"Imposter!\";\n}   \n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "onlyOneAllowanceChange",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "isApprovedForAll",
                "setApprovalForAll"
            ],
            "start_line": 65,
            "end_line": 76,
            "block_hash": "7f750b767d7b07fa83c428866b870bdb"
        }
    },
    {
        "id": "ERC1155_unexpectedBalanceChange_741b14db",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "safeBatchTransferFrom/safeTransferFrom",
        "text_chunk": "    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n",
        "formal_property": "rule unexpectedBalanceChange(method f, env e) \n    filtered { f -> f.selector != safeTransferFrom(address, address, uint256, uint256, bytes).selector\n                        && f.selector != safeBatchTransferFrom(address, address, uint256[], uint256[], bytes).selector \n                        && f.selector != mint(address, uint256, uint256, bytes).selector \n                        && f.selector != mintBatch(address, uint256[], uint256[], bytes).selector  \n                        && f.selector != burn(address, uint256, uint256).selector \n                        && f.selector != burnBatch(address, uint256[], uint256[]).selector } {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "unexpectedBalanceChange",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "safeTransferFrom",
                "safeBatchTransferFrom",
                "mint",
                "mintBatch",
                "burn",
                "burnBatch"
            ],
            "start_line": 87,
            "end_line": 93,
            "block_hash": "741b14dbdaabfd39ee16de9edd70e901"
        }
    },
    {
        "id": "ERC1155_balanceOfRevertCases_42a54e28",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n",
        "formal_property": "rule balanceOfRevertCases(env e){\n    address account; uint256 id;\n    balanceOf@withrevert(account, id);\n    assert lastReverted => account == 0, \"Houston, we have a problem\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "balanceOfRevertCases",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf"
            ],
            "start_line": 108,
            "end_line": 112,
            "block_hash": "42a54e28d560c154a1101593584f73f2"
        }
    },
    {
        "id": "ERC1155_balanceOfBatchRevertCases_d18f7fa7",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf/balanceOfBatch",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n",
        "formal_property": "rule balanceOfBatchRevertCases(env e){\n    address[] accounts; uint256[] ids;\n    address account1; address account2; address account3;\n    uint256 id1; uint256 id2; uint256 id3;\n\n    require accounts.length == 3; \n    require ids.length == 3; \n    require accounts[0] == account1; require accounts[1] == account2; require accounts[2] == account3;\n    balanceOfBatch@withrevert(accounts, ids);\n    assert lastReverted => (account1 == 0 || account2 == 0 || account3 == 0), \"Houston, we have a problem\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "balanceOfBatchRevertCases",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "balanceOfBatch"
            ],
            "start_line": 117,
            "end_line": 129,
            "block_hash": "d18f7fa772de8cc58294196bd29bb3eb"
        }
    },
    {
        "id": "ERC1155_transferAdditivity_94fed8d7",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf/safeTransferFrom",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n",
        "formal_property": "rule transferAdditivity(env e){\n    address from; address to; uint256 id; bytes data;\n    uint256 amount; uint256 amount1; uint256 amount2;\n    require amount == amount1 + amount2;\n\n    storage initialStorage = lastStorage;\n    safeTransferFrom(e, from, to, id, amount, data);\n    uint256 balanceAfterSingleTransaction = balanceOf(to, id);\n    safeTransferFrom(e, from, to, id, amount1, data) at initialStorage;\n    safeTransferFrom(e, from, to, id, amount2, data);\n    uint256 balanceAfterDoubleTransaction = balanceOf(to, id);\n    assert balanceAfterSingleTransaction == balanceAfterDoubleTransaction, \"Not additive\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferAdditivity",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "safeTransferFrom"
            ],
            "start_line": 140,
            "end_line": 157,
            "block_hash": "94fed8d7111aaec384f2678b7655c257"
        }
    },
    {
        "id": "ERC1155_transferCorrectness_9984312b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf/safeTransferFrom",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n",
        "formal_property": "rule transferCorrectness(env e){\n    address from; address to; uint256 id; uint256 amount; bytes data;\n\n    require to != from;\n    uint256 fromBalanceBefore = balanceOf(from, id);\n    uint256 toBalanceBefore = balanceOf(to, id);\n    safeTransferFrom(e, from, to, id, amount, data);\n    uint256 fromBalanceAfter = balanceOf(from, id);\n    uint256 toBalanceAfter = balanceOf(to, id);\n    assert fromBalanceBefore == fromBalanceAfter + amount, \"Something wet wrong\";\n    assert toBalanceBefore == toBalanceAfter - amount, \"Something wet wrong\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferCorrectness",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "safeTransferFrom"
            ],
            "start_line": 162,
            "end_line": 177,
            "block_hash": "9984312bbb89f86a32bca74e40cbdbc7"
        }
    },
    {
        "id": "ERC1155_transferBatchCorrectness_01140aa4",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf/safeBatchTransferFrom",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n",
        "formal_property": "rule transferBatchCorrectness(env e){\n    address from; address to; uint256[] ids; uint256[] amounts; bytes data;\n    uint256 idToCheck1; uint256 amountToCheck1;\n    uint256 idToCheck2; uint256 amountToCheck2;\n    uint256 idToCheck3; uint256 amountToCheck3;\n\n    require to != from;\n    require idToCheck1 != idToCheck2 && idToCheck3 != idToCheck2 && idToCheck1 != idToCheck3;\n    \n    require ids.length == 3;        \n    require amounts.length == 3;    \n    require ids[0] == idToCheck1; require amounts[0] == amountToCheck1;\n    require ids[1] == idToCheck2; require amounts[1] == amountToCheck2;\n    require ids[2] == idToCheck3; require amounts[2] == amountToCheck3;\n    uint256 fromBalanceBefore1 = balanceOf(from, idToCheck1);\n    uint256 fromBalanceBefore2 = balanceOf(from, idToCheck2);\n    uint256 fromBalanceBefore3 = balanceOf(from, idToCheck3);\n    uint256 toBalanceBefore1 = balanceOf(to, idToCheck1);\n    uint256 toBalanceBefore2 = balanceOf(to, idToCheck2);\n    uint256 toBalanceBefore3 = balanceOf(to, idToCheck3);\n    safeBatchTransferFrom(e, from, to, ids, amounts, data);\n    uint256 fromBalanceAfter1 = balanceOf(from, idToCheck1);\n    uint256 fromBalanceAfter2 = balanceOf(from, idToCheck2);\n    uint256 fromBalanceAfter3 = balanceOf(from, idToCheck3);\n    uint256 toBalanceAfter1 = balanceOf(to, idToCheck1);\n    uint256 toBalanceAfter2 = balanceOf(to, idToCheck2);\n    uint256 toBalanceAfter3 = balanceOf(to, idToCheck3);\n    assert (fromBalanceBefore1 == fromBalanceAfter1 + amountToCheck1)\n                && (fromBalanceBefore2 == fromBalanceAfter2 + amountToCheck2)\n                && (fromBalanceBefore3 == fromBalanceAfter3 + amountToCheck3), \"Something wet wrong\";\n    assert (toBalanceBefore1 == toBalanceAfter1 - amountToCheck1)\n                && (toBalanceBefore2 == toBalanceAfter2 - amountToCheck2)\n                && (toBalanceBefore3 == toBalanceAfter3 - amountToCheck3), \"Something wet wrong\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferBatchCorrectness",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "safeBatchTransferFrom"
            ],
            "start_line": 182,
            "end_line": 221,
            "block_hash": "01140aa4097002d34e8f51891d709638"
        }
    },
    {
        "id": "ERC1155_cannotTransferMoreSingle_c0114da5",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf/safeTransferFrom",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n",
        "formal_property": "rule cannotTransferMoreSingle(env e){\n    address from; address to; uint256 id; uint256 amount; bytes data;\n    uint256 balanceBefore = balanceOf(from, id);\n\n    safeTransferFrom@withrevert(e, from, to, id, amount, data);\n    assert amount > balanceBefore => lastReverted, \"Achtung! Scammer!\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cannotTransferMoreSingle",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "safeTransferFrom"
            ],
            "start_line": 226,
            "end_line": 233,
            "block_hash": "c0114da547d03acc2ad1a97c537c0990"
        }
    },
    {
        "id": "ERC1155_cannotTransferMoreBatch_a55f7320",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf/safeBatchTransferFrom",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n",
        "formal_property": "rule cannotTransferMoreBatch(env e){\n    address from; address to; uint256[] ids; uint256[] amounts; bytes data;\n    uint256 idToCheck1; uint256 amountToCheck1;\n    uint256 idToCheck2; uint256 amountToCheck2;\n    uint256 idToCheck3; uint256 amountToCheck3;\n\n    uint256 balanceBefore1 = balanceOf(from, idToCheck1);\n    uint256 balanceBefore2 = balanceOf(from, idToCheck2);\n    uint256 balanceBefore3 = balanceOf(from, idToCheck3);\n    require ids.length == 3;        \n    require amounts.length == 3;    \n    require ids[0] == idToCheck1; require amounts[0] == amountToCheck1;\n    require ids[1] == idToCheck2; require amounts[1] == amountToCheck2;\n    require ids[2] == idToCheck3; require amounts[2] == amountToCheck3;\n    safeBatchTransferFrom@withrevert(e, from, to, ids, amounts, data);\n    assert (amountToCheck1 > balanceBefore1 || amountToCheck2 > balanceBefore2 || amountToCheck3 > balanceBefore3) => lastReverted, \"Achtung! Scammer!\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cannotTransferMoreBatch",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "safeBatchTransferFrom"
            ],
            "start_line": 238,
            "end_line": 257,
            "block_hash": "a55f732085c522308406d274641b8c72"
        }
    },
    {
        "id": "ERC1155_transferBalanceReduceEffect_be79be39",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf/safeTransferFrom",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n",
        "formal_property": "rule transferBalanceReduceEffect(env e){\n    address from; address to; address other;\n    uint256 id; uint256 amount; \n    bytes data;\n\n    require other != to;\n    uint256 otherBalanceBefore = balanceOf(other, id);\n    safeTransferFrom(e, from, to, id, amount, data);\n    uint256 otherBalanceAfter = balanceOf(other, id);\n    assert from != other => otherBalanceBefore == otherBalanceAfter, \"Don't touch my money!\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferBalanceReduceEffect",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "safeTransferFrom"
            ],
            "start_line": 262,
            "end_line": 276,
            "block_hash": "be79be396b04c8467e4102f8b1034783"
        }
    },
    {
        "id": "ERC1155_transferBalanceIncreaseEffect_3711fe62",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf/safeTransferFrom",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n",
        "formal_property": "rule transferBalanceIncreaseEffect(env e){\n    address from; address to; address other;\n    uint256 id; uint256 amount; \n    bytes data;\n\n    require from != other;\n    uint256 otherBalanceBefore = balanceOf(other, id);\n    safeTransferFrom(e, from, to, id, amount, data);\n    uint256 otherBalanceAfter = balanceOf(other, id);\n    assert other != to => otherBalanceBefore == otherBalanceAfter, \"Don't touch my money!\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferBalanceIncreaseEffect",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "safeTransferFrom"
            ],
            "start_line": 281,
            "end_line": 295,
            "block_hash": "3711fe62a129bad91e9371aee64bf37c"
        }
    },
    {
        "id": "ERC1155_transferBatchBalanceFromEffect_12bbc927",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf/safeBatchTransferFrom",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n",
        "formal_property": "rule transferBatchBalanceFromEffect(env e){\n    address from; address to; address other;\n    uint256[] ids; uint256[] amounts;\n    uint256 id1; uint256 amount1; uint256 id2; uint256 amount2; uint256 id3; uint256 amount3;\n    bytes data;\n\n    require other != to;\n    uint256 otherBalanceBefore1 = balanceOf(other, id1);\n    uint256 otherBalanceBefore2 = balanceOf(other, id2);\n    uint256 otherBalanceBefore3 = balanceOf(other, id3);\n    safeBatchTransferFrom(e, from, to, ids, amounts, data);\n    uint256 otherBalanceAfter1 = balanceOf(other, id1);\n    uint256 otherBalanceAfter2 = balanceOf(other, id2);\n    uint256 otherBalanceAfter3 = balanceOf(other, id3);\n    assert from != other => (otherBalanceBefore1 == otherBalanceAfter1 \n                                && otherBalanceBefore2 == otherBalanceAfter2 \n                                && otherBalanceBefore3 == otherBalanceAfter3), \"Don't touch my money!\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferBatchBalanceFromEffect",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "safeBatchTransferFrom"
            ],
            "start_line": 300,
            "end_line": 321,
            "block_hash": "12bbc927fbb97dba153104df007028c4"
        }
    },
    {
        "id": "ERC1155_transferBatchBalanceToEffect_2f74183b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf/safeBatchTransferFrom",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n",
        "formal_property": "rule transferBatchBalanceToEffect(env e){\n    address from; address to; address other;\n    uint256[] ids; uint256[] amounts;\n    uint256 id1; uint256 amount1; uint256 id2; uint256 amount2; uint256 id3; uint256 amount3;\n    bytes data;\n\n    require other != from;\n    uint256 otherBalanceBefore1 = balanceOf(other, id1);\n    uint256 otherBalanceBefore2 = balanceOf(other, id2);\n    uint256 otherBalanceBefore3 = balanceOf(other, id3);\n    safeBatchTransferFrom(e, from, to, ids, amounts, data);\n    uint256 otherBalanceAfter1 = balanceOf(other, id1);\n    uint256 otherBalanceAfter2 = balanceOf(other, id2);\n    uint256 otherBalanceAfter3 = balanceOf(other, id3);\n    assert other != to => (otherBalanceBefore1 == otherBalanceAfter1 \n                                && otherBalanceBefore2 == otherBalanceAfter2 \n                                && otherBalanceBefore3 == otherBalanceAfter3), \"Don't touch my money!\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferBatchBalanceToEffect",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "safeBatchTransferFrom"
            ],
            "start_line": 326,
            "end_line": 347,
            "block_hash": "2f74183bf7fd564228b1c285da222e56"
        }
    },
    {
        "id": "ERC1155_noTransferForNotApproved_aaeccdd3",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "isApprovedForAll/safeTransferFrom",
        "text_chunk": "    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n",
        "formal_property": "rule noTransferForNotApproved(env e) {\n    address from; address operator;\n    address to; uint256 id; uint256 amount; bytes data;\n\n    require from != e.msg.sender;\n    bool approve = isApprovedForAll(from, e.msg.sender);\n    safeTransferFrom@withrevert(e, from, to, id, amount, data);\n    assert !approve => lastReverted, \"You don't have king's approval!\";\n}   \n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "noTransferForNotApproved",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "isApprovedForAll",
                "safeTransferFrom"
            ],
            "start_line": 352,
            "end_line": 363,
            "block_hash": "aaeccdd3ceba1b3af6b4efaea4891bf9"
        }
    },
    {
        "id": "ERC1155_noTransferBatchForNotApproved_daa1af76",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "isApprovedForAll/safeBatchTransferFrom",
        "text_chunk": "    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n",
        "formal_property": "rule noTransferBatchForNotApproved(env e) {\n    address from; address operator; address to; \n    bytes data;\n    uint256[] ids; uint256[] amounts;\n\n    require from != e.msg.sender;\n    bool approve = isApprovedForAll(from, e.msg.sender);\n    safeBatchTransferFrom@withrevert(e, from, to, ids, amounts, data);\n    assert !approve => lastReverted, \"You don't have king's approval!\";\n}   \n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "noTransferBatchForNotApproved",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "isApprovedForAll",
                "safeBatchTransferFrom"
            ],
            "start_line": 368,
            "end_line": 380,
            "block_hash": "daa1af76aac475c4430080dddab49849"
        }
    },
    {
        "id": "ERC1155_noTransferEffectOnApproval_16c413a8",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "isApprovedForAll/safeTransferFrom",
        "text_chunk": "    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n",
        "formal_property": "rule noTransferEffectOnApproval(env e){\n    address from; address to;\n    address owner; address operator;\n    uint256 id; uint256 amount; \n    bytes data;\n\n    bool approveBefore = isApprovedForAll(owner, operator);\n    safeTransferFrom(e, from, to, id, amount, data);\n    bool approveAfter = isApprovedForAll(owner, operator);\n    assert approveBefore == approveAfter, \"Something was effected\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "noTransferEffectOnApproval",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "isApprovedForAll",
                "safeTransferFrom"
            ],
            "start_line": 385,
            "end_line": 398,
            "block_hash": "16c413a8816160d8bfa05b3c51d3e4b9"
        }
    },
    {
        "id": "ERC1155_noTransferBatchEffectOnApproval_ea660981",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "isApprovedForAll/safeBatchTransferFrom",
        "text_chunk": "    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n",
        "formal_property": "rule noTransferBatchEffectOnApproval(env e){\n    address from; address to;\n    address owner; address operator;\n    uint256[] ids; uint256[] amounts;\n    bytes data;\n\n    bool approveBefore = isApprovedForAll(owner, operator);\n    safeBatchTransferFrom(e, from, to, ids, amounts, data);\n    bool approveAfter = isApprovedForAll(owner, operator);\n    assert approveBefore == approveAfter, \"Something was effected\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "noTransferBatchEffectOnApproval",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "isApprovedForAll",
                "safeBatchTransferFrom"
            ],
            "start_line": 403,
            "end_line": 416,
            "block_hash": "ea66098178b3db47dee58539af4eb6d3"
        }
    },
    {
        "id": "ERC1155_mintAdditivity_a2fd2aeb",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n",
        "formal_property": "rule mintAdditivity(env e){\n    address to; uint256 id; uint256 amount; uint256 amount1; uint256 amount2; bytes data;\n    require amount == amount1 + amount2;\n\n    storage initialStorage = lastStorage;\n    mint(e, to, id, amount, data);\n    uint256 balanceAfterSingleTransaction = balanceOf(to, id);\n    mint(e, to, id, amount1, data) at initialStorage;\n    mint(e, to, id, amount2, data);\n    uint256 balanceAfterDoubleTransaction = balanceOf(to, id);\n    assert balanceAfterSingleTransaction == balanceAfterDoubleTransaction, \"Not additive\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "mintAdditivity",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "mint"
            ],
            "start_line": 427,
            "end_line": 443,
            "block_hash": "a2fd2aebae6b7b34b7ff83570f445099"
        }
    },
    {
        "id": "ERC1155_mintRevertCases_d5176365",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n",
        "formal_property": "rule mintRevertCases(env e){\n    address to; uint256 id; uint256 amount; bytes data;\n\n    mint@withrevert(e, to, id, amount, data);\n    assert to == 0 => lastReverted, \"Should revert\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "mintRevertCases",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint"
            ],
            "start_line": 448,
            "end_line": 454,
            "block_hash": "d517636580331a961190269706016c08"
        }
    },
    {
        "id": "ERC1155_mintBatchRevertCases_f0ae0a83",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n",
        "formal_property": "rule mintBatchRevertCases(env e){\n    address to; uint256[] ids; uint256[] amounts; bytes data;\n\n    require ids.length < 1000000000;\n    require amounts.length < 1000000000;\n    mintBatch@withrevert(e, to, ids, amounts, data);\n    assert (ids.length != amounts.length || to == 0) => lastReverted, \"Should revert\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "mintBatchRevertCases",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint",
                "mintBatch"
            ],
            "start_line": 459,
            "end_line": 468,
            "block_hash": "f0ae0a8370db7f701151a6d0f0167e73"
        }
    },
    {
        "id": "ERC1155_mintCorrectWork_21895366",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n",
        "formal_property": "rule mintCorrectWork(env e){\n    address to; uint256 id; uint256 amount; bytes data;\n\n    uint256 otherBalanceBefore = balanceOf(to, id);\n    mint(e, to, id, amount, data);\n    uint256 otherBalanceAfter = balanceOf(to, id);\n    \n    assert otherBalanceBefore == otherBalanceAfter - amount, \"Something is wrong\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "mintCorrectWork",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "mint"
            ],
            "start_line": 473,
            "end_line": 483,
            "block_hash": "218953668cc7a80fda109c1819e4b512"
        }
    },
    {
        "id": "ERC1155_mintBatchCorrectWork_9029b52b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n",
        "formal_property": "rule mintBatchCorrectWork(env e){\n    address to;\n    uint256 id1; uint256 id2; uint256 id3; \n    uint256 amount1; uint256 amount2; uint256 amount3;\n    uint256[] ids; uint256[] amounts;\n    bytes data;\n\n    require ids.length == 3; \n    require amounts.length == 3; \n    require id1 != id2 && id2 != id3 && id3 != id1;\n    require ids[0] == id1; require ids[1] == id2; require ids[2] == id3;\n    require amounts[0] == amount1; require amounts[1] == amount2; require amounts[2] == amount3;\n    uint256 otherBalanceBefore1 = balanceOf(to, id1);\n    uint256 otherBalanceBefore2 = balanceOf(to, id2);\n    uint256 otherBalanceBefore3 = balanceOf(to, id3);\n    mintBatch(e, to, ids, amounts, data);\n    uint256 otherBalanceAfter1 = balanceOf(to, id1);\n    uint256 otherBalanceAfter2 = balanceOf(to, id2);\n    uint256 otherBalanceAfter3 = balanceOf(to, id3);\n    \n    assert otherBalanceBefore1 == otherBalanceAfter1 - amount1\n            && otherBalanceBefore2 == otherBalanceAfter2 - amount2\n            && otherBalanceBefore3 == otherBalanceAfter3 - amount3\n            , \"Something is wrong\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "mintBatchCorrectWork",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "mint",
                "mintBatch"
            ],
            "start_line": 488,
            "end_line": 516,
            "block_hash": "9029b52b0b44bd8f5fbd2004fea67194"
        }
    },
    {
        "id": "ERC1155_cantMintMoreSingle_cb19cca2",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n",
        "formal_property": "rule cantMintMoreSingle(env e){\n    address to; uint256 id; uint256 amount; bytes data;\n\n    require to_mathint(balanceOf(to, id) + amount) > max_uint256;\n    mint@withrevert(e, to, id, amount, data);\n    \n    assert lastReverted, \"Don't be too greedy!\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cantMintMoreSingle",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "mint"
            ],
            "start_line": 521,
            "end_line": 529,
            "block_hash": "cb19cca2c23cf397d325d71238a2ba2e"
        }
    },
    {
        "id": "ERC1155_cantMintMoreBatch_09fed02d",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n",
        "formal_property": "rule cantMintMoreBatch(env e){\n    address to; bytes data;\n    uint256 id1; uint256 id2; uint256 id3; \n    uint256 amount1; uint256 amount2; uint256 amount3;\n    uint256[] ids; uint256[] amounts;\n\n    require ids.length == 3; \n    require amounts.length == 3;\n    require ids[0] == id1; require ids[1] == id2; require ids[2] == id3;\n    require amounts[0] == amount1; require amounts[1] == amount2; require amounts[2] == amount3;\n    require to_mathint(balanceOf(to, id1) + amount1) > max_uint256 \n                || to_mathint(balanceOf(to, id2) + amount2) > max_uint256\n                || to_mathint(balanceOf(to, id3) + amount3) > max_uint256;\n    mintBatch@withrevert(e, to, ids, amounts, data);\n    \n    assert lastReverted, \"Don't be too greedy!\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cantMintMoreBatch",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "mint",
                "mintBatch"
            ],
            "start_line": 534,
            "end_line": 553,
            "block_hash": "09fed02d108e3ba66ada09dc7eac7c9f"
        }
    },
    {
        "id": "ERC1155_cantMintOtherBalances_6b00bbbe",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n",
        "formal_property": "rule cantMintOtherBalances(env e){\n    address to; uint256 id; uint256 amount; bytes data;\n    address other;\n\n    uint256 otherBalanceBefore = balanceOf(other, id);\n    mint(e, to, id, amount, data);\n    uint256 otherBalanceAfter = balanceOf(other, id);\n    \n    assert other != to => otherBalanceBefore == otherBalanceAfter, \"I like to see your money disappearing\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cantMintOtherBalances",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "mint"
            ],
            "start_line": 558,
            "end_line": 569,
            "block_hash": "6b00bbbe45ede75d7ddd5141b1a9c16e"
        }
    },
    {
        "id": "ERC1155_cantMintBatchOtherBalances_16cb5565",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n",
        "formal_property": "rule cantMintBatchOtherBalances(env e){\n    address to;\n    uint256 id1; uint256 id2; uint256 id3; \n    uint256[] ids; uint256[] amounts;\n    address other;\n    bytes data;\n\n    uint256 otherBalanceBefore1 = balanceOf(other, id1);\n    uint256 otherBalanceBefore2 = balanceOf(other, id2);\n    uint256 otherBalanceBefore3 = balanceOf(other, id3);\n    mintBatch(e, to, ids, amounts, data);\n    uint256 otherBalanceAfter1 = balanceOf(other, id1);\n    uint256 otherBalanceAfter2 = balanceOf(other, id2);\n    uint256 otherBalanceAfter3 = balanceOf(other, id3);\n    \n    assert other != to => (otherBalanceBefore1 == otherBalanceAfter1 \n                                && otherBalanceBefore2 == otherBalanceAfter2 \n                                && otherBalanceBefore3 == otherBalanceAfter3)\n                                , \"I like to see your money disappearing\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cantMintBatchOtherBalances",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "mint",
                "mintBatch"
            ],
            "start_line": 574,
            "end_line": 595,
            "block_hash": "16cb556580292d5ad2a6e776ac813f67"
        }
    },
    {
        "id": "ERC1155_burnAdditivity_0647824a",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n",
        "formal_property": "rule burnAdditivity(env e){\n    address from; uint256 id; uint256 amount; uint256 amount1; uint256 amount2;\n    require amount == amount1 + amount2;\n\n    storage initialStorage = lastStorage;\n    burn(e, from, id, amount);\n    uint256 balanceAfterSingleTransaction = balanceOf(from, id);\n    burn(e, from, id, amount1) at initialStorage;\n    burn(e, from, id, amount2);\n    uint256 balanceAfterDoubleTransaction = balanceOf(from, id);\n    assert balanceAfterSingleTransaction == balanceAfterDoubleTransaction, \"Not additive\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burnAdditivity",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "burn"
            ],
            "start_line": 605,
            "end_line": 621,
            "block_hash": "0647824a571bb13b234f2ba862c8278e"
        }
    },
    {
        "id": "ERC1155_burnRevertCases_2423bfd1",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n",
        "formal_property": "rule burnRevertCases(env e){\n    address from; uint256 id; uint256 amount;\n\n    burn@withrevert(e, from, id, amount);\n    assert from == 0 => lastReverted, \"Should revert\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burnRevertCases",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "burn"
            ],
            "start_line": 626,
            "end_line": 632,
            "block_hash": "2423bfd17ecf2ad6ff1922346540f51e"
        }
    },
    {
        "id": "ERC1155_burnBatchRevertCases_1279403c",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    string private _uri;\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n",
        "formal_property": "rule burnBatchRevertCases(env e){\n    address from; uint256[] ids; uint256[] amounts;\n\n    require ids.length < 1000000000;\n    require amounts.length < 1000000000;\n    burnBatch@withrevert(e, from, ids, amounts);\n    assert (from == 0 || ids.length != amounts.length) => lastReverted, \"Should revert\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burnBatchRevertCases",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "burn",
                "burnBatch"
            ],
            "start_line": 637,
            "end_line": 646,
            "block_hash": "1279403ccb6456d673ec9c838975f6eb"
        }
    },
    {
        "id": "ERC1155_burnCorrectWork_27fff8f4",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n",
        "formal_property": "rule burnCorrectWork(env e){\n    address from; uint256 id; uint256 amount;\n\n    uint256 otherBalanceBefore = balanceOf(from, id);\n    burn(e, from, id, amount);\n    uint256 otherBalanceAfter = balanceOf(from, id);\n    \n    assert otherBalanceBefore == otherBalanceAfter + amount, \"Something is wrong\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burnCorrectWork",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "burn"
            ],
            "start_line": 651,
            "end_line": 661,
            "block_hash": "27fff8f45a851e68f1f8110d68f86fb0"
        }
    },
    {
        "id": "ERC1155_burnBatchCorrectWork_9f8c53ca",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n",
        "formal_property": "rule burnBatchCorrectWork(env e){\n    address from;\n    uint256 id1; uint256 id2; uint256 id3; \n    uint256 amount1; uint256 amount2; uint256 amount3;\n    uint256[] ids; uint256[] amounts;\n\n    require ids.length == 3; \n    require id1 != id2 && id2 != id3 && id3 != id1;\n    require ids[0] == id1; require ids[1] == id2; require ids[2] == id3;\n    require amounts[0] == amount1; require amounts[1] == amount2; require amounts[2] == amount3;\n    uint256 otherBalanceBefore1 = balanceOf(from, id1);\n    uint256 otherBalanceBefore2 = balanceOf(from, id2);\n    uint256 otherBalanceBefore3 = balanceOf(from, id3);\n    burnBatch(e, from, ids, amounts);\n    uint256 otherBalanceAfter1 = balanceOf(from, id1);\n    uint256 otherBalanceAfter2 = balanceOf(from, id2);\n    uint256 otherBalanceAfter3 = balanceOf(from, id3);\n    \n    assert otherBalanceBefore1 == otherBalanceAfter1 + amount1\n            && otherBalanceBefore2 == otherBalanceAfter2 + amount2\n            && otherBalanceBefore3 == otherBalanceAfter3 + amount3\n            , \"Something is wrong\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burnBatchCorrectWork",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "burn",
                "burnBatch"
            ],
            "start_line": 666,
            "end_line": 692,
            "block_hash": "9f8c53cada982444d7e9e73cf4a18d7d"
        }
    },
    {
        "id": "ERC1155_cantBurnMoreSingle_f401bb12",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n",
        "formal_property": "rule cantBurnMoreSingle(env e){\n    address from; uint256 id; uint256 amount;\n\n    require to_mathint(balanceOf(from, id) - amount) < 0;\n    burn@withrevert(e, from, id, amount);\n    \n    assert lastReverted, \"Don't be too greedy!\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cantBurnMoreSingle",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "burn"
            ],
            "start_line": 697,
            "end_line": 705,
            "block_hash": "f401bb125f4a2b0e6641a137b9db063d"
        }
    },
    {
        "id": "ERC1155_cantBurnMoreBatch_e89793ed",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n",
        "formal_property": "rule cantBurnMoreBatch(env e){\n    address from;\n    uint256 id1; uint256 id2; uint256 id3; \n    uint256 amount1; uint256 amount2; uint256 amount3;\n    uint256[] ids; uint256[] amounts;\n\n    require ids.length == 3; \n    require ids[0] == id1; require ids[1] == id2; require ids[2] == id3;\n    require amounts[0] == amount1; require amounts[1] == amount2; require amounts[2] == amount3;\n    require to_mathint(balanceOf(from, id1) - amount1) < 0 \n                || to_mathint(balanceOf(from, id2) - amount2) < 0 \n                || to_mathint(balanceOf(from, id3) - amount3) < 0 ;\n    burnBatch@withrevert(e, from, ids, amounts);\n    \n    assert lastReverted, \"Don't be too greedy!\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cantBurnMoreBatch",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "burn",
                "burnBatch"
            ],
            "start_line": 710,
            "end_line": 728,
            "block_hash": "e89793ed023d9f48f6f5bf3375216daa"
        }
    },
    {
        "id": "ERC1155_cantBurnOtherBalances_871424cd",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n",
        "formal_property": "rule cantBurnOtherBalances(env e){\n    address from; uint256 id; uint256 amount;\n    address other;\n\n    uint256 otherBalanceBefore = balanceOf(other, id);\n    burn(e, from, id, amount);\n    uint256 otherBalanceAfter = balanceOf(other, id);\n    \n    assert other != from => otherBalanceBefore == otherBalanceAfter, \"I like to see your money disappearing\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cantBurnOtherBalances",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "burn"
            ],
            "start_line": 733,
            "end_line": 744,
            "block_hash": "871424cdaf0c9f25bf25bcb8de4ab6a7"
        }
    },
    {
        "id": "ERC1155_cantBurnBatchOtherBalances_a664d6fe",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n",
        "formal_property": "rule cantBurnBatchOtherBalances(env e){\n    address from;\n    uint256 id1; uint256 id2; uint256 id3; \n    uint256 amount1; uint256 amount2; uint256 amount3;\n    uint256[] ids; uint256[] amounts;\n    address other;\n\n    uint256 otherBalanceBefore1 = balanceOf(other, id1);\n    uint256 otherBalanceBefore2 = balanceOf(other, id2);\n    uint256 otherBalanceBefore3 = balanceOf(other, id3);\n    burnBatch(e, from, ids, amounts);\n    uint256 otherBalanceAfter1 = balanceOf(other, id1);\n    uint256 otherBalanceAfter2 = balanceOf(other, id2);\n    uint256 otherBalanceAfter3 = balanceOf(other, id3);\n    \n    assert other != from => (otherBalanceBefore1 == otherBalanceAfter1 \n                                && otherBalanceBefore2 == otherBalanceAfter2 \n                                && otherBalanceBefore3 == otherBalanceAfter3)\n                                , \"I like to see your money disappearing\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cantBurnBatchOtherBalances",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "burn",
                "burnBatch"
            ],
            "start_line": 749,
            "end_line": 770,
            "block_hash": "a664d6fec84d9218667a4ac5f6f299eb"
        }
    },
    {
        "id": "ERC1155_singleTokenSafeTransferFromSafeBatchTransferFromEquivalence_a6c739b0",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf/safeBatchTransferFrom/safeTransferFrom",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n",
        "formal_property": "rule singleTokenSafeTransferFromSafeBatchTransferFromEquivalence {\n    storage beforeTransfer = lastStorage;\n    env e;\n\n    address holder; address recipient;\n    uint256 token; uint256 transferAmount; bytes data;\n    uint256[] tokens; uint256[] transferAmounts;\n    mathint holderStartingBalance = balanceOf(holder, token);\n    mathint recipientStartingBalance = balanceOf(recipient, token);\n    require tokens.length == 1; require transferAmounts.length == 1;\n    require tokens[0] == token; require transferAmounts[0] == transferAmount;\n    // transferring via safeTransferFrom\n    safeTransferFrom(e, holder, recipient, token, transferAmount, data) at beforeTransfer;\n    mathint holderSafeTransferFromBalanceChange = holderStartingBalance - balanceOf(holder, token);\n    mathint recipientSafeTransferFromBalanceChange = balanceOf(recipient, token) - recipientStartingBalance;\n    // transferring via safeBatchTransferFrom\n    safeBatchTransferFrom(e, holder, recipient, tokens, transferAmounts, data) at beforeTransfer;\n    mathint holderSafeBatchTransferFromBalanceChange = holderStartingBalance - balanceOf(holder, token);\n    mathint recipientSafeBatchTransferFromBalanceChange = balanceOf(recipient, token) - recipientStartingBalance;\n    assert holderSafeTransferFromBalanceChange == holderSafeBatchTransferFromBalanceChange\n        && recipientSafeTransferFromBalanceChange == recipientSafeBatchTransferFromBalanceChange, \n        \"Transferring a single token via safeTransferFrom or safeBatchTransferFrom must be equivalent\";\n}   \n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "singleTokenSafeTransferFromSafeBatchTransferFromEquivalence",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "safeTransferFrom",
                "safeBatchTransferFrom"
            ],
            "start_line": 779,
            "end_line": 806,
            "block_hash": "a6c739b0bab38cc5c86f9c0ddf600dd3"
        }
    },
    {
        "id": "ERC1155_multipleTokenSafeTransferFromSafeBatchTransferFromEquivalence_35799dd1",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "balanceOf/safeBatchTransferFrom/safeTransferFrom",
        "text_chunk": "    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n",
        "formal_property": "rule multipleTokenSafeTransferFromSafeBatchTransferFromEquivalence {\n    storage beforeTransfers = lastStorage;\n    env e;\n\n    address holder; address recipient; bytes data;\n    uint256 tokenA; uint256 tokenB; uint256 tokenC;\n    uint256 transferAmountA; uint256 transferAmountB; uint256 transferAmountC;\n    uint256[] tokens; uint256[] transferAmounts;\n    mathint holderStartingBalanceA = balanceOf(holder, tokenA);\n    mathint holderStartingBalanceB = balanceOf(holder, tokenB);\n    mathint holderStartingBalanceC = balanceOf(holder, tokenC);\n    mathint recipientStartingBalanceA = balanceOf(recipient, tokenA);\n    mathint recipientStartingBalanceB = balanceOf(recipient, tokenB);\n    mathint recipientStartingBalanceC = balanceOf(recipient, tokenC);\n    require tokens.length == 3; require transferAmounts.length == 3;\n    require tokens[0] == tokenA; require transferAmounts[0] == transferAmountA;\n    require tokens[1] == tokenB; require transferAmounts[1] == transferAmountB;\n    require tokens[2] == tokenC; require transferAmounts[2] == transferAmountC;\n    // transferring via safeTransferFrom\n    safeTransferFrom(e, holder, recipient, tokenA, transferAmountA, data) at beforeTransfers;\n    safeTransferFrom(e, holder, recipient, tokenB, transferAmountB, data);\n    safeTransferFrom(e, holder, recipient, tokenC, transferAmountC, data);\n    mathint holderSafeTransferFromBalanceChangeA = holderStartingBalanceA - balanceOf(holder, tokenA);\n    mathint holderSafeTransferFromBalanceChangeB = holderStartingBalanceB - balanceOf(holder, tokenB);\n    mathint holderSafeTransferFromBalanceChangeC = holderStartingBalanceC - balanceOf(holder, tokenC);\n    mathint recipientSafeTransferFromBalanceChangeA = balanceOf(recipient, tokenA) - recipientStartingBalanceA;\n    mathint recipientSafeTransferFromBalanceChangeB = balanceOf(recipient, tokenB) - recipientStartingBalanceB;\n    mathint recipientSafeTransferFromBalanceChangeC = balanceOf(recipient, tokenC) - recipientStartingBalanceC;\n    // transferring via safeBatchTransferFrom\n    safeBatchTransferFrom(e, holder, recipient, tokens, transferAmounts, data) at beforeTransfers;\n    mathint holderSafeBatchTransferFromBalanceChangeA = holderStartingBalanceA - balanceOf(holder, tokenA);\n    mathint holderSafeBatchTransferFromBalanceChangeB = holderStartingBalanceB - balanceOf(holder, tokenB);\n    mathint holderSafeBatchTransferFromBalanceChangeC = holderStartingBalanceC - balanceOf(holder, tokenC);\n    mathint recipientSafeBatchTransferFromBalanceChangeA = balanceOf(recipient, tokenA) - recipientStartingBalanceA;\n    mathint recipientSafeBatchTransferFromBalanceChangeB = balanceOf(recipient, tokenB) - recipientStartingBalanceB;\n    mathint recipientSafeBatchTransferFromBalanceChangeC = balanceOf(recipient, tokenC) - recipientStartingBalanceC;\n    assert holderSafeTransferFromBalanceChangeA == holderSafeBatchTransferFromBalanceChangeA\n        && holderSafeTransferFromBalanceChangeB == holderSafeBatchTransferFromBalanceChangeB\n        && holderSafeTransferFromBalanceChangeC == holderSafeBatchTransferFromBalanceChangeC\n        && recipientSafeTransferFromBalanceChangeA == recipientSafeBatchTransferFromBalanceChangeA\n        && recipientSafeTransferFromBalanceChangeB == recipientSafeBatchTransferFromBalanceChangeB\n        && recipientSafeTransferFromBalanceChangeC == recipientSafeBatchTransferFromBalanceChangeC, \n        \"Transferring multiple tokens via safeTransferFrom or safeBatchTransferFrom must be equivalent\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "multipleTokenSafeTransferFromSafeBatchTransferFromEquivalence",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "safeTransferFrom",
                "safeBatchTransferFrom"
            ],
            "start_line": 810,
            "end_line": 858,
            "block_hash": "35799dd12f2a738eae0102ad9e3ee0ec"
        }
    },
    {
        "id": "ERC1155_transfersHaveSameLengthInputArrays_6400142b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155.sol",
        "target_function": "safeBatchTransferFrom",
        "text_chunk": "    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n",
        "formal_property": "rule transfersHaveSameLengthInputArrays {\n    env e;\n\n    address recipient; bytes data;\n    uint256[] tokens; uint256[] transferAmounts;\n    uint max_int = 0xffffffffffffffffffffffffffffffff;\n    require tokens.length >= 0 && tokens.length <= max_int;\n    require transferAmounts.length >= 0 && transferAmounts.length <= max_int;\n    safeBatchTransferFrom(e, _, recipient, tokens, transferAmounts, data);\n    uint256 tokensLength = tokens.length;\n    uint256 transferAmountsLength = transferAmounts.length;\n    assert tokens.length == transferAmounts.length, \n        \"If transfer methods do not revert, the input arrays must be the same length\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transfersHaveSameLengthInputArrays",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "safeBatchTransferFrom"
            ],
            "start_line": 861,
            "end_line": 878,
            "block_hash": "6400142b9faebdf7283c8bdf3d4d0a01"
        }
    },
    {
        "id": "GhoDiscountRateStrategy_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "GhoDiscountRateStrategy.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {WadRayMath} from '@aave/core-v3/contracts/protocol/libraries/math/WadRayMath.sol';\nimport {IGhoDiscountRateStrategy} from './interfaces/IGhoDiscountRateStrategy.sol';\n\n/**\n * @title GhoDiscountRateStrategy contract\n * @author Aave\n * @notice Implements the calculation of the discount rate depending on the current strategy\n */\ncontract GhoDiscountRateStrategy is IGhoDiscountRateStrategy {\n  using WadRayMath for uint256;\n\n  /**\n   * @dev Amount of debt that is entitled to get a discount per unit of discount token\n   * Expressed with the number of decimals of the discounted token\n   */\n  uint256 public constant GHO_DISCOUNTED_PER_DISCOUNT_TOKEN = 100e18;\n\n  /**\n   * @dev Percentage of discount to apply to the part of the debt that is entitled to get a discount\n   * Expressed in bps, a value of 2000 results in 20.00%\n   */\n  uint256 public constant DISCOUNT_RATE = 0.3e4;\n\n  /**\n   * @dev Minimum balance amount of discount token to be entitled to a discount\n   * Expressed with the number of decimals of the discount token\n   */\n  uint256 public constant MIN_DISCOUNT_TOKEN_BALANCE = 1e15;\n\n  /**\n   * @dev Minimum balance amount of debt token to be entitled to a discount\n   * Expressed with the number of decimals of the debt token\n   */\n  uint256 public constant MIN_DEBT_TOKEN_BALANCE = 1e18;\n\n  /// @inheritdoc IGhoDiscountRateStrategy\n  function calculateDiscountRate(\n    uint256 debtBalance,\n    uint256 discountTokenBalance\n  ) external pure override returns (uint256) {\n    if (discountTokenBalance < MIN_DISCOUNT_TOKEN_BALANCE || debtBalance < MIN_DEBT_TOKEN_BALANCE) {\n      return 0;\n    } else {\n      uint256 discountedBalance = discountTokenBalance.wadMul(GHO_DISCOUNTED_PER_DISCOUNT_TOKEN);\n      if (discountedBalance >= debtBalance) {\n        return DISCOUNT_RATE;\n      } else {\n        return (discountedBalance * DISCOUNT_RATE) / debtBalance;\n      }\n    }\n  }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "calculateDiscountRate"
            ],
            "state_variables": [],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "GhoDiscountRateStrategy_limitOnDiscountRate_5c5ed460",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoDiscountRateStrategy.sol",
        "target_function": "calculateDiscountRate",
        "text_chunk": "  function calculateDiscountRate(\n    uint256 debtBalance,\n    uint256 discountTokenBalance\n  ) external pure override returns (uint256) {\n    if (discountTokenBalance < MIN_DISCOUNT_TOKEN_BALANCE || debtBalance < MIN_DEBT_TOKEN_BALANCE) {\n      return 0;\n    } else {\n      uint256 discountedBalance = discountTokenBalance.wadMul(GHO_DISCOUNTED_PER_DISCOUNT_TOKEN);\n      if (discountedBalance >= debtBalance) {\n        return DISCOUNT_RATE;\n      } else {\n        return (discountedBalance * DISCOUNT_RATE) / debtBalance;\n      }\n    }\n  }\n",
        "formal_property": "rule limitOnDiscountRate() {\n    uint256 debtBalance;\n    uint256 discountTokenBalance;\n    uint256 discountRate = calculateDiscountRate(debtBalance, discountTokenBalance);\n    assert(discountRate <= DISCOUNT_RATE());\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "limitOnDiscountRate",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "calculateDiscountRate",
                "DISCOUNT_RATE"
            ],
            "start_line": 14,
            "end_line": 19,
            "block_hash": "5c5ed46070393d13473073e85245618a"
        }
    },
    {
        "id": "ERC20Votes_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC20Votes.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"./draft-ERC20Permit.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../governance/utils/IVotes.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\nabstract contract ERC20Votes is IVotes, ERC20Permit {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n    bytes32 private constant _DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));\n        }\n    }\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "checkpoints",
                "numCheckpoints",
                "delegates",
                "getVotes",
                "getPastVotes",
                "getPastTotalSupply",
                "_checkpointsLookup",
                "delegate",
                "delegateBySig",
                "_maxSupply",
                "_mint",
                "_burn",
                "_afterTokenTransfer",
                "_delegate",
                "_moveVotingPower",
                "_writeCheckpoint",
                "_add",
                "_subtract"
            ],
            "state_variables": [
                "fromBlock",
                "votes",
                "_checkpoints",
                "_delegates",
                "_totalSupplyCheckpoints"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC20Votes_votes_solvency_ef3a1f03",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Votes.sol",
        "target_function": "_burn/checkpoints/numCheckpoints",
        "text_chunk": "    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n",
        "formal_property": "invariant votes_solvency()\n    totalSupply() >= to_uint256(totalVotes())\n// converted from an invariant to a rule to slightly change the logic\n// if the fromBlock is the same as before, then the number of checkpoints stays the same\n// however if the fromBlock is new than the number of checkpoints increases\n// passes, fails rule sanity because tautology check seems to be bugged\n// passes + rule sanity\ninvariant fromBlock_greaterThanEq_pos(address account, uint32 pos)\n    ckptFromBlock(account, pos) >= pos\n    filtered { f -> !f.isView }\nrule unique_checkpoints_rule(method f) {\n    env e; calldataarg args;\n    address account;\n    uint32 num_ckpts_ = numCheckpoints(account); \n    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);\n\n    f(e, args);\n    uint32 _num_ckpts = numCheckpoints(account);\n    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);\n    \n    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, \"same fromBlock, new checkpoint\";\n}\nfiltered { f -> f.selector != _burn(address, uint256).selector}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "votes_solvency",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "totalSupply",
                "burn"
            ],
            "start_line": 69,
            "end_line": 71,
            "block_hash": "ef3a1f0370fd58aeb4f42cea69b74251"
        }
    },
    {
        "id": "ERC20Votes_blockNum_constrains_fromBlock_f48807b6",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Votes.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"./draft-ERC20Permit.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../governance/utils/IVotes.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\nabstract contract ERC20Votes is IVotes, ERC20Permit {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n    bytes32 private constant _DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));\n        }\n    }\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n}",
        "formal_property": "invariant blockNum_constrains_fromBlock(address account, uint32 index, env e)\n    ckptFromBlock(account, index) < e.block.number\n    filtered { f -> !f.isView }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "blockNum_constrains_fromBlock",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "ckptFromBlock"
            ],
            "start_line": 83,
            "end_line": 85,
            "block_hash": "f48807b64fb6729c7179745baf923c63"
        }
    },
    {
        "id": "ERC20Votes_maxInt_constrains_numBlocks_4ddbdce5",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Votes.sol",
        "target_function": "checkpoints/numCheckpoints",
        "text_chunk": "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n",
        "formal_property": "// invariant maxInt_constrains_numBlocks(address account)\n//     numCheckpoints(account) < 4294967295 // 2^32\n\n// can't have more checkpoints for a given account than the last from block\n// passes\ninvariant fromBlock_constrains_numBlocks(address account)\n    numCheckpoints(account) <= ckptFromBlock(account, numCheckpoints(account) - 1)\n    filtered { f -> !f.isView }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "maxInt_constrains_numBlocks",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "checkpoints",
                "numCheckpoints",
                "ckptFromBlock"
            ],
            "start_line": 93,
            "end_line": 100,
            "block_hash": "4ddbdce5eaab40cf36605607cf8c7366"
        }
    },
    {
        "id": "ERC20Votes_above_a0637167",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Votes.sol",
        "target_function": "checkpoints/numCheckpoints",
        "text_chunk": "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n",
        "formal_property": "    require e.block.number >= ckptFromBlock(account, numCheckpoints(account) - 1); // this should be true from the invariant above!!\n}}\n\n// for any given checkpoint, the fromBlock must be greater than the checkpoint\n// this proves the above invariant in combination with the below invariant\n// if checkpoint has a greater fromBlock than the last, and the FromBlock is always greater than the pos. \n// Then the number of positions must be less than the currentFromBlock\n// ^note that the tool is assuming it's possible for the starting fromBlock to be 0 or anything, and does not know the current starting block\n// converted from an invariant to a rule to slightly change the logic\n// if the fromBlock is the same as before, then the number of checkpoints stays the same\n// however if the fromBlock is new than the number of checkpoints increases\n// passes, fails rule sanity because tautology check seems to be bugged\n// passes + rule sanity\ninvariant fromBlock_greaterThanEq_pos(address account, uint32 pos)\n    ckptFromBlock(account, pos) >= pos\n    filtered { f -> !f.isView }\nrule unique_checkpoints_rule(method f) {\n    env e; calldataarg args;\n    address account;\n    uint32 num_ckpts_ = numCheckpoints(account); \n    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);\n    f(e, args);\n    uint32 _num_ckpts = numCheckpoints(account);\n    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);\n    \n    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, \"same fromBlock, new checkpoint\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "above",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "numCheckpoints",
                "ckptFromBlock"
            ],
            "start_line": 102,
            "end_line": 113,
            "block_hash": "a0637167012d7e07da0c63655445aa99"
        }
    },
    {
        "id": "ERC20Votes_fromBlock_increasing_e1c81c89",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Votes.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"./draft-ERC20Permit.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../governance/utils/IVotes.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\nabstract contract ERC20Votes is IVotes, ERC20Permit {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n    bytes32 private constant _DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));\n        }\n    }\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n}",
        "formal_property": "invariant fromBlock_increasing(address account, uint32 pos, uint32 pos2)\n    pos > pos2 => ckptFromBlock(account, pos) > ckptFromBlock(account, pos2)\n    filtered { f -> !f.isView }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "fromBlock_increasing",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "ckptFromBlock"
            ],
            "start_line": 117,
            "end_line": 119,
            "block_hash": "e1c81c89eeac56149d50f5152c2f72d0"
        }
    },
    {
        "id": "ERC20Votes_to_9694f5a3",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Votes.sol",
        "target_function": "checkpoints/numCheckpoints",
        "text_chunk": "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n",
        "formal_property": "// converted from an invariant to a rule to slightly change the logic\n// if the fromBlock is the same as before, then the number of checkpoints stays the same\n// however if the fromBlock is new than the number of checkpoints increases\n// passes, fails rule sanity because tautology check seems to be bugged\n// passes + rule sanity\ninvariant fromBlock_greaterThanEq_pos(address account, uint32 pos)\n    ckptFromBlock(account, pos) >= pos\n    filtered { f -> !f.isView }\nrule unique_checkpoints_rule(method f) {\n    env e; calldataarg args;\n    address account;\n    uint32 num_ckpts_ = numCheckpoints(account); \n    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);\n\n    f(e, args);\n    uint32 _num_ckpts = numCheckpoints(account);\n    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);\n    \n    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, \"same fromBlock, new checkpoint\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "to",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "checkpoints",
                "numCheckpoints",
                "ckptFromBlock"
            ],
            "start_line": 122,
            "end_line": 139,
            "block_hash": "9694f5a3d1451f00b5933534bdb22770"
        }
    },
    {
        "id": "ERC20Votes_sanity_07a709f4",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Votes.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"./draft-ERC20Permit.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../governance/utils/IVotes.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\nabstract contract ERC20Votes is IVotes, ERC20Permit {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n    bytes32 private constant _DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));\n        }\n    }\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n}",
        "formal_property": "// passes + rule sanity\ninvariant fromBlock_greaterThanEq_pos(address account, uint32 pos)\n    ckptFromBlock(account, pos) >= pos\n    filtered { f -> !f.isView }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sanity",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "ckptFromBlock"
            ],
            "start_line": 110,
            "end_line": 113,
            "block_hash": "07a709f42611546f03ef3911764da22f"
        }
    },
    {
        "id": "ERC20Votes_sanity_4df4d9dc",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Votes.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"./draft-ERC20Permit.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../governance/utils/IVotes.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\nabstract contract ERC20Votes is IVotes, ERC20Permit {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n    bytes32 private constant _DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));\n        }\n    }\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n}",
        "formal_property": "// passes + rule sanity\ninvariant fromBlock_increasing(address account, uint32 pos, uint32 pos2)\n    pos > pos2 => ckptFromBlock(account, pos) > ckptFromBlock(account, pos2)\n    filtered { f -> !f.isView }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sanity",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "ckptFromBlock"
            ],
            "start_line": 116,
            "end_line": 119,
            "block_hash": "4df4d9dce6aeb5c6b5b5719912c9764b"
        }
    },
    {
        "id": "ERC20Votes_to_7daf69b4",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Votes.sol",
        "target_function": "checkpoints/numCheckpoints",
        "text_chunk": "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n",
        "formal_property": "// converted from an invariant to a rule to slightly change the logic\n// if the fromBlock is the same as before, then the number of checkpoints stays the same\n// however if the fromBlock is new than the number of checkpoints increases\n// passes, fails rule sanity because tautology check seems to be bugged\n// passes + rule sanity\ninvariant fromBlock_greaterThanEq_pos(address account, uint32 pos)\n    ckptFromBlock(account, pos) >= pos\n    filtered { f -> !f.isView }\nrule unique_checkpoints_rule(method f) {\n    env e; calldataarg args;\n    address account;\n    uint32 num_ckpts_ = numCheckpoints(account); \n    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);\n\n    f(e, args);\n    uint32 _num_ckpts = numCheckpoints(account);\n    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);\n    \n    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, \"same fromBlock, new checkpoint\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "to",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "checkpoints",
                "numCheckpoints",
                "ckptFromBlock"
            ],
            "start_line": 122,
            "end_line": 139,
            "block_hash": "7daf69b4957eebb75b7c5e63aa896c5b"
        }
    },
    {
        "id": "ERC20Votes_sanity_b65ab4a0",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Votes.sol",
        "target_function": "checkpoints/delegate/delegates/getVotes/numCheckpoints",
        "text_chunk": "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n\n\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n\n\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n",
        "formal_property": "// passes + rule sanity (- a bad tautology check)\n// converted from an invariant to a rule to slightly change the logic\n// if the fromBlock is the same as before, then the number of checkpoints stays the same\n// however if the fromBlock is new than the number of checkpoints increases\n// passes, fails rule sanity because tautology check seems to be bugged\n// passes + rule sanity\ninvariant fromBlock_greaterThanEq_pos(address account, uint32 pos)\n    ckptFromBlock(account, pos) >= pos\n    filtered { f -> !f.isView }\nrule unique_checkpoints_rule(method f) {\n    env e; calldataarg args;\n    address account;\n    uint32 num_ckpts_ = numCheckpoints(account); \n    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);\n\n    f(e, args);\n    uint32 _num_ckpts = numCheckpoints(account);\n    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);\n    \n    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, \"same fromBlock, new checkpoint\";\n}\nrule transfer_safe() {\n    env e;\n    uint256 amount;\n    address a; address b;\n    require delegates(a) != delegates(b); // confirmed if they both delegate to the same person then transfer keeps the votes the same\n    require numCheckpoints(delegates(a)) < 1000000;\n    require numCheckpoints(delegates(b)) < 1000000;\n    uint256 votesA_pre = getVotes(delegates(a));\n    uint256 votesB_pre = getVotes(delegates(b));\n    uint224 totalVotes_pre = totalVotes();\n    transferFrom(e, a, b, amount);\n    uint224 totalVotes_post = totalVotes();\n    uint256 votesA_post = getVotes(delegates(a));\n    uint256 votesB_post = getVotes(delegates(b));\n    // if an account that has not delegated transfers balance to an account that has, it will increase the total supply of votes\n    assert totalVotes_pre == totalVotes_post, \"transfer changed total supply\";\n    assert delegates(a) != 0 => votesA_pre - votesA_post == amount, \"A lost the wrong amount of votes\";\n    assert delegates(b) != 0 => votesB_post - votesB_pre == amount, \"B lost the wrong amount of votes\";\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sanity",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "numCheckpoints",
                "delegates",
                "getVotes",
                "delegate"
            ],
            "start_line": 144,
            "end_line": 164,
            "block_hash": "b65ab4a074ba86f092ccf9e428fd3703"
        }
    },
    {
        "id": "ERC20Votes_delegates_safe_a446a886",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Votes.sol",
        "target_function": "_delegate/checkpoints/delegate/delegateBySig/delegates/numCheckpoints",
        "text_chunk": "    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n\n\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n\n\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n",
        "formal_property": "rule delegates_safe(method f) filtered {f -> (f.selector != delegate(address).selector &&\n// converted from an invariant to a rule to slightly change the logic\n// if the fromBlock is the same as before, then the number of checkpoints stays the same\n// however if the fromBlock is new than the number of checkpoints increases\n// passes, fails rule sanity because tautology check seems to be bugged\n// passes + rule sanity\ninvariant fromBlock_greaterThanEq_pos(address account, uint32 pos)\n    ckptFromBlock(account, pos) >= pos\n    filtered { f -> !f.isView }\nrule unique_checkpoints_rule(method f) {\n    env e; calldataarg args;\n    address account;\n    uint32 num_ckpts_ = numCheckpoints(account); \n    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);\n\n    f(e, args);\n    uint32 _num_ckpts = numCheckpoints(account);\n    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);\n    \n    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, \"same fromBlock, new checkpoint\";\n}\n                                                f.selector != _delegate(address, address).selector &&\n                                                f.selector != delegateBySig(address, uint256, uint256, uint8, bytes32, bytes32).selector) }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "delegates_safe",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "delegates",
                "delegate",
                "_delegate"
            ],
            "start_line": 167,
            "end_line": 169,
            "block_hash": "a446a886018ffc038a92e565136618a5"
        }
    },
    {
        "id": "ERC20Votes_sanity_4f85e57d",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Votes.sol",
        "target_function": "_delegate/checkpoints/delegate/delegates/getVotes/numCheckpoints",
        "text_chunk": "    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n\n\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n\n\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n",
        "formal_property": "// passes + rule sanity\nrule delegatee_receives_votes() {\n    env e; \n    address delegator; address delegatee;\n// converted from an invariant to a rule to slightly change the logic\n// if the fromBlock is the same as before, then the number of checkpoints stays the same\n// however if the fromBlock is new than the number of checkpoints increases\n// passes, fails rule sanity because tautology check seems to be bugged\ninvariant fromBlock_greaterThanEq_pos(address account, uint32 pos)\n    ckptFromBlock(account, pos) >= pos\n    filtered { f -> !f.isView }\nrule unique_checkpoints_rule(method f) {\n    env e; calldataarg args;\n    address account;\n    uint32 num_ckpts_ = numCheckpoints(account); \n    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);\n\n    f(e, args);\n    uint32 _num_ckpts = numCheckpoints(account);\n    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);\n    \n    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, \"same fromBlock, new checkpoint\";\n}\n    require delegates(delegator) != delegatee;\n    require delegatee != 0x0;\n    uint256 delegator_bal = balanceOf(e, delegator);\n    uint256 votes_= getVotes(delegatee);\n    _delegate(e, delegator, delegatee);\n    require lastIndex(delegatee) < 1000000;\n    uint256 _votes = getVotes(delegatee);\n    assert _votes == votes_ + delegator_bal, \"delegatee did not receive votes\";\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sanity",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "delegates",
                "getVotes",
                "delegate",
                "_delegate"
            ],
            "start_line": 179,
            "end_line": 198,
            "block_hash": "4f85e57d76b44e14493e579fbdb91e2e"
        }
    },
    {
        "id": "ERC20Votes_sanity_cc75edf0",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Votes.sol",
        "target_function": "_delegate/checkpoints/delegate/delegates/getVotes/numCheckpoints",
        "text_chunk": "    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n\n\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n\n\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n",
        "formal_property": "// passes + rule sanity\nrule previous_delegatee_votes_removed() {\n    env e;\n    address delegator; address delegatee; address third;\n// converted from an invariant to a rule to slightly change the logic\n// if the fromBlock is the same as before, then the number of checkpoints stays the same\n// however if the fromBlock is new than the number of checkpoints increases\n// passes, fails rule sanity because tautology check seems to be bugged\ninvariant fromBlock_greaterThanEq_pos(address account, uint32 pos)\n    ckptFromBlock(account, pos) >= pos\n    filtered { f -> !f.isView }\nrule unique_checkpoints_rule(method f) {\n    env e; calldataarg args;\n    address account;\n    uint32 num_ckpts_ = numCheckpoints(account); \n    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);\n\n    f(e, args);\n    uint32 _num_ckpts = numCheckpoints(account);\n    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);\n    \n    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, \"same fromBlock, new checkpoint\";\n}\n    require third != delegatee;\n    require delegates(delegator) == third;\n    require numCheckpoints(third) < 1000000;\n    uint256 delegator_bal = balanceOf(e, delegator);\n    uint256 votes_ = getVotes(third);\n    _delegate(e, delegator, delegatee);\n    uint256 _votes = getVotes(third);\n    assert third != 0x0 => _votes == votes_ - delegator_bal, \"votes not removed from the previous delegatee\";\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sanity",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "numCheckpoints",
                "delegates",
                "getVotes",
                "delegate",
                "_delegate"
            ],
            "start_line": 200,
            "end_line": 217,
            "block_hash": "cc75edf0462175905d3321a248ba9d87"
        }
    },
    {
        "id": "ERC20Votes_sanity_9cf85abb",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Votes.sol",
        "target_function": "_delegate/checkpoints/delegate/delegates/getVotes/numCheckpoints",
        "text_chunk": "    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n\n\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n\n\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n",
        "formal_property": "// passes with rule sanity\nrule delegate_contained() {\n    env e;\n    address delegator; address delegatee; address other;\n// converted from an invariant to a rule to slightly change the logic\n// if the fromBlock is the same as before, then the number of checkpoints stays the same\n// however if the fromBlock is new than the number of checkpoints increases\n// passes, fails rule sanity because tautology check seems to be bugged\n// passes + rule sanity\ninvariant fromBlock_greaterThanEq_pos(address account, uint32 pos)\n    ckptFromBlock(account, pos) >= pos\n    filtered { f -> !f.isView }\nrule unique_checkpoints_rule(method f) {\n    env e; calldataarg args;\n    address account;\n    uint32 num_ckpts_ = numCheckpoints(account); \n    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);\n\n    f(e, args);\n    uint32 _num_ckpts = numCheckpoints(account);\n    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);\n    \n    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, \"same fromBlock, new checkpoint\";\n}\n    require other != delegatee;\n    require other != delegates(delegator); \n    uint256 votes_ = getVotes(other);\n    _delegate(e, delegator, delegatee);\n    uint256 _votes = getVotes(other);\n    assert votes_ == _votes, \"votes not contained\";\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sanity",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "delegates",
                "getVotes",
                "delegate",
                "_delegate"
            ],
            "start_line": 219,
            "end_line": 234,
            "block_hash": "9cf85abb92e732f8d1c5557fe43f0f64"
        }
    },
    {
        "id": "ERC20Votes_delegate_no_frontrunning_714a04b0",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Votes.sol",
        "target_function": "_delegate/checkpoints/delegate/delegates/getVotes/numCheckpoints",
        "text_chunk": "    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n\n\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n\n\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n",
        "formal_property": "rule delegate_no_frontrunning(method f) {\n    env e; calldataarg args;\n    address delegator; address delegatee; address third; address other;\n// converted from an invariant to a rule to slightly change the logic\n// if the fromBlock is the same as before, then the number of checkpoints stays the same\n// however if the fromBlock is new than the number of checkpoints increases\n// passes, fails rule sanity because tautology check seems to be bugged\n// passes + rule sanity\ninvariant fromBlock_greaterThanEq_pos(address account, uint32 pos)\n    ckptFromBlock(account, pos) >= pos\n    filtered { f -> !f.isView }\nrule unique_checkpoints_rule(method f) {\n    address account;\n    uint32 num_ckpts_ = numCheckpoints(account); \n    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);\n\n    f(e, args);\n    uint32 _num_ckpts = numCheckpoints(account);\n    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);\n    \n    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, \"same fromBlock, new checkpoint\";\n}\n    require numCheckpoints(delegatee) < 1000000;\n    require numCheckpoints(third) < 1000000;\n    uint256 delegator_bal = balanceOf(e, delegator);\n    uint256 delegatee_votes_ = getVotes(delegatee);\n    uint256 third_votes_ = getVotes(third);\n    uint256 other_votes_ = getVotes(other);\n    require delegates(delegator) == third;\n    require third != delegatee;\n    require other != third;\n    require other != delegatee;\n    require delegatee != 0x0;\n    _delegate(e, delegator, delegatee);\n    uint256 _delegatee_votes = getVotes(delegatee);\n    uint256 _third_votes = getVotes(third);\n    uint256 _other_votes = getVotes(other);\n    // previous delegatee loses all of their votes\n    // delegatee gains that many votes\n    // third loses any votes delegated to them\n    assert _delegatee_votes == delegatee_votes_ + delegator_bal, \"delegatee did not receive votes\";\n    assert third != 0 => _third_votes == third_votes_ - delegator_bal, \"votes not removed from third\";\n    assert other_votes_ == _other_votes, \"delegate not contained\";\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "delegate_no_frontrunning",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "numCheckpoints",
                "delegates",
                "getVotes",
                "delegate",
                "_delegate"
            ],
            "start_line": 236,
            "end_line": 271,
            "block_hash": "714a04b013e49f46c826ae9937ecf80e"
        }
    },
    {
        "id": "ERC20Votes_mint_increases_totalSupply_d1ed8dfc",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Votes.sol",
        "target_function": "_maxSupply/checkpoints/getPastTotalSupply/numCheckpoints",
        "text_chunk": "    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n",
        "formal_property": "rule mint_increases_totalSupply() {\n// converted from an invariant to a rule to slightly change the logic\n// if the fromBlock is the same as before, then the number of checkpoints stays the same\n// however if the fromBlock is new than the number of checkpoints increases\n// passes, fails rule sanity because tautology check seems to be bugged\n// passes + rule sanity\ninvariant fromBlock_greaterThanEq_pos(address account, uint32 pos)\n    ckptFromBlock(account, pos) >= pos\n    filtered { f -> !f.isView }\nrule unique_checkpoints_rule(method f) {\n    env e; calldataarg args;\n    address account;\n    uint32 num_ckpts_ = numCheckpoints(account); \n    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);\n\n    f(e, args);\n    uint32 _num_ckpts = numCheckpoints(account);\n    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);\n    \n    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, \"same fromBlock, new checkpoint\";\n}\n    env e;\n    uint256 amount; address account;\n    uint256 fromBlock = e.block.number;\n    uint256 totalSupply_ = totalSupply();\n    mint(e, account, amount);\n    uint256 _totalSupply = totalSupply();\n    require _totalSupply < _maxSupply();\n    assert _totalSupply == totalSupply_ + amount, \"totalSupply not increased properly\";\n    assert getPastTotalSupply(e, fromBlock) == totalSupply_ , \"previous total supply not saved properly\";\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "mint_increases_totalSupply",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "getPastTotalSupply",
                "totalSupply",
                "_maxSupply",
                "mint"
            ],
            "start_line": 276,
            "end_line": 291,
            "block_hash": "d1ed8dfc8f675bb31bde1c1caae60355"
        }
    },
    {
        "id": "ERC20Votes_burn_decreases_totalSupply_cc3aef9d",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Votes.sol",
        "target_function": "checkpoints/getPastTotalSupply/numCheckpoints",
        "text_chunk": "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n",
        "formal_property": "rule burn_decreases_totalSupply() {\n// converted from an invariant to a rule to slightly change the logic\n// if the fromBlock is the same as before, then the number of checkpoints stays the same\n// however if the fromBlock is new than the number of checkpoints increases\n// passes, fails rule sanity because tautology check seems to be bugged\n// passes + rule sanity\ninvariant fromBlock_greaterThanEq_pos(address account, uint32 pos)\n    ckptFromBlock(account, pos) >= pos\n    filtered { f -> !f.isView }\nrule unique_checkpoints_rule(method f) {\n    env e; calldataarg args;\n    address account;\n    uint32 num_ckpts_ = numCheckpoints(account); \n    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);\n\n    f(e, args);\n    uint32 _num_ckpts = numCheckpoints(account);\n    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);\n    \n    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, \"same fromBlock, new checkpoint\";\n}\n    env e;\n    uint256 amount; address account;\n    uint256 fromBlock = e.block.number;\n    uint256 totalSupply_ = totalSupply();\n    burn(e, account, amount);\n    uint256 _totalSupply = totalSupply();\n    assert _totalSupply == totalSupply_ - amount, \"totalSupply not decreased properly\";\n    assert getPastTotalSupply(e, fromBlock) == totalSupply_ , \"previous total supply not saved properly\";\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burn_decreases_totalSupply",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "getPastTotalSupply",
                "totalSupply",
                "burn"
            ],
            "start_line": 294,
            "end_line": 307,
            "block_hash": "cc3aef9da479384ca565afce1b906625"
        }
    },
    {
        "id": "ERC20Votes_mint_doesnt_increase_totalVotes_5d5419ab",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Votes.sol",
        "target_function": "checkpoints/numCheckpoints",
        "text_chunk": "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n",
        "formal_property": "rule mint_doesnt_increase_totalVotes() {\n// converted from an invariant to a rule to slightly change the logic\n// if the fromBlock is the same as before, then the number of checkpoints stays the same\n// however if the fromBlock is new than the number of checkpoints increases\n// passes, fails rule sanity because tautology check seems to be bugged\n// passes + rule sanity\ninvariant fromBlock_greaterThanEq_pos(address account, uint32 pos)\n    ckptFromBlock(account, pos) >= pos\n    filtered { f -> !f.isView }\nrule unique_checkpoints_rule(method f) {\n    env e; calldataarg args;\n    address account;\n    uint32 num_ckpts_ = numCheckpoints(account); \n    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);\n\n    f(e, args);\n    uint32 _num_ckpts = numCheckpoints(account);\n    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);\n    \n    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, \"same fromBlock, new checkpoint\";\n}\n    env e;\n    uint256 amount; address account;\n    uint224 totalVotes_ = totalVotes();\n    mint(e, account, amount);\n    assert totalVotes() == totalVotes_, \"totalVotes increased\";\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "mint_doesnt_increase_totalVotes",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint"
            ],
            "start_line": 312,
            "end_line": 321,
            "block_hash": "5d5419ab0889ba92c951ce36255cfcf5"
        }
    },
    {
        "id": "ERC20Votes_burn_doesnt_decrease_totalVotes_79ddf2d6",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Votes.sol",
        "target_function": "checkpoints/numCheckpoints",
        "text_chunk": "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n",
        "formal_property": "rule burn_doesnt_decrease_totalVotes() {\n// converted from an invariant to a rule to slightly change the logic\n// if the fromBlock is the same as before, then the number of checkpoints stays the same\n// however if the fromBlock is new than the number of checkpoints increases\n// passes, fails rule sanity because tautology check seems to be bugged\n// passes + rule sanity\ninvariant fromBlock_greaterThanEq_pos(address account, uint32 pos)\n    ckptFromBlock(account, pos) >= pos\n    filtered { f -> !f.isView }\nrule unique_checkpoints_rule(method f) {\n    env e; calldataarg args;\n    address account;\n    uint32 num_ckpts_ = numCheckpoints(account); \n    uint32 fromBlock_ = num_ckpts_ == 0 ? 0 : ckptFromBlock(account, num_ckpts_ - 1);\n\n    f(e, args);\n    uint32 _num_ckpts = numCheckpoints(account);\n    uint32 _fromBlock = _num_ckpts == 0 ? 0 : ckptFromBlock(account, _num_ckpts - 1);\n    \n    assert fromBlock_ == _fromBlock => num_ckpts_ == _num_ckpts || _num_ckpts == 1, \"same fromBlock, new checkpoint\";\n}\n    env e;\n    uint256 amount; address account;\n    uint224 totalVotes_ = totalVotes();\n    burn(e, account, amount);\n    assert totalVotes() == totalVotes_, \"totalVotes decreased\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burn_doesnt_decrease_totalVotes",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "burn"
            ],
            "start_line": 323,
            "end_line": 332,
            "block_hash": "79ddf2d6576f1a47cd8e510f26560001"
        }
    },
    {
        "id": "ERC20Wrapper_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC20Wrapper.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/ERC20Wrapper.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../utils/SafeERC20.sol\";\n\nabstract contract ERC20Wrapper is ERC20 {\n    IERC20 public immutable underlying;\n\n    constructor(IERC20 underlyingToken) {\n        underlying = underlyingToken;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        try IERC20Metadata(address(underlying)).decimals() returns (uint8 value) {\n            return value;\n        } catch {\n            return super.decimals();\n        }\n    }\n    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);\n        _mint(account, amount);\n        return true;\n    }\n    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\n        _burn(_msgSender(), amount);\n        SafeERC20.safeTransfer(underlying, account, amount);\n        return true;\n    }\n    function _recover(address account) internal virtual returns (uint256) {\n        uint256 value = underlying.balanceOf(address(this)) - totalSupply();\n        _mint(account, value);\n        return value;\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "decimals",
                "depositFor",
                "withdrawTo",
                "_recover"
            ],
            "state_variables": [],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC20Wrapper_whatAboutTotal_57706f22",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Wrapper.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/ERC20Wrapper.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../utils/SafeERC20.sol\";\n\nabstract contract ERC20Wrapper is ERC20 {\n    IERC20 public immutable underlying;\n\n    constructor(IERC20 underlyingToken) {\n        underlying = underlyingToken;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        try IERC20Metadata(address(underlying)).decimals() returns (uint8 value) {\n            return value;\n        } catch {\n            return super.decimals();\n        }\n    }\n    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);\n        _mint(account, amount);\n        return true;\n    }\n    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\n        _burn(_msgSender(), amount);\n        SafeERC20.safeTransfer(underlying, account, amount);\n        return true;\n    }\n    function _recover(address account) internal virtual returns (uint256) {\n        uint256 value = underlying.balanceOf(address(this)) - totalSupply();\n        _mint(account, value);\n        return value;\n    }\n}\n",
        "formal_property": "invariant whatAboutTotal(env e)\n    totalSupply(e) <= underlyingTotalSupply()\n    filtered { f -> f.selector != certorafallback_0().selector && !f.isView}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "whatAboutTotal",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "underlying",
                "underlyingTotalSupply"
            ],
            "start_line": 16,
            "end_line": 18,
            "block_hash": "57706f22a95db593b0eb33c61736218d"
        }
    },
    {
        "id": "ERC20Wrapper_underTotalAndContractBalanceOfCorrelation_2cae76f0",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Wrapper.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/ERC20Wrapper.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../utils/SafeERC20.sol\";\n\nabstract contract ERC20Wrapper is ERC20 {\n    IERC20 public immutable underlying;\n\n    constructor(IERC20 underlyingToken) {\n        underlying = underlyingToken;\n    }\n    function decimals() public view virtual override returns (uint8) {\n        try IERC20Metadata(address(underlying)).decimals() returns (uint8 value) {\n            return value;\n        } catch {\n            return super.decimals();\n        }\n    }\n    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);\n        _mint(account, amount);\n        return true;\n    }\n    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\n        _burn(_msgSender(), amount);\n        SafeERC20.safeTransfer(underlying, account, amount);\n        return true;\n    }\n    function _recover(address account) internal virtual returns (uint256) {\n        uint256 value = underlying.balanceOf(address(this)) - totalSupply();\n        _mint(account, value);\n        return value;\n    }\n}\n",
        "formal_property": "invariant underTotalAndContractBalanceOfCorrelation(env e)\n    totalSupply(e) <= underlyingBalanceOf(currentContract)\n    {\n        preserved with (env e2) {\n            require underlying() != currentContract;\n            require e.msg.sender != currentContract;\n            require e.msg.sender == e2.msg.sender;\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "underTotalAndContractBalanceOfCorrelation",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "underlying",
                "underlyingBalanceOf"
            ],
            "start_line": 31,
            "end_line": 39,
            "block_hash": "2cae76f013d05a4744eee02597cafa2d"
        }
    },
    {
        "id": "ERC20Wrapper_depositForSpecBasic_a2aa00fb",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Wrapper.sol",
        "target_function": "depositFor",
        "text_chunk": "    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);\n        _mint(account, amount);\n        return true;\n    }\n",
        "formal_property": "rule depositForSpecBasic(env e){\n    address account; uint256 amount;\n\n    require e.msg.sender != currentContract;\n    require underlying() != currentContract;\n    uint256 wrapperTotalBefore = totalSupply(e);\n    uint256 underlyingTotalBefore = underlyingTotalSupply();\n    uint256 underlyingThisBalanceBefore = underlyingBalanceOf(currentContract);\n    depositFor(e, account, amount);\n    uint256 wrapperTotalAfter = totalSupply(e);\n    uint256 underlyingTotalAfter = underlyingTotalSupply();\n    uint256 underlyingThisBalanceAfter = underlyingBalanceOf(currentContract);\n    assert wrapperTotalBefore == wrapperTotalAfter - amount, \"wrapper total wrong update\";\n    assert underlyingTotalBefore == underlyingTotalAfter, \"underlying total was updated\";\n    assert underlyingThisBalanceBefore == underlyingThisBalanceAfter - amount, \"underlying this balance wrong update\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "depositForSpecBasic",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "underlying",
                "underlyingTotalSupply",
                "underlyingBalanceOf",
                "depositFor"
            ],
            "start_line": 44,
            "end_line": 63,
            "block_hash": "a2aa00fb0d8b8f795ea512ea88a0953c"
        }
    },
    {
        "id": "ERC20Wrapper_depositForSpecWrapper_56e9deb2",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Wrapper.sol",
        "target_function": "depositFor",
        "text_chunk": "    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);\n        _mint(account, amount);\n        return true;\n    }\n",
        "formal_property": "rule depositForSpecWrapper(env e){\n    address account; uint256 amount;\n\n    require underlying() != currentContract;\n    uint256 wrapperUserBalanceBefore = balanceOf(e, account);\n    uint256 wrapperSenderBalanceBefore = balanceOf(e, e.msg.sender);\n    depositFor(e, account, amount);\n    uint256 wrapperUserBalanceAfter = balanceOf(e, account);\n    uint256 wrapperSenderBalanceAfter = balanceOf(e, e.msg.sender);\n    assert account == e.msg.sender => wrapperUserBalanceBefore == wrapperSenderBalanceBefore \n                && wrapperUserBalanceAfter == wrapperSenderBalanceAfter \n                && wrapperUserBalanceBefore == wrapperUserBalanceAfter - amount, \"wrapper balances wrong update\";\n    assert account != e.msg.sender => wrapperUserBalanceBefore == wrapperUserBalanceAfter - amount\n                && wrapperSenderBalanceBefore == wrapperSenderBalanceAfter, \"wrapper balances wrong update\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "depositForSpecWrapper",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "underlying",
                "depositFor"
            ],
            "start_line": 68,
            "end_line": 86,
            "block_hash": "56e9deb2e263978fa0778175a0d244cd"
        }
    },
    {
        "id": "ERC20Wrapper_depositForSpecUnderlying_6b157381",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Wrapper.sol",
        "target_function": "depositFor",
        "text_chunk": "    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);\n        _mint(account, amount);\n        return true;\n    }\n",
        "formal_property": "rule depositForSpecUnderlying(env e){\n    address account; uint256 amount;\n\n    require e.msg.sender != currentContract;\n    require underlying() != currentContract;\n    uint256 underlyingSenderBalanceBefore = underlyingBalanceOf(e.msg.sender);\n    uint256 underlyingUserBalanceBefore = underlyingBalanceOf(account);\n    depositFor(e, account, amount);\n    uint256 underlyingSenderBalanceAfter = underlyingBalanceOf(e.msg.sender);\n    uint256 underlyingUserBalanceAfter = underlyingBalanceOf(account);\n    assert account == e.msg.sender => underlyingSenderBalanceBefore == underlyingUserBalanceBefore\n                && underlyingSenderBalanceAfter == underlyingUserBalanceAfter\n                && underlyingSenderBalanceBefore == underlyingSenderBalanceAfter + amount, \"underlying balances wrong update\";\n    \n    assert account != e.msg.sender && account == currentContract => underlyingSenderBalanceBefore == underlyingSenderBalanceAfter + amount\n                && underlyingUserBalanceBefore == underlyingUserBalanceAfter - amount, \"underlying balances wrong update\";\n    assert account != e.msg.sender && account != currentContract => underlyingSenderBalanceBefore == underlyingSenderBalanceAfter + amount\n                && underlyingUserBalanceBefore == underlyingUserBalanceAfter, \"underlying balances wrong update\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "depositForSpecUnderlying",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "underlying",
                "underlyingBalanceOf",
                "depositFor"
            ],
            "start_line": 91,
            "end_line": 114,
            "block_hash": "6b157381d2c89931ab22dfb13cfdcd3a"
        }
    },
    {
        "id": "ERC20Wrapper_withdrawToSpecBasic_204292cb",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Wrapper.sol",
        "target_function": "withdrawTo",
        "text_chunk": "    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\n        _burn(_msgSender(), amount);\n        SafeERC20.safeTransfer(underlying, account, amount);\n        return true;\n    }\n",
        "formal_property": "rule withdrawToSpecBasic(env e){\n    address account; uint256 amount;\n\n    require underlying() != currentContract;\n    uint256 wrapperTotalBefore = totalSupply(e);\n    uint256 underlyingTotalBefore = underlyingTotalSupply();\n    withdrawTo(e, account, amount);\n    uint256 wrapperTotalAfter = totalSupply(e);\n    uint256 underlyingTotalAfter = underlyingTotalSupply();\n    assert wrapperTotalBefore == wrapperTotalAfter + amount, \"wrapper total wrong update\";\n    assert underlyingTotalBefore == underlyingTotalAfter, \"underlying total was updated\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "withdrawToSpecBasic",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "underlying",
                "underlyingTotalSupply",
                "withdrawTo"
            ],
            "start_line": 119,
            "end_line": 134,
            "block_hash": "204292cb826c285c607506a2d1a793a8"
        }
    },
    {
        "id": "ERC20Wrapper_withdrawToSpecWrapper_ccdadb6b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Wrapper.sol",
        "target_function": "withdrawTo",
        "text_chunk": "    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\n        _burn(_msgSender(), amount);\n        SafeERC20.safeTransfer(underlying, account, amount);\n        return true;\n    }\n",
        "formal_property": "rule withdrawToSpecWrapper(env e){\n    address account; uint256 amount;\n\n    require underlying() != currentContract;\n    uint256 wrapperUserBalanceBefore = balanceOf(e, account);\n    uint256 wrapperSenderBalanceBefore = balanceOf(e, e.msg.sender);\n    withdrawTo(e, account, amount);\n    uint256 wrapperUserBalanceAfter = balanceOf(e, account);\n    uint256 wrapperSenderBalanceAfter = balanceOf(e, e.msg.sender);\n    \n    assert account == e.msg.sender => wrapperUserBalanceBefore == wrapperSenderBalanceBefore\n                && wrapperUserBalanceAfter == wrapperSenderBalanceAfter\n                && wrapperUserBalanceBefore == wrapperUserBalanceAfter + amount, \"wrapper user balance wrong update\";\n    assert account != e.msg.sender => wrapperSenderBalanceBefore == wrapperSenderBalanceAfter + amount\n                && wrapperUserBalanceBefore == wrapperUserBalanceAfter, \"wrapper user balance wrong update\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "withdrawToSpecWrapper",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "underlying",
                "withdrawTo"
            ],
            "start_line": 139,
            "end_line": 157,
            "block_hash": "ccdadb6b067b6ac0e0dc6fd51eefdc6f"
        }
    },
    {
        "id": "ERC20Wrapper_withdrawToSpecUnderlying_1bbf6d94",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Wrapper.sol",
        "target_function": "withdrawTo",
        "text_chunk": "    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\n        _burn(_msgSender(), amount);\n        SafeERC20.safeTransfer(underlying, account, amount);\n        return true;\n    }\n",
        "formal_property": "rule withdrawToSpecUnderlying(env e){\n    address account; uint256 amount;\n\n    require e.msg.sender != currentContract;\n    require underlying() != currentContract;\n    uint256 underlyingSenderBalanceBefore = underlyingBalanceOf(e.msg.sender);\n    uint256 underlyingUserBalanceBefore = underlyingBalanceOf(account);\n    uint256 underlyingThisBalanceBefore = underlyingBalanceOf(currentContract);\n    withdrawTo(e, account, amount);\n    uint256 underlyingSenderBalanceAfter = underlyingBalanceOf(e.msg.sender);\n    uint256 underlyingUserBalanceAfter = underlyingBalanceOf(account);\n    uint256 underlyingThisBalanceAfter = underlyingBalanceOf(currentContract);\n    assert account == e.msg.sender => underlyingSenderBalanceBefore == underlyingUserBalanceBefore \n                && underlyingSenderBalanceAfter == underlyingUserBalanceAfter \n                && underlyingUserBalanceBefore == underlyingUserBalanceAfter - amount, \"underlying balances wrong update (acc == sender)\";\n    \n    assert account != e.msg.sender && account == currentContract => underlyingUserBalanceBefore == underlyingUserBalanceAfter\n                && underlyingSenderBalanceBefore == underlyingSenderBalanceAfter, \"underlying balances wrong update (acc == contract)\"; \n    assert account != e.msg.sender && account != currentContract => underlyingUserBalanceBefore == underlyingUserBalanceAfter - amount\n                && underlyingSenderBalanceBefore == underlyingSenderBalanceAfter\n                && underlyingThisBalanceBefore == underlyingThisBalanceAfter + amount, \"underlying balances wrong update (acc != contract)\";   \n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "withdrawToSpecUnderlying",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "underlying",
                "underlyingBalanceOf",
                "withdrawTo"
            ],
            "start_line": 162,
            "end_line": 187,
            "block_hash": "1bbf6d94c48f3b7b43820a853a21ff6e"
        }
    },
    {
        "id": "ERC20Wrapper_recoverSpec_c0744a91",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20Wrapper.sol",
        "target_function": "_recover",
        "text_chunk": "    function _recover(address account) internal virtual returns (uint256) {\n        uint256 value = underlying.balanceOf(address(this)) - totalSupply();\n        _mint(account, value);\n        return value;\n    }\n",
        "formal_property": "rule recoverSpec(env e){\n    address account; uint256 amount;\n\n    uint256 wrapperTotalBefore = totalSupply(e);\n    uint256 wrapperUserBalanceBefore = balanceOf(e, account);\n    uint256 wrapperSenderBalanceBefore = balanceOf(e, e.msg.sender);\n    uint256 underlyingThisBalanceBefore = underlyingBalanceOf(currentContract);\n    mathint value = underlyingThisBalanceBefore - wrapperTotalBefore;\n    _recover(e, account);\n    uint256 wrapperTotalAfter = totalSupply(e);\n    uint256 wrapperUserBalanceAfter = balanceOf(e, account);\n    uint256 wrapperSenderBalanceAfter = balanceOf(e, e.msg.sender);\n    \n    assert wrapperTotalBefore == wrapperTotalAfter - value, \"wrapper total wrong update\";\n    assert e.msg.sender == account => wrapperUserBalanceBefore == wrapperSenderBalanceBefore\n                && wrapperUserBalanceAfter == wrapperSenderBalanceAfter\n                && wrapperUserBalanceBefore == wrapperUserBalanceAfter - value, \"wrapper balances wrong update\";\n    assert e.msg.sender != account => wrapperUserBalanceBefore == wrapperUserBalanceAfter - value\n                && wrapperSenderBalanceBefore == wrapperSenderBalanceAfter, \"wrapper balances wrong update\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "recoverSpec",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "underlying",
                "underlyingBalanceOf",
                "_recover"
            ],
            "start_line": 192,
            "end_line": 214,
            "block_hash": "c0744a913905fa7d306ce8454468f071"
        }
    },
    {
        "id": "Vat_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "Vat.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.13;\n\ncontract Vat {\n    mapping (address => uint256) public wards;\n    mapping(address => mapping (address => uint256)) public can;\n    struct Ilk {\n        uint256 Art; \n        uint256 rate;\n        uint256 spot;\n        uint256 line;\n        uint256 dust;\n    }\n    struct Urn {\n        uint256 ink;\n        uint256 art;\n    }\n    mapping (bytes32 => Ilk) public ilks;\n    mapping (bytes32 => mapping (address => Urn )) public urns;\n    mapping (bytes32 => mapping (address => uint)) public gem;\n    mapping (address => uint256) public dai;\n    mapping (address => uint256) public sin;\n    uint256 public debt;\n    uint256 public vice;\n    uint256 public Line;\n    uint256 public live;\n\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n    event Init(bytes32 indexed ilk);\n    event File(bytes32 indexed what, uint256 data);\n    event File(bytes32 indexed ilk, bytes32 indexed what, uint256 data);\n    event Cage();\n    event Hope(address indexed from, address indexed to);\n    event Nope(address indexed from, address indexed to);\n    event Slip(bytes32 indexed ilk, address indexed usr, int256 wad);\n    event Flux(bytes32 indexed ilk, address indexed src, address indexed dst, uint256 wad);\n    event Move(address indexed src, address indexed dst, uint256 rad);\n    event Frob(bytes32 indexed i, address indexed u, address v, address w, int256 dink, int256 dart);\n    event Fork(bytes32 indexed ilk, address indexed src, address indexed dst, int256 dink, int256 dart);\n    event Grab(bytes32 indexed i, address indexed u, address v, address w, int256 dink, int256 dart);\n    event Heal(address indexed u, uint256 rad);\n    event Suck(address indexed u, address indexed v, uint256 rad);\n    event Fold(bytes32 indexed i, address indexed u, int256 rate);\n\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Vat/not-authorized\");\n        _;\n    }\n\n    function wish(address bit, address usr) internal view returns (bool) {\n        return either(bit == usr, can[bit][usr] == 1);\n    }\n\n    constructor() {\n        wards[msg.sender] = 1;\n        live = 1;\n        emit Rely(msg.sender);\n    }\n\n    function _add(uint256 x, int256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + uint256(y);\n        }\n        require(y >= 0 || z <= x);\n        require(y <= 0 || z >= x);\n    }\n\n    function _sub(uint256 x, int256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - uint256(y);\n        }\n        require(y <= 0 || z <= x);\n        require(y >= 0 || z >= x);\n    }\n\n    function _int256(uint256 x) internal pure returns (int256 y) {\n        require((y = int256(x)) >= 0);\n    }\n\n    function rely(address usr) external auth {\n        require(live == 1, \"Vat/not-live\");\n        wards[usr] = 1;\n        emit Rely(usr);\n    }\n\n    function deny(address usr) external auth {\n        require(live == 1, \"Vat/not-live\");\n        wards[usr] = 0;\n        emit Deny(usr);\n    }\n\n    function init(bytes32 ilk) external auth {\n        require(ilks[ilk].rate == 0, \"Vat/ilk-already-init\");\n        ilks[ilk].rate = 10 ** 27;\n        emit Init(ilk);\n    }\n\n    function file(bytes32 what, uint256 data) external auth {\n        require(live == 1, \"Vat/not-live\");\n        if (what == \"Line\") Line = data;\n        else revert(\"Vat/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    function file(bytes32 ilk, bytes32 what, uint256 data) external auth {\n        require(live == 1, \"Vat/not-live\");\n        if (what == \"spot\") ilks[ilk].spot = data;\n        else if (what == \"line\") ilks[ilk].line = data;\n        else if (what == \"dust\") ilks[ilk].dust = data;\n        else revert(\"Vat/file-unrecognized-param\");\n        emit File(ilk, what, data);\n    }\n\n    function cage() external auth {\n        live = 0;\n        emit Cage();\n    }\n\n    function Art(bytes32 ilk) external view returns (uint256 Art_) {\n        Art_ = ilks[ilk].Art;\n    }\n\n    function rate(bytes32 ilk) external view returns (uint256 rate_) {\n        rate_ = ilks[ilk].rate;\n    }\n\n    function spot(bytes32 ilk) external view returns (uint256 spot_) {\n        spot_ = ilks[ilk].spot;\n    }\n\n    function line(bytes32 ilk) external view returns (uint256 line_) {\n        line_ = ilks[ilk].line;\n    }\n\n    function dust(bytes32 ilk) external view returns (uint256 dust_) {\n        dust_ = ilks[ilk].dust;\n    }\n\n    function ink(bytes32 ilk, address urn) external view returns (uint256 ink_) {\n        ink_ = urns[ilk][urn].ink;\n    }\n\n    function art(bytes32 ilk, address urn) external view returns (uint256 art_) {\n        art_ = urns[ilk][urn].art;\n    }\n\n    function hope(address usr) external {\n        can[msg.sender][usr] = 1;\n        emit Hope(msg.sender, usr);\n    }\n\n    function nope(address usr) external {\n        can[msg.sender][usr] = 0;\n        emit Nope(msg.sender, usr);\n    }\n\n    function slip(bytes32 ilk, address usr, int256 wad) external auth {\n        gem[ilk][usr] = _add(gem[ilk][usr], wad);\n        emit Slip(ilk, usr, wad);\n    }\n\n    function flux(bytes32 ilk, address src, address dst, uint256 wad) external {\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\n        gem[ilk][src] = gem[ilk][src] - wad;\n        gem[ilk][dst] = gem[ilk][dst] + wad;\n        emit Flux(ilk, src, dst, wad);\n    }\n\n    function move(address src, address dst, uint256 rad) external {\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\n        dai[src] = dai[src] - rad;\n        dai[dst] = dai[dst] + rad;\n        emit Move(src, dst, rad);\n    }\n\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    function frob(bytes32 i, address u, address v, address w, int256 dink, int256 dart) external {\n        require(live == 1, \"Vat/not-live\");\n\n        Urn memory urn = urns[i][u];\n        Ilk memory ilk = ilks[i];\n        require(ilk.rate != 0, \"Vat/ilk-not-init\");\n\n        urn.ink = _add(urn.ink, dink);\n        urn.art = _add(urn.art, dart);\n        ilk.Art = _add(ilk.Art, dart);\n\n        int256 dtab = _int256(ilk.rate) * dart;\n        uint256 tab = ilk.rate * urn.art;\n        debt     = _add(debt, dtab);\n\n        require(either(dart <= 0, both(ilk.Art * ilk.rate <= ilk.line, debt <= Line)), \"Vat/ceiling-exceeded\");\n        require(either(both(dart <= 0, dink >= 0), tab <= urn.ink * ilk.spot), \"Vat/not-safe\");\n\n        require(either(both(dart <= 0, dink >= 0), wish(u, msg.sender)), \"Vat/not-allowed-u\");\n        require(either(dink <= 0, wish(v, msg.sender)), \"Vat/not-allowed-v\");\n        require(either(dart >= 0, wish(w, msg.sender)), \"Vat/not-allowed-w\");\n\n        require(either(urn.art == 0, tab >= ilk.dust), \"Vat/dust\");\n\n        gem[i][v] = _sub(gem[i][v], dink);\n        dai[w]    = _add(dai[w],    dtab);\n\n        urns[i][u] = urn;\n        ilks[i]    = ilk;\n\n        emit Frob(i, u, v, w, dink, dart);\n    }\n\n    function fork(bytes32 ilk, address src, address dst, int256 dink, int256 dart) external {\n        Urn storage u = urns[ilk][src];\n        Urn storage v = urns[ilk][dst];\n        Ilk storage i = ilks[ilk];\n\n        u.ink = _sub(u.ink, dink);\n        u.art = _sub(u.art, dart);\n        v.ink = _add(v.ink, dink);\n        v.art = _add(v.art, dart);\n\n        uint256 utab = u.art * i.rate;\n        uint256 vtab = v.art * i.rate;\n\n        require(both(wish(src, msg.sender), wish(dst, msg.sender)), \"Vat/not-allowed\");\n\n        require(utab <= u.ink * i.spot, \"Vat/not-safe-src\");\n        require(vtab <= v.ink * i.spot, \"Vat/not-safe-dst\");\n\n        require(either(utab >= i.dust, u.art == 0), \"Vat/dust-src\");\n        require(either(vtab >= i.dust, v.art == 0), \"Vat/dust-dst\");\n\n        emit Fork(ilk, src, dst, dink, dart);\n    }\n\n    function grab(bytes32 i, address u, address v, address w, int256 dink, int256 dart) external auth {\n        Urn storage urn = urns[i][u];\n        Ilk storage ilk = ilks[i];\n\n        urn.ink = _add(urn.ink, dink);\n        urn.art = _add(urn.art, dart);\n        ilk.Art = _add(ilk.Art, dart);\n\n        int256 dtab = _int256(ilk.rate) * dart;\n\n        gem[i][v] = _sub(gem[i][v], dink);\n        sin[w]    = _sub(sin[w],    dtab);\n        vice      = _sub(vice,      dtab);\n\n        emit Grab(i, u, v, w, dink, dart);\n    }\n\n    function heal(uint256 rad) external {\n        address u = msg.sender;\n        sin[u] = sin[u] - rad;\n        dai[u] = dai[u] - rad;\n        vice   = vice   - rad;\n        debt   = debt   - rad;\n\n        emit Heal(msg.sender, rad);\n    }\n\n    function suck(address u, address v, uint256 rad) external auth {\n        sin[u] = sin[u] + rad;\n        dai[v] = dai[v] + rad;\n        vice   = vice   + rad;\n        debt   = debt   + rad;\n\n        emit Suck(u, v, rad);\n    }\n\n    function fold(bytes32 i, address u, int256 rate_) external auth {\n        require(live == 1, \"Vat/not-live\");\n        Ilk storage ilk = ilks[i];\n        ilk.rate    = _add(ilk.rate, rate_);\n        int256 rad  = _int256(ilk.Art) * rate_;\n        dai[u]      = _add(dai[u], rad);\n        debt        = _add(debt,   rad);\n\n        emit Fold(i, u, rate_);\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "wish",
                "_add",
                "_sub",
                "_int256",
                "rely",
                "deny",
                "init",
                "file",
                "cage",
                "Art",
                "rate",
                "spot",
                "line",
                "dust",
                "ink",
                "art",
                "hope",
                "nope",
                "slip",
                "flux",
                "move",
                "either",
                "both",
                "frob",
                "fork",
                "grab",
                "heal",
                "suck",
                "fold"
            ],
            "state_variables": [
                "art",
                "sin",
                "Line",
                "dai",
                "ilks",
                "urns",
                "debt",
                "Art",
                "wards",
                "gem",
                "rate",
                "spot",
                "line",
                "ink",
                "dust",
                "vice",
                "live",
                "can"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "Vat_states_1a0a4cba",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Vat.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.13;\n\ncontract Vat {\n    mapping (address => uint256) public wards;\n    mapping(address => mapping (address => uint256)) public can;\n    struct Ilk {\n        uint256 Art; \n        uint256 rate;\n        uint256 spot;\n        uint256 line;\n        uint256 dust;\n    }\n    struct Urn {\n        uint256 ink;\n        uint256 art;\n    }\n    mapping (bytes32 => Ilk) public ilks;\n    mapping (bytes32 => mapping (address => Urn )) public urns;\n    mapping (bytes32 => mapping (address => uint)) public gem;\n    mapping (address => uint256) public dai;\n    mapping (address => uint256) public sin;\n    uint256 public debt;\n    uint256 public vice;\n    uint256 public Line;\n    uint256 public live;\n\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n    event Init(bytes32 indexed ilk);\n    event File(bytes32 indexed what, uint256 data);\n    event File(bytes32 indexed ilk, bytes32 indexed what, uint256 data);\n    event Cage();\n    event Hope(address indexed from, address indexed to);\n    event Nope(address indexed from, address indexed to);\n    event Slip(bytes32 indexed ilk, address indexed usr, int256 wad);\n    event Flux(bytes32 indexed ilk, address indexed src, address indexed dst, uint256 wad);\n    event Move(address indexed src, address indexed dst, uint256 rad);\n    event Frob(bytes32 indexed i, address indexed u, address v, address w, int256 dink, int256 dart);\n    event Fork(bytes32 indexed ilk, address indexed src, address indexed dst, int256 dink, int256 dart);\n    event Grab(bytes32 indexed i, address indexed u, address v, address w, int256 dink, int256 dart);\n    event Heal(address indexed u, uint256 rad);\n    event Suck(address indexed u, address indexed v, uint256 rad);\n    event Fold(bytes32 indexed i, address indexed u, int256 rate);\n\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Vat/not-authorized\");\n        _;\n    }\n\n    function wish(address bit, address usr) internal view returns (bool) {\n        return either(bit == usr, can[bit][usr] == 1);\n    }\n\n    constructor() {\n        wards[msg.sender] = 1;\n        live = 1;\n        emit Rely(msg.sender);\n    }\n\n    function _add(uint256 x, int256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + uint256(y);\n        }\n        require(y >= 0 || z <= x);\n        require(y <= 0 || z >= x);\n    }\n\n    function _sub(uint256 x, int256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - uint256(y);\n        }\n        require(y <= 0 || z <= x);\n        require(y >= 0 || z >= x);\n    }\n\n    function _int256(uint256 x) internal pure returns (int256 y) {\n        require((y = int256(x)) >= 0);\n    }\n\n    function rely(address usr) external auth {\n        require(live == 1, \"Vat/not-live\");\n        wards[usr] = 1;\n        emit Rely(usr);\n    }\n\n    function deny(address usr) external auth {\n        require(live == 1, \"Vat/not-live\");\n        wards[usr] = 0;\n        emit Deny(usr);\n    }\n\n    function init(bytes32 ilk) external auth {\n        require(ilks[ilk].rate == 0, \"Vat/ilk-already-init\");\n        ilks[ilk].rate = 10 ** 27;\n        emit Init(ilk);\n    }\n\n    function file(bytes32 what, uint256 data) external auth {\n        require(live == 1, \"Vat/not-live\");\n        if (what == \"Line\") Line = data;\n        else revert(\"Vat/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    function file(bytes32 ilk, bytes32 what, uint256 data) external auth {\n        require(live == 1, \"Vat/not-live\");\n        if (what == \"spot\") ilks[ilk].spot = data;\n        else if (what == \"line\") ilks[ilk].line = data;\n        else if (what == \"dust\") ilks[ilk].dust = data;\n        else revert(\"Vat/file-unrecognized-param\");\n        emit File(ilk, what, data);\n    }\n\n    function cage() external auth {\n        live = 0;\n        emit Cage();\n    }\n\n    function Art(bytes32 ilk) external view returns (uint256 Art_) {\n        Art_ = ilks[ilk].Art;\n    }\n\n    function rate(bytes32 ilk) external view returns (uint256 rate_) {\n        rate_ = ilks[ilk].rate;\n    }\n\n    function spot(bytes32 ilk) external view returns (uint256 spot_) {\n        spot_ = ilks[ilk].spot;\n    }\n\n    function line(bytes32 ilk) external view returns (uint256 line_) {\n        line_ = ilks[ilk].line;\n    }\n\n    function dust(bytes32 ilk) external view returns (uint256 dust_) {\n        dust_ = ilks[ilk].dust;\n    }\n\n    function ink(bytes32 ilk, address urn) external view returns (uint256 ink_) {\n        ink_ = urns[ilk][urn].ink;\n    }\n\n    function art(bytes32 ilk, address urn) external view returns (uint256 art_) {\n        art_ = urns[ilk][urn].art;\n    }\n\n    function hope(address usr) external {\n        can[msg.sender][usr] = 1;\n        emit Hope(msg.sender, usr);\n    }\n\n    function nope(address usr) external {\n        can[msg.sender][usr] = 0;\n        emit Nope(msg.sender, usr);\n    }\n\n    function slip(bytes32 ilk, address usr, int256 wad) external auth {\n        gem[ilk][usr] = _add(gem[ilk][usr], wad);\n        emit Slip(ilk, usr, wad);\n    }\n\n    function flux(bytes32 ilk, address src, address dst, uint256 wad) external {\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\n        gem[ilk][src] = gem[ilk][src] - wad;\n        gem[ilk][dst] = gem[ilk][dst] + wad;\n        emit Flux(ilk, src, dst, wad);\n    }\n\n    function move(address src, address dst, uint256 rad) external {\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\n        dai[src] = dai[src] - rad;\n        dai[dst] = dai[dst] + rad;\n        emit Move(src, dst, rad);\n    }\n\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    function frob(bytes32 i, address u, address v, address w, int256 dink, int256 dart) external {\n        require(live == 1, \"Vat/not-live\");\n\n        Urn memory urn = urns[i][u];\n        Ilk memory ilk = ilks[i];\n        require(ilk.rate != 0, \"Vat/ilk-not-init\");\n\n        urn.ink = _add(urn.ink, dink);\n        urn.art = _add(urn.art, dart);\n        ilk.Art = _add(ilk.Art, dart);\n\n        int256 dtab = _int256(ilk.rate) * dart;\n        uint256 tab = ilk.rate * urn.art;\n        debt     = _add(debt, dtab);\n\n        require(either(dart <= 0, both(ilk.Art * ilk.rate <= ilk.line, debt <= Line)), \"Vat/ceiling-exceeded\");\n        require(either(both(dart <= 0, dink >= 0), tab <= urn.ink * ilk.spot), \"Vat/not-safe\");\n\n        require(either(both(dart <= 0, dink >= 0), wish(u, msg.sender)), \"Vat/not-allowed-u\");\n        require(either(dink <= 0, wish(v, msg.sender)), \"Vat/not-allowed-v\");\n        require(either(dart >= 0, wish(w, msg.sender)), \"Vat/not-allowed-w\");\n\n        require(either(urn.art == 0, tab >= ilk.dust), \"Vat/dust\");\n\n        gem[i][v] = _sub(gem[i][v], dink);\n        dai[w]    = _add(dai[w],    dtab);\n\n        urns[i][u] = urn;\n        ilks[i]    = ilk;\n\n        emit Frob(i, u, v, w, dink, dart);\n    }\n\n    function fork(bytes32 ilk, address src, address dst, int256 dink, int256 dart) external {\n        Urn storage u = urns[ilk][src];\n        Urn storage v = urns[ilk][dst];\n        Ilk storage i = ilks[ilk];\n\n        u.ink = _sub(u.ink, dink);\n        u.art = _sub(u.art, dart);\n        v.ink = _add(v.ink, dink);\n        v.art = _add(v.art, dart);\n\n        uint256 utab = u.art * i.rate;\n        uint256 vtab = v.art * i.rate;\n\n        require(both(wish(src, msg.sender), wish(dst, msg.sender)), \"Vat/not-allowed\");\n\n        require(utab <= u.ink * i.spot, \"Vat/not-safe-src\");\n        require(vtab <= v.ink * i.spot, \"Vat/not-safe-dst\");\n\n        require(either(utab >= i.dust, u.art == 0), \"Vat/dust-src\");\n        require(either(vtab >= i.dust, v.art == 0), \"Vat/dust-dst\");\n\n        emit Fork(ilk, src, dst, dink, dart);\n    }\n\n    function grab(bytes32 i, address u, address v, address w, int256 dink, int256 dart) external auth {\n        Urn storage urn = urns[i][u];\n        Ilk storage ilk = ilks[i];\n\n        urn.ink = _add(urn.ink, dink);\n        urn.art = _add(urn.art, dart);\n        ilk.Art = _add(ilk.Art, dart);\n\n        int256 dtab = _int256(ilk.rate) * dart;\n\n        gem[i][v] = _sub(gem[i][v], dink);\n        sin[w]    = _sub(sin[w],    dtab);\n        vice      = _sub(vice,      dtab);\n\n        emit Grab(i, u, v, w, dink, dart);\n    }\n\n    function heal(uint256 rad) external {\n        address u = msg.sender;\n        sin[u] = sin[u] - rad;\n        dai[u] = dai[u] - rad;\n        vice   = vice   - rad;\n        debt   = debt   - rad;\n\n        emit Heal(msg.sender, rad);\n    }\n\n    function suck(address u, address v, uint256 rad) external auth {\n        sin[u] = sin[u] + rad;\n        dai[v] = dai[v] + rad;\n        vice   = vice   + rad;\n        debt   = debt   + rad;\n\n        emit Suck(u, v, rad);\n    }\n\n    function fold(bytes32 i, address u, int256 rate_) external auth {\n        require(live == 1, \"Vat/not-live\");\n        Ilk storage ilk = ilks[i];\n        ilk.rate    = _add(ilk.rate, rate_);\n        int256 rad  = _int256(ilk.Art) * rate_;\n        dai[u]      = _add(dai[u], rad);\n        debt        = _add(debt,   rad);\n\n        emit Fold(i, u, rate_);\n    }\n}",
        "formal_property": "// This invariant states that these two sources of debt, when added, should equal the sum of all DAI balances. \n// vice is the total bad debt.\n// debt is the sum over all DAI balances.\ninvariant fundamental_equation_of_dai()\n   debt() == vice() + sumOfVaultDebtGhost()\n   filtered { f -> !f.isFallback }",
        "nl_summary": "",
        "metadata": {
            "rule_name": "states",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 49,
            "end_line": 54,
            "block_hash": "1a0a4cba6c8cbeee763925655ff06205"
        }
    },
    {
        "id": "PopsicleV3Optimizer_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./interfaces/external/IWETH9.sol\";\nimport \"./utils/ReentrancyGuard.sol\";\nimport './libraries/TransferHelper.sol';\nimport \"./libraries/SqrtPriceMath.sol\";\nimport \"./base/ERC20Permit.sol\";\nimport \"./libraries/PoolActions.sol\";\nimport \"./interfaces/IOptimizerStrategy.sol\";\nimport \"./interfaces/IPopsicleV3Optimizer.sol\";\n\n/// @title PopsicleV3 Optimizer is a yield enchancement v3 contract\n/// @dev PopsicleV3 Optimizer is a Uniswap V3 yield enchancement contract which acts as\n/// intermediary between the user who wants to provide liquidity to specific pools\n/// and earn fees from such actions. The contract ensures that user position is in \n/// range and earns maximum amount of fees available at current liquidity utilization\n/// rate. \ncontract PopsicleV3Optimizer is ERC20Permit, ReentrancyGuard, IPopsicleV3Optimizer {\n    using LowGasSafeMath for uint256;\n    using LowGasSafeMath for uint160;\n    using LowGasSafeMath for uint128;\n    using UnsafeMath for uint256;\n    using SafeCast for uint256;\n    using PoolVariables for IUniswapV3Pool;\n    using PoolActions for IUniswapV3Pool;\n    \n    //Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n    struct MintCallbackData {\n        address payer;\n    }\n    //Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    struct SwapCallbackData {\n        bool zeroForOne;\n    }\n\n    /// @notice Emitted when user adds liquidity\n    /// @param sender The address that minted the liquidity\n    /// @param recipient The address that get shares\n    /// @param share The amount of share of liquidity added by the user to position\n    /// @param amount0 How much token0 was required for the added liquidity\n    /// @param amount1 How much token1 was required for the added liquidity\n    event Deposit(\n        address indexed sender,\n        address indexed recipient,\n        uint256 share,\n        uint256 amount0,\n        uint256 amount1\n    );\n    \n    /// @notice Emitted when user withdraws liquidity\n    /// @param sender The address that minted the liquidity\n    /// @param recipient The address that get amounts\n    /// @param shares of liquidity withdrawn by the user from the position\n    /// @param amount0 How much token0 was required for the added liquidity\n    /// @param amount1 How much token1 was required for the added liquidity\n    event Withdraw(\n        address indexed sender,\n        address indexed recipient,\n        uint256 shares,\n        uint256 amount0,\n        uint256 amount1\n    );\n    \n    /// @notice Emitted when fees was collected from the pool\n    /// @param feesFromPool0 Total amount of fees collected in terms of token 0\n    /// @param feesFromPool1 Total amount of fees collected in terms of token 1\n    /// @param usersFees0 Total amount of fees collected by users in terms of token 0\n    /// @param usersFees1 Total amount of fees collected by users in terms of token 1\n    event CollectFees(\n        uint256 feesFromPool0,\n        uint256 feesFromPool1,\n        uint256 usersFees0,\n        uint256 usersFees1\n    );\n\n    /// @notice Emitted when fees was compuonded to the pool\n    /// @param amount0 Total amount of fees compounded in terms of token 0\n    /// @param amount1 Total amount of fees compounded in terms of token 1\n    event CompoundFees(\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when PopsicleV3 Optimizer changes the position in the pool\n    /// @param tickLower Lower price tick of the positon\n    /// @param tickUpper Upper price tick of the position\n    /// @param amount0 Amount of token 0 deposited to the position\n    /// @param amount1 Amount of token 1 deposited to the position\n    event Rerange(\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 amount0,\n        uint256 amount1\n    );\n    \n    /// @notice Emitted when user collects his fee share\n    /// @param sender User address\n    /// @param fees0 Exact amount of fees claimed by the users in terms of token 0 \n    /// @param fees1 Exact amount of fees claimed by the users in terms of token 1\n    event RewardPaid(\n        address indexed sender,\n        uint256 fees0,\n        uint256 fees1\n    );\n    \n    /// @notice Shows current Optimizer's balances\n    /// @param totalAmount0 Current token0 Optimizer's balance\n    /// @param totalAmount1 Current token1 Optimizer's balance\n    event Snapshot(uint256 totalAmount0, uint256 totalAmount1);\n\n    event TransferGovernance(address indexed previousGovernance, address indexed newGovernance);\n    \n    /// @notice Prevents calls from users\n    modifier onlyGovernance {\n        require(msg.sender == governance, \"OG\");\n        _;\n    }\n\n    /// @inheritdoc IPopsicleV3Optimizer\n    address public immutable override token0;\n    /// @inheritdoc IPopsicleV3Optimizer\n    address public immutable override token1;\n    // WETH address\n    address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    // @inheritdoc IPopsicleV3Optimizer\n    int24 public immutable override tickSpacing;\n\n    uint24 constant GLOBAL_DIVISIONER = 1e6; // for basis point (0.0001%)\n    //The protocol's fee in hundredths of a bip, i.e. 1e-6\n    uint24 constant protocolFee = 2 * 1e5; //20%\n\n    mapping (address => bool) private _operatorApproved;\n\n    // @inheritdoc IPopsicleV3Optimizer\n    IUniswapV3Pool public override pool;\n    // Accrued protocol fees in terms of token0\n    uint256 public protocolFees0;\n    // Accrued protocol fees in terms of token1\n    uint256 public protocolFees1;\n    // Total lifetime accrued fees in terms of token0\n    uint256 public totalFees0;\n    // Total lifetime accrued fees in terms of token1\n    uint256 public totalFees1;\n    \n    // Address of the Optimizer's owner\n    address public governance;\n    // Pending to claim ownership address\n    address public pendingGovernance;\n    //PopsicleV3 Optimizer settings address\n    address public strategy;\n    // Current tick lower of Optimizer pool position\n    int24 public override tickLower;\n    // Current tick higher of Optimizer pool position\n    int24 public override tickUpper;\n    // Checks if Optimizer is initialized\n    bool public initialized;\n\n    bool private _paused = false;\n    \n    /**\n     * @dev After deploying, strategy can be set via `setStrategy()`\n     * @param _pool Underlying Uniswap V3 pool with fee = 3000\n     * @param _strategy Underlying Optimizer Strategy for Optimizer settings\n     */\n     constructor(\n        address _pool,\n        address _strategy\n    ) ERC20(\"Popsicle LP V3 USDT/WETH\", \"PLP\") ERC20Permit(\"Popsicle LP V3 USDT/WETH\") {\n        pool = IUniswapV3Pool(_pool);\n        strategy = _strategy;\n        token0 = pool.token0();\n        token1 = pool.token1();\n        tickSpacing = pool.tickSpacing();\n        governance = msg.sender;\n        _operatorApproved[msg.sender] = true;\n    }\n    //initialize strategy\n    function init() external onlyGovernance {\n        require(!initialized, \"F\");\n        initialized = true;\n        int24 baseThreshold = tickSpacing * IOptimizerStrategy(strategy).tickRangeMultiplier();\n        ( , int24 currentTick, , , , , ) = pool.slot0();\n        int24 tickFloor = PoolVariables.floor(currentTick, tickSpacing);\n        \n        tickLower = tickFloor - baseThreshold;\n        tickUpper = tickFloor + baseThreshold;\n        PoolVariables.checkRange(tickLower, tickUpper); //check ticks also for overflow/underflow\n    }\n    \n    /// @inheritdoc IPopsicleV3Optimizer\n     function deposit(\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        checkDeviation\n        whenNotPaused\n        returns (\n            uint256 shares,\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        _earnFees();\n        _compoundFees(); // prevent user drains others\n        (uint256 usersAmount0, uint256 usersAmount1) = pool.usersAmounts(tickLower, tickUpper);\n        usersAmount0 = usersAmount0.add(_balance0().unsafeDiv(2)); // prevent draining\n        usersAmount1 = usersAmount1.add(_balance1().unsafeDiv(2));\n        \n        // compute the liquidity amount\n        uint128 liquidity = pool.liquidityForAmounts(amount0Desired, amount1Desired, tickLower, tickUpper);\n        \n        (amount0, amount1) = pool.mint(\n            address(this),\n            tickLower,\n            tickUpper,\n            liquidity,\n            abi.encode(MintCallbackData({payer: msg.sender})));\n        \n        require(amount0 > 0 && amount1 > 0, \"ANV\");\n        uint256 shares0 = \n            totalSupply() == 0 \n            ? liquidity\n            : FullMath.mulDiv(amount0, totalSupply(), usersAmount0);\n        \n        uint256 shares1 = \n            totalSupply() == 0 \n            ? liquidity\n            : FullMath.mulDiv(amount1, totalSupply(), usersAmount1);\n        shares =  shares0 < shares1 ? shares0 : shares1;\n\n        _mint(to, shares);\n        require(IOptimizerStrategy(strategy).maxTotalSupply() >= totalSupply(), \"MTS\");\n        emit Deposit(msg.sender, to, shares, amount0, amount1);\n    }\n    \n    /// @inheritdoc IPopsicleV3Optimizer\n    // function withdraw(\n    //     uint256 shares,\n    //     address to\n    // ) \n    //     external\n    //     override\n    //     nonReentrant\n    //     checkDeviation\n    //     whenNotPaused\n    //     returns (\n    //         uint256 amount0,\n    //         uint256 amount1\n    //     )\n    // {\n    //     require(shares > 0, \"S\");\n    //     require(to != address(0), \"WZA\");\n    //     _earnFees();\n    //     _compoundFees();\n    //     uint128 balance0Liquidity = LiquidityAmounts.getLiquidityForAmount0(\n    //             TickMath.getSqrtRatioAtTick(tickLower),\n    //             TickMath.getSqrtRatioAtTick(tickUpper),\n    //             _balance0()\n    //         );\n    //     uint128 balance1Liquidity = LiquidityAmounts.getLiquidityForAmount1(\n    //             TickMath.getSqrtRatioAtTick(tickLower),\n    //             TickMath.getSqrtRatioAtTick(tickUpper),\n    //             _balance1()\n    //         );\n    //     uint128 totalLiquidity = pool.positionLiquidity(tickLower, tickUpper).add128(balance0Liquidity).add128(balance1Liquidity) ;\n    //     (amount0, amount1) = pool.burnLiquidityShare( tickLower, tickUpper, totalSupply(), shares,  to,  totalLiquidity);\n    //     require(amount0 > 0 || amount1 > 0, \"EA\");\n    //     //certora \n    //     // require(!(shares == totalSupply()) || ((amount0 == IERC20(token0).balanceOf(address(pool)) && amount1 == IERC20(token1).balanceOf(address(pool))) ));\n    //     // require(shares == totalSupply() || ((amount0 < IERC20(token0).balanceOf(address(pool)) || amount1 < IERC20(token1).balanceOf(address(pool))) ));\n    //     // Burn shares\n    //     _burn(msg.sender, shares);\n        \n    //     emit Withdraw(msg.sender, shares, amount0, amount1);\n    // }\n    \n    function withdraw(\n        uint256 shares,\n        address to\n    ) \n        external\n        override\n        nonReentrant\n        checkDeviation\n        whenNotPaused\n        returns (\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        require(shares > 0, \"S\");\n        require(to != address(0), \"WZA\");\n        _earnFees();\n        _compoundFees();\n        (amount0, amount1) = pool.burnLiquidityShare(tickLower, tickUpper, totalSupply(), shares,  to);\n        require(amount0 > 0 || amount1 > 0, \"EA\");\n        uint256 imbalancedAmount0 = FullMath.mulDiv(_balance0(), shares, totalSupply());\n        uint256 imbalancedAmount1 = FullMath.mulDiv(_balance1(), shares, totalSupply());\n        if (imbalancedAmount0 > 0) pay(token0, address(this), to, imbalancedAmount0);\n        if (imbalancedAmount1 > 0) pay(token1, address(this), to, imbalancedAmount1);\n        // Burn shares\n        _burn(msg.sender, shares);\n        \n        emit Withdraw(msg.sender, to, shares, amount0, amount1);\n    }\n\n    /// @inheritdoc IPopsicleV3Optimizer\n    function rerange() external override nonReentrant checkDeviation {\n        require(_operatorApproved[msg.sender], \"ONA\");\n        _earnFees();\n        //Burn all liquidity from pool to rerange for Optimizer's balances.\n        pool.burnAllLiquidity(tickLower, tickUpper);\n        \n\n        // Emit snapshot to record balances\n        uint256 balance0 = _balance0();\n        uint256 balance1 = _balance1();\n        emit Snapshot(balance0, balance1);\n\n        int24 baseThreshold = tickSpacing * IOptimizerStrategy(strategy).tickRangeMultiplier();\n\n        //Get exact ticks depending on Optimizer's balances\n        (tickLower, tickUpper) = pool.getPositionTicks(balance0, balance1, baseThreshold, tickSpacing);\n\n        //Get Liquidity for Optimizer's balances\n        uint128 liquidity = pool.liquidityForAmounts(balance0, balance1, tickLower, tickUpper);\n        \n        // Add liquidity to the pool\n        (uint256 amount0, uint256 amount1) = pool.mint(\n            address(this),\n            tickLower,\n            tickUpper,\n            liquidity,\n            abi.encode(MintCallbackData({payer: address(this)})));\n\n        emit Rerange(tickLower, tickUpper, amount0, amount1);\n    }\n\n    /// @inheritdoc IPopsicleV3Optimizer\n    function rebalance() external override nonReentrant checkDeviation {\n        require(_operatorApproved[msg.sender], \"ONA\");\n    //    _earnFees();\n        //Burn all liquidity from pool to rerange for Optimizer's balances.\n        pool.burnAllLiquidity(tickLower, tickUpper);\n        \n        //Calc base ticks\n        (uint160 sqrtPriceX96, int24 currentTick, , , , , ) = pool.slot0();\n        PoolVariables.Info memory cache;\n        int24 baseThreshold = tickSpacing * IOptimizerStrategy(strategy).tickRangeMultiplier();\n        (cache.tickLower, cache.tickUpper) = PoolVariables.baseTicks(currentTick, baseThreshold, tickSpacing);\n        \n        cache.amount0Desired = _balance0();\n        cache.amount1Desired = _balance1();\n        emit Snapshot(cache.amount0Desired, cache.amount1Desired);\n        // Calc liquidity for base ticks\n        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, cache.tickLower, cache.tickUpper);\n\n        // Get exact amounts for base ticks\n        (cache.amount0, cache.amount1) = pool.amountsForLiquidity(cache.liquidity, cache.tickLower, cache.tickUpper);\n\n        // Get imbalanced token\n        bool zeroForOne = PoolVariables.amountsDirection(cache.amount0Desired, cache.amount1Desired, cache.amount0, cache.amount1);\n        // Calculate the amount of imbalanced token that should be swapped. Calculations strive to achieve one to one ratio\n        int256 amountSpecified = \n            zeroForOne\n                ? int256(cache.amount0Desired.sub(cache.amount0).unsafeDiv(2))\n                : int256(cache.amount1Desired.sub(cache.amount1).unsafeDiv(2)); // always positive. \"overflow\" safe convertion cuz we are dividing by 2\n\n        // Calculate Price limit depending on price impact\n        uint160 exactSqrtPriceImpact = sqrtPriceX96.mul160(IOptimizerStrategy(strategy).priceImpactPercentage() / 2) / GLOBAL_DIVISIONER;\n        uint160 sqrtPriceLimitX96 = zeroForOne ?  sqrtPriceX96.sub160(exactSqrtPriceImpact) : sqrtPriceX96.add160(exactSqrtPriceImpact);\n\n        //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit\n        pool.swap(\n            address(this),\n            zeroForOne,\n            amountSpecified,\n            sqrtPriceLimitX96,\n            abi.encode(SwapCallbackData({zeroForOne: zeroForOne}))\n        );\n\n\n        (sqrtPriceX96, currentTick, , , , , ) = pool.slot0();\n\n        // Emit snapshot to record balances\n        cache.amount0Desired = _balance0();\n        cache.amount1Desired = _balance1();\n        emit Snapshot(cache.amount0Desired, cache.amount1Desired);\n        //Get exact ticks depending on Optimizer's new balances\n        (tickLower, tickUpper) = pool.getPositionTicks(cache.amount0Desired, cache.amount1Desired, baseThreshold, tickSpacing);\n\n        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, tickLower, tickUpper);\n\n        // Add liquidity to the pool\n        (cache.amount0, cache.amount1) = pool.mint(\n            address(this),\n            tickLower,\n            tickUpper,\n            cache.liquidity,\n            abi.encode(MintCallbackData({payer: address(this)})));\n\n        emit Rerange(tickLower, tickUpper, cache.amount0, cache.amount1);\n    }\n    \n    /// @dev Amount of token0 held as unused balance.\n    function _balance0() internal view returns (uint256) {\n        return IERC20(token0).balanceOf(address(this)).sub(protocolFees0);\n    }\n\n    /// @dev Amount of token1 held as unused balance.\n    function _balance1() internal view returns (uint256) {\n        return IERC20(token1).balanceOf(address(this)).sub(protocolFees1);\n    }\n    \n    /// @dev collects fees from the pool\n    function _earnFees() internal {\n        uint liquidity = pool.positionLiquidity(tickLower, tickUpper);\n        if (liquidity == 0) return; // we can't poke when liquidity is zero\n         // Do zero-burns to poke the Uniswap pools so earned fees are updated\n        pool.burn(tickLower, tickUpper, 0);\n        \n        (uint256 collect0, uint256 collect1) =\n            pool.collect(\n                address(this),\n                tickLower,\n                tickUpper,\n                type(uint128).max,\n                type(uint128).max\n            );\n\n        // Calculate protocol's fees\n        uint256 earnedProtocolFees0 = collect0.mul(protocolFee).unsafeDiv(GLOBAL_DIVISIONER); //gadi ?\n        uint256 earnedProtocolFees1 = collect1.mul(protocolFee).unsafeDiv(GLOBAL_DIVISIONER); //gadi ?\n        protocolFees0 = protocolFees0.add(earnedProtocolFees0);\n        protocolFees1 = protocolFees1.add(earnedProtocolFees1);\n        totalFees0 = totalFees0.add(collect0);\n        totalFees1 = totalFees1.add(collect1);\n        emit CollectFees(collect0, collect1, totalFees0, totalFees1);\n    }\n\nuint256 public lastCompoundLiquidity;\n\n    function _compoundFees() internal returns (uint256 amount0, uint256 amount1){\n        uint256 balance0 = _balance0();\n        uint256 balance1 = _balance1();\n\n        emit Snapshot(balance0, balance1);\n\n        //Get Liquidity for Optimizer's balances\n        uint128 liquidity = pool.liquidityForAmounts(balance0, balance1, tickLower, tickUpper);\n        \n        // Add liquidity to the pool\n        if (liquidity > 0)\n        {\n            (amount0, amount1) = pool.mint(\n                address(this),\n                tickLower,\n                tickUpper,\n                liquidity,\n                abi.encode(MintCallbackData({payer: address(this)})));\n\n            lastCompoundLiquidity = liquidity; //Gadi, to differientiate between compound and deposit\n\n            emit CompoundFees(amount0, amount1);\n        }\n    }\n\n    /// @notice Returns current Optimizer's position in pool\n    function position() external view returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1) {\n        bytes32 positionKey = PositionKey.compute(address(this), tickLower, tickUpper);\n        (liquidity, feeGrowthInside0LastX128, feeGrowthInside1LastX128, tokensOwed0, tokensOwed1) = pool.positions(positionKey);\n    }\n\n    /// @notice Returns current Optimizer's users amounts in pool\n    function usersAmounts() public view returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = pool.usersAmounts(tickLower, tickUpper);\n        amount0 = amount0.add(_balance0());\n        amount1 = amount1.add(_balance1());\n    }\n    \n    /// @notice Pull in tokens from sender. Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.\n    /// @dev In the implementation you must pay to the pool for the minted liquidity.\n    /// @param amount0 The amount of token0 due to the pool for the minted liquidity\n    /// @param amount1 The amount of token1 due to the pool for the minted liquidity\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n\n    /// @notice Called to `msg.sender` after minting swaping from IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay to the pool for swap.\n    /// @param amount0 The amount of token0 due to the pool for the swap\n    /// @param amount1 The amount of token1 due to the pool for the swap\n    /// @param _data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0,\n        int256 amount1,\n        bytes calldata _data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        require(amount0 > 0 || amount1 > 0, \"LEZ\"); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        bool zeroForOne = data.zeroForOne;\n\n        if (zeroForOne) pay(token0, address(this), msg.sender, uint256(amount0)); \n        else pay(token1, address(this), msg.sender, uint256(amount1));\n    }\n\n    /// @param token The token to pay\n    /// @param payer The entity that must pay\n    /// @param recipient The entity that will receive payment\n    /// @param value The amount to pay\n    /*\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            TransferHelper.safeTransfer(token, recipient, value);\n        } else {\n            // pull payment\n            TransferHelper.safeTransferFrom(token, payer, recipient, value);\n        }\n    } */\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == weth && address(this).balance >= value) {\n            // pay with WETH9\n            IWETH9(weth).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH9(weth).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            //TransferHelper.safeTransfer(token, recipient, value);\n            //certora change\n            IERC20(token).transfer(recipient, value);\n\n        } else {\n            // pull payment\n            //TransferHelper.safeTransferFrom(token, payer, recipient, value);\n            //certora change\n            IERC20(token).transferFrom(payer, recipient, value);\n        }\n    }\n    \n    /**\n     * @notice Used to withdraw accumulated protocol fees.\n     */\n    function collectProtocolFees(\n        uint256 amount0,\n        uint256 amount1\n    ) external nonReentrant onlyGovernance {\n        _earnFees();\n        require(protocolFees0 >= amount0, \"A0F\");\n        require(protocolFees1 >= amount1, \"A1F\");\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);\n        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);\n        \n        protocolFees0 = protocolFees0.sub(amount0);\n        protocolFees1 = protocolFees1.sub(amount1);\n        _compoundFees();\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n    // Function modifier that checks if price has not moved a lot recently.\n    // This mitigates price manipulation during rebalance and also prevents placing orders\n    // when it's too volatile.\n    modifier checkDeviation() {\n    //    pool.checkDeviation(IOptimizerStrategy(strategy).maxTwapDeviation(), IOptimizerStrategy(strategy).twapDuration());\n        _;\n    }\n\n    /**\n     * @notice `setGovernance()` should be called by the existing governance\n     * address prior to calling this function.\n     */\n    function setGovernance(address _governance) external onlyGovernance {\n        pendingGovernance = _governance;\n    }\n\n    /**\n     * @notice Governance address is not updated until the new governance\n     * address has called `acceptGovernance()` to accept this responsibility.\n     */\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"PG\");\n        emit TransferGovernance(governance, pendingGovernance);\n        pendingGovernance = address(0);\n        governance = msg.sender;\n    }\n\n    // Sets new strategy contract address for new settings\n    function setStrategy(address _strategy) external onlyGovernance {\n        require(_strategy != address(0), \"NA\");\n        strategy = _strategy;\n    }\n\n    function approveOperator(address _operator) external onlyGovernance {\n        _operatorApproved[_operator] = true;\n    }\n    \n    function disableOperator(address _operator) external onlyGovernance {\n        _operatorApproved[_operator] = false;\n    }\n    \n    function isOperator(address _operator) external view returns (bool) {\n        return _operatorApproved[_operator];\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"P\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"NP\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function pause() external onlyGovernance whenNotPaused {\n        _paused = true;\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function unpause() external onlyGovernance whenPaused {\n        _paused = false;\n    }\n\n    // certora helpers\n    function amountInUniswapPerShare() public  returns (uint128){\n        uint128 protocolLiquidity = pool.liquidityForAmounts(protocolFees0, protocolFees1, tickLower, tickUpper);\n        uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);\n        uint128 usersLiquidity = liquidity - protocolLiquidity;\n        uint128 amountInUniswapPerShare = usersLiquidity / (uint128) (totalSupply());\n        return amountInUniswapPerShare;\n    }\n    function protocol_Liquidity() public returns (uint128){\n        uint128 protocolLiquidity = pool.liquidityForAmounts(protocolFees0, protocolFees1, tickLower, tickUpper);\n        return protocolLiquidity;\n    }\n    function position_Liquidity() public returns (uint128){\n        uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);\n        return liquidity;\n    }\n}\n\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "init",
                "deposit",
                "withdraw",
                "rerange",
                "rebalance",
                "_balance0",
                "_balance1",
                "_earnFees",
                "_compoundFees",
                "position",
                "usersAmounts",
                "uniswapV3MintCallback",
                "uniswapV3SwapCallback",
                "pay",
                "collectProtocolFees",
                "setGovernance",
                "acceptGovernance",
                "setStrategy",
                "approveOperator",
                "disableOperator",
                "isOperator",
                "callable",
                "pause",
                "unpause",
                "amountInUniswapPerShare",
                "protocol_Liquidity",
                "position_Liquidity"
            ],
            "state_variables": [
                "protocolFees1",
                "lastCompoundLiquidity",
                "payer",
                "protocolFees0",
                "_operatorApproved",
                "zeroForOne",
                "initialized",
                "pendingGovernance",
                "governance",
                "strategy",
                "totalFees0",
                "totalFees1"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "PopsicleV3Optimizer_balance_vs_protocol_Liquidity_0f7fcbc8",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "protocol_Liquidity/uniswapV3MintCallback/uniswapV3SwapCallback",
        "text_chunk": "    function protocol_Liquidity() public returns (uint128){\n        uint128 protocolLiquidity = pool.liquidityForAmounts(protocolFees0, protocolFees1, tickLower, tickUpper);\n        return protocolLiquidity;\n    }\n\n\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n\n\n    function uniswapV3SwapCallback(\n        int256 amount0,\n        int256 amount1,\n        bytes calldata _data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        require(amount0 > 0 || amount1 > 0, \"LEZ\"); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        bool zeroForOne = data.zeroForOne;\n\n        if (zeroForOne) pay(token0, address(this), msg.sender, uint256(amount0)); \n        else pay(token1, address(this), msg.sender, uint256(amount1));\n    }\n",
        "formal_property": "    ///// invariant balance_vs_protocol_Liquidity()\n    ////  verifies that if total supply is zero than all the assets of the system is the owned to governance \n    ////  uniswapV3SwapCallback() - meaningless outside of the swap context\n    ////  uniswapV3MintCallback() - meaningless outside of the mint context\n    invariant balance_vs_protocol_Liquidity()\n    (totalSupply() == 0) => token0.balanceOf(currentContract) == protocolFees0() //&&\n                            //token1.balanceOf(currentContract) == protocolFees1()\n    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "balance_vs_protocol_Liquidity",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "balanceOf",
                "totalSupply",
                "protocol_Liquidity",
                "governance",
                "protocolFees0",
                "protocolFees1",
                "token0.balanceOf",
                "token1.balanceOf",
                "uniswapV3MintCallback",
                "uniswapV3SwapCallback"
            ],
            "start_line": 92,
            "end_line": 99,
            "block_hash": "0f7fcbc8eb08f3d4d849fc24f8787993"
        }
    },
    {
        "id": "PopsicleV3Optimizer_balance_contract_GE_protocolFees_375befc6",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "uniswapV3MintCallback/uniswapV3SwapCallback",
        "text_chunk": "    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n\n\n    function uniswapV3SwapCallback(\n        int256 amount0,\n        int256 amount1,\n        bytes calldata _data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        require(amount0 > 0 || amount1 > 0, \"LEZ\"); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        bool zeroForOne = data.zeroForOne;\n\n        if (zeroForOne) pay(token0, address(this), msg.sender, uint256(amount0)); \n        else pay(token1, address(this), msg.sender, uint256(amount1));\n    }\n",
        "formal_property": "    ///// invariant balance_contract_GE_protocolFees()\n    ////  verifies that balance of the conttract is greater than protocol fees\n    ////  uniswapV3SwapCallback() - meaningles outside of the swap context\n    ////  uniswapV3MintCallback() - meaningles outside of the mint context\n    invariant balance_contract_GE_protocolFees()\n    token0.balanceOf(currentContract) >= protocolFees0()\n    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "balance_contract_GE_protocolFees",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "balanceOf",
                "protocolFees0",
                "token0.balanceOf",
                "uniswapV3MintCallback",
                "uniswapV3SwapCallback"
            ],
            "start_line": 120,
            "end_line": 126,
            "block_hash": "375befc61e45c970b59a864b5d12d7df"
        }
    },
    {
        "id": "PopsicleV3Optimizer_empty_pool_state_5e4716ed",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "collectProtocolFees/uniswapV3MintCallback",
        "text_chunk": "    function collectProtocolFees(\n        uint256 amount0,\n        uint256 amount1\n    ) external nonReentrant onlyGovernance {\n        _earnFees();\n        require(protocolFees0 >= amount0, \"A0F\");\n        require(protocolFees1 >= amount1, \"A1F\");\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);\n        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);\n        \n        protocolFees0 = protocolFees0.sub(amount0);\n        protocolFees1 = protocolFees1.sub(amount1);\n        _compoundFees();\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n",
        "formal_property": "    ///// invariant empty_pool_state()\n    ////  verifies that pool liquidity == 0 IFF totalSupply == 0\n    ////  collectProtocolFees() - it breakes the rule\n    ////  uniswapV3MintCallback() - meaningless outside of the mint context\n    invariant empty_pool_state()\n    pool.liquidity() == 0 <=> totalSupply() == 0\n    filtered { f -> excludeCallback(f) }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "empty_pool_state",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "totalSupply",
                "pool.liquidity",
                "uniswapV3MintCallback"
            ],
            "start_line": 150,
            "end_line": 156,
            "block_hash": "5e4716ed4ce994ac043dc76b45c9290b"
        }
    },
    {
        "id": "PopsicleV3Optimizer_empty_pool_state_reverse_2fda33f9",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "collectProtocolFees/uniswapV3MintCallback",
        "text_chunk": "    function collectProtocolFees(\n        uint256 amount0,\n        uint256 amount1\n    ) external nonReentrant onlyGovernance {\n        _earnFees();\n        require(protocolFees0 >= amount0, \"A0F\");\n        require(protocolFees1 >= amount1, \"A1F\");\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);\n        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);\n        \n        protocolFees0 = protocolFees0.sub(amount0);\n        protocolFees1 = protocolFees1.sub(amount1);\n        _compoundFees();\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n",
        "formal_property": "    ///// invariant empty_pool_state_reverse()\n    ///// invariant empty_pool_state()\n    ////  verifies that pool liquidity == 0 IFF totalSupply == 0\n    ////  collectProtocolFees() - it breakes the rule\n    ////  uniswapV3MintCallback() - meaningless outside of the mint context\n    invariant empty_pool_state()\n    pool.liquidity() == 0 <=> totalSupply() == 0\n    filtered { f -> excludeCallback(f) }\n    ////  verifies that pool liquidity == 0 IFF pool balance - pool owed == 0\n    ////  following function are excluded:\n    invariant empty_pool_state_reverse()\n    pool.liquidity() == 0 <=> (pool.balance0() - pool.owed0() == 0 && pool.balance1() - pool.owed1() == 0)\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "empty_pool_state_reverse",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "pool.liquidity",
                "pool.balance0",
                "pool.balance1",
                "pool.owed0",
                "pool.owed1",
                "uniswapV3MintCallback"
            ],
            "start_line": 176,
            "end_line": 183,
            "block_hash": "2fda33f914f4d15de64a32f9233815dd"
        }
    },
    {
        "id": "PopsicleV3Optimizer_zero_totalSupply_zero_owed_32ecbe8d",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "collectProtocolFees/uniswapV3MintCallback",
        "text_chunk": "    function collectProtocolFees(\n        uint256 amount0,\n        uint256 amount1\n    ) external nonReentrant onlyGovernance {\n        _earnFees();\n        require(protocolFees0 >= amount0, \"A0F\");\n        require(protocolFees1 >= amount1, \"A1F\");\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);\n        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);\n        \n        protocolFees0 = protocolFees0.sub(amount0);\n        protocolFees1 = protocolFees1.sub(amount1);\n        _compoundFees();\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n",
        "formal_property": "    ///// invariant zero_totalSupply_zero_owed()\n    ////  verifies that all assets withdrawn - totalSupply == 0 - no owed assets left in the pool\n    invariant zero_totalSupply_zero_owed()\n    totalSupply() == 0 => (pool.owed0() == 0 && pool.owed1() == 0){ \n    preserved {\n        requireInvariant empty_pool_state();\n    ///// invariant empty_pool_state()\n    ////  verifies that pool liquidity == 0 IFF totalSupply == 0\n    ////  collectProtocolFees() - it breakes the rule\n    ////  uniswapV3MintCallback() - meaningless outside of the mint context\n    invariant empty_pool_state()\n    pool.liquidity() == 0 <=> totalSupply() == 0\n    filtered { f -> excludeCallback(f) }\n    } \n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "zero_totalSupply_zero_owed",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "totalSupply",
                "pool.owed0",
                "pool.owed1"
            ],
            "start_line": 206,
            "end_line": 213,
            "block_hash": "32ecbe8d970954aa0d16db52e28b0277"
        }
    },
    {
        "id": "PopsicleV3Optimizer_pool_balance_vs_owed_b677a432",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "uniswapV3MintCallback",
        "text_chunk": "    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n",
        "formal_property": "    ///// invariant pool_balance_vs_owed()\n    ////  verifies that pool balance greater equal to pool owed\n    ////  uniswapV3MintCallback() - meaningless outside of the mint context\n    invariant pool_balance_vs_owed()\n    pool.balance0() >= pool.owed0() && pool.balance1() >= pool.owed1()\n    filtered { f -> excludeCallback(f) }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "pool_balance_vs_owed",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "pool.balance0",
                "pool.balance1",
                "pool.owed0",
                "pool.owed1",
                "uniswapV3MintCallback"
            ],
            "start_line": 216,
            "end_line": 221,
            "block_hash": "b677a432004da1355b5dc315da16f0b7"
        }
    },
    {
        "id": "PopsicleV3Optimizer_zero_pool_balance_zero_owed_64c82186",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "uniswapV3MintCallback",
        "text_chunk": "    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n",
        "formal_property": "    ///// invariant zero_pool_balance_zero_owed()\n    ////  verifies that pool balance == 0 implies pool owed == 0\n    ////  uniswapV3MintCallback() - meaningless outside of the mint context\n    invariant zero_pool_balance_zero_owed()\n    (pool.balance0() == 0 => pool.owed0() == 0) && \n    (pool.balance1() == 0 => pool.owed1() == 0)\n    filtered { f -> excludeCallback(f) }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "zero_pool_balance_zero_owed",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "pool.balance0",
                "pool.balance1",
                "pool.owed0",
                "pool.owed1",
                "uniswapV3MintCallback"
            ],
            "start_line": 224,
            "end_line": 230,
            "block_hash": "64c82186857d9ed4adf834371cbc6ac1"
        }
    },
    {
        "id": "PopsicleV3Optimizer_total_vs_protocol_Fees_cde78566",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "deposit",
        "text_chunk": "     function deposit(\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        checkDeviation\n        whenNotPaused\n        returns (\n            uint256 shares,\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        _earnFees();\n        _compoundFees(); // prevent user drains others\n        (uint256 usersAmount0, uint256 usersAmount1) = pool.usersAmounts(tickLower, tickUpper);\n        usersAmount0 = usersAmount0.add(_balance0().unsafeDiv(2)); // prevent draining\n        usersAmount1 = usersAmount1.add(_balance1().unsafeDiv(2));\n        \n        // compute the liquidity amount\n        uint128 liquidity = pool.liquidityForAmounts(amount0Desired, amount1Desired, tickLower, tickUpper);\n        \n        (amount0, amount1) = pool.mint(\n            address(this),\n            tickLower,\n            tickUpper,\n            liquidity,\n            abi.encode(MintCallbackData({payer: msg.sender})));\n        \n        require(amount0 > 0 && amount1 > 0, \"ANV\");\n        uint256 shares0 = \n            totalSupply() == 0 \n            ? liquidity\n            : FullMath.mulDiv(amount0, totalSupply(), usersAmount0);\n        \n        uint256 shares1 = \n            totalSupply() == 0 \n            ? liquidity\n            : FullMath.mulDiv(amount1, totalSupply(), usersAmount1);\n        shares =  shares0 < shares1 ? shares0 : shares1;\n\n        _mint(to, shares);\n        require(IOptimizerStrategy(strategy).maxTotalSupply() >= totalSupply(), \"MTS\");\n        emit Deposit(msg.sender, to, shares, amount0, amount1);\n    }\n",
        "formal_property": "    ///// invariant total_vs_protocol_Fees()\n    ////  verifies that total fees greater than protocol fees\n    invariant total_vs_protocol_Fees()\n    totalFees0() > protocolFees0() ||\n    totalFees0() == 0 &&  protocolFees0() == 0\n    {\n        preserved deposit(uint256 amount0Desired,uint256 amount1Desired, address to) with (env e){\n             require to != currentContract && to != pool && to != governance();\n             require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();\n         } \n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "total_vs_protocol_Fees",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "governance",
                "protocolFees0",
                "totalFees0"
            ],
            "start_line": 233,
            "end_line": 243,
            "block_hash": "cde7856669d83eee392da7201f5046aa"
        }
    },
    {
        "id": "PopsicleV3Optimizer_liquidity_GE_poolBalance0_c3957456",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "collectProtocolFees/uniswapV3MintCallback",
        "text_chunk": "    function collectProtocolFees(\n        uint256 amount0,\n        uint256 amount1\n    ) external nonReentrant onlyGovernance {\n        _earnFees();\n        require(protocolFees0 >= amount0, \"A0F\");\n        require(protocolFees1 >= amount1, \"A1F\");\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);\n        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);\n        \n        protocolFees0 = protocolFees0.sub(amount0);\n        protocolFees1 = protocolFees1.sub(amount1);\n        _compoundFees();\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n",
        "formal_property": "    ///// invariant liquidity_GE_poolBalance0()\n    ////  verifies that pool liquidity == pool balance - pool owed\n    ////  collectProtocolFees() - breaks the rule\n    ////  uniswapV3MintCallback() - meaningless outside of the mint context\n    invariant liquidity_GE_poolBalance0()\n    pool.liquidity() == pool.balance0() - pool.owed0()\n    filtered { f -> excludeCallback(f) }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "liquidity_GE_poolBalance0",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "pool.liquidity",
                "pool.balance0",
                "pool.owed0",
                "uniswapV3MintCallback"
            ],
            "start_line": 246,
            "end_line": 252,
            "block_hash": "c395745641b0ecfd5e6733072ad90c02"
        }
    },
    {
        "id": "PopsicleV3Optimizer_zeroCharacteristicOfWithdraw_43b4c95a",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "withdraw",
        "text_chunk": "    function withdraw(\n        uint256 shares,\n        address to\n    ) \n        external\n        override\n        nonReentrant\n        checkDeviation\n        whenNotPaused\n        returns (\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        require(shares > 0, \"S\");\n        require(to != address(0), \"WZA\");\n        _earnFees();\n        _compoundFees();\n        (amount0, amount1) = pool.burnLiquidityShare(tickLower, tickUpper, totalSupply(), shares,  to);\n        require(amount0 > 0 || amount1 > 0, \"EA\");\n        uint256 imbalancedAmount0 = FullMath.mulDiv(_balance0(), shares, totalSupply());\n        uint256 imbalancedAmount1 = FullMath.mulDiv(_balance1(), shares, totalSupply());\n        if (imbalancedAmount0 > 0) pay(token0, address(this), to, imbalancedAmount0);\n        if (imbalancedAmount1 > 0) pay(token1, address(this), to, imbalancedAmount1);\n        // Burn shares\n        _burn(msg.sender, shares);\n        \n        emit Withdraw(msg.sender, to, shares, amount0, amount1);\n    }\n",
        "formal_property": "///// rule zeroCharacteristicOfWithdraw()\n////  verifies that if withraw returns amount0 == 0 and amount1 == 0 then necessarily shares == 0\nrule zeroCharacteristicOfWithdraw(uint256 shares, address to){\n    env e;\n    uint256 amount0;\n    uint256 amount1;\n\n    require governance() != currentContract;\n    require governance() != pool;\n    require to != currentContract && to != pool && to != governance();\n    require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();\n    amount0,amount1 =  withdraw(e,shares, to);\n    assert (amount0 == 0 && amount1 == 0 => shares == 0);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "zeroCharacteristicOfWithdraw",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "governance"
            ],
            "start_line": 278,
            "end_line": 293,
            "block_hash": "43b4c95a3f7bf89d97361dbea543b5be"
        }
    },
    {
        "id": "PopsicleV3Optimizer_more_shares_more_amounts_to_withdraw_cb845d08",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "withdraw",
        "text_chunk": "    function withdraw(\n        uint256 shares,\n        address to\n    ) \n        external\n        override\n        nonReentrant\n        checkDeviation\n        whenNotPaused\n        returns (\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        require(shares > 0, \"S\");\n        require(to != address(0), \"WZA\");\n        _earnFees();\n        _compoundFees();\n        (amount0, amount1) = pool.burnLiquidityShare(tickLower, tickUpper, totalSupply(), shares,  to);\n        require(amount0 > 0 || amount1 > 0, \"EA\");\n        uint256 imbalancedAmount0 = FullMath.mulDiv(_balance0(), shares, totalSupply());\n        uint256 imbalancedAmount1 = FullMath.mulDiv(_balance1(), shares, totalSupply());\n        if (imbalancedAmount0 > 0) pay(token0, address(this), to, imbalancedAmount0);\n        if (imbalancedAmount1 > 0) pay(token1, address(this), to, imbalancedAmount1);\n        // Burn shares\n        _burn(msg.sender, shares);\n        \n        emit Withdraw(msg.sender, to, shares, amount0, amount1);\n    }\n",
        "formal_property": "///// rule more_shares_more_amounts_to_withdraw()\n////  verifies that with larger number of shares one will withdraw a larger amount of assets\n////  this rule passes only when the following line added to burnLiquidityShares():\n////  require (share == liquidity * totalSupply/uint256(liquidityInPool));\n// rule more_shares_more_amounts_to_withdraw( address to){\n// env e;\n//     uint256 sharesX;\n//     uint256 sharesY;\n//     uint256 amount0X;\n//     uint256 amount1X;\n//     uint256 amount0Y;\n//     uint256 amount1Y;\n\n//     require governance() != currentContract;\n//     require governance() != pool;\n//     require to != currentContract && to != pool && to != governance();\n//     require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();\n//     require sharesX > sharesY;\n//     storage init = lastStorage;\n    \n//     amount0X,amount1X =  withdraw(e,sharesX, to);\n//     amount0Y,amount1Y =  withdraw(e,sharesY, to) at init;\n//     assert amount0X >= amount0Y && amount1X >= amount1Y;\n// }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "more_shares_more_amounts_to_withdraw",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "totalSupply",
                "governance"
            ],
            "start_line": 295,
            "end_line": 321,
            "block_hash": "cb845d08b4ee669dba0ee29ca86131d8"
        }
    },
    {
        "id": "PopsicleV3Optimizer_totalSupply_vs_positionAmounts_6fe15b7b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "position_Liquidity",
        "text_chunk": "    function position_Liquidity() public returns (uint128){\n        uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);\n        return liquidity;\n    }\n",
        "formal_property": "///// rule totalSupply_vs_positionAmounts()\n////  verifies that totalSupply before applying f() greater than totalSupply after implies posistion \n////  liquidity before is greater than position liquidity after minus last compound liquidity\nrule totalSupply_vs_positionAmounts(method f){\n   env e;\n\n   uint256 totalSupplyBefore = totalSupply();\n   uint256 posLiquidityBefore = position_Liquidity();\n    require governance() != currentContract;\n    require governance() != pool;\n   require lastCompoundLiquidity(e) == 0;\n   calldataarg args;\n\tf(e,args);\n   uint256 totalSupplyAfter = totalSupply();\n   uint256 posLiquidityAfter = position_Liquidity();   \n   uint256 compoundAfter = lastCompoundLiquidity(e);\n    assert totalSupplyAfter < totalSupplyBefore =>\n            posLiquidityAfter - compoundAfter < posLiquidityBefore;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "totalSupply_vs_positionAmounts",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "totalSupply",
                "position_Liquidity",
                "governance"
            ],
            "start_line": 323,
            "end_line": 346,
            "block_hash": "6fe15b7b7e2ae20d37e3e0e6a420be86"
        }
    },
    {
        "id": "PopsicleV3Optimizer_protocolFees_state_4eb34e82",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "acceptGovernance/uniswapV3MintCallback/uniswapV3SwapCallback",
        "text_chunk": "    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"PG\");\n        emit TransferGovernance(governance, pendingGovernance);\n        pendingGovernance = address(0);\n        governance = msg.sender;\n    }\n\n\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n\n\n    function uniswapV3SwapCallback(\n        int256 amount0,\n        int256 amount1,\n        bytes calldata _data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        require(amount0 > 0 || amount1 > 0, \"LEZ\"); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        bool zeroForOne = data.zeroForOne;\n\n        if (zeroForOne) pay(token0, address(this), msg.sender, uint256(amount0)); \n        else pay(token1, address(this), msg.sender, uint256(amount1));\n    }\n",
        "formal_property": "///// rule protocolFees_state()\n////  verifies that balance of governance before applying f() + the change in protocolFees is greater or equal balance of governance after applying f()\n////  uniswapV3SwapCallback() - meaningless outside of the swap context\n////  uniswapV3MintCallback() - meaningless outside of the mint context\n////  acceptGovernance()      - breaks the rule when governance changes\nrule protocolFees_state(env e, method f, uint256 shares, address to)\n    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector && f.selector != acceptGovernance().selector }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "protocolFees_state",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "governance",
                "uniswapV3MintCallback",
                "uniswapV3SwapCallback"
            ],
            "start_line": 348,
            "end_line": 354,
            "block_hash": "4eb34e82586c7b03fec7400b214eceeb"
        }
    },
    {
        "id": "PopsicleV3Optimizer_empty_pool_zero_totalSupply_0ee3df0b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "collectProtocolFees/uniswapV3MintCallback",
        "text_chunk": "    function collectProtocolFees(\n        uint256 amount0,\n        uint256 amount1\n    ) external nonReentrant onlyGovernance {\n        _earnFees();\n        require(protocolFees0 >= amount0, \"A0F\");\n        require(protocolFees1 >= amount1, \"A1F\");\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);\n        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);\n        \n        protocolFees0 = protocolFees0.sub(amount0);\n        protocolFees1 = protocolFees1.sub(amount1);\n        _compoundFees();\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n",
        "formal_property": "///// rule empty_pool_zero_totalSupply()\n////  verifies that pool is empty IFF totalSupply == 0\n////  uniswapV3MintCallback() - meaningless outside of the mint context\n////  collectProtocolFees() - it breakes the rule\nrule empty_pool_zero_totalSupply(method f, address to)\nfiltered { f -> excludeCallback(f) }{\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "empty_pool_zero_totalSupply",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "totalSupply",
                "uniswapV3MintCallback"
            ],
            "start_line": 381,
            "end_line": 386,
            "block_hash": "0ee3df0bf509cc50c4455692c7f258ec"
        }
    },
    {
        "id": "PopsicleV3Optimizer_withdraw_amount_ca74932f",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "collectProtocolFees/deposit/uniswapV3MintCallback/uniswapV3SwapCallback/withdraw",
        "text_chunk": "    function collectProtocolFees(\n        uint256 amount0,\n        uint256 amount1\n    ) external nonReentrant onlyGovernance {\n        _earnFees();\n        require(protocolFees0 >= amount0, \"A0F\");\n        require(protocolFees1 >= amount1, \"A1F\");\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);\n        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);\n        \n        protocolFees0 = protocolFees0.sub(amount0);\n        protocolFees1 = protocolFees1.sub(amount1);\n        _compoundFees();\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n\n     function deposit(\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        checkDeviation\n        whenNotPaused\n        returns (\n            uint256 shares,\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        _earnFees();\n        _compoundFees(); // prevent user drains others\n        (uint256 usersAmount0, uint256 usersAmount1) = pool.usersAmounts(tickLower, tickUpper);\n        usersAmount0 = usersAmount0.add(_balance0().unsafeDiv(2)); // prevent draining\n        usersAmount1 = usersAmount1.add(_balance1().unsafeDiv(2));\n        \n        // compute the liquidity amount\n        uint128 liquidity = pool.liquidityForAmounts(amount0Desired, amount1Desired, tickLower, tickUpper);\n        \n        (amount0, amount1) = pool.mint(\n            address(this),\n            tickLower,\n            tickUpper,\n            liquidity,\n            abi.encode(MintCallbackData({payer: msg.sender})));\n        \n        require(amount0 > 0 && amount1 > 0, \"ANV\");\n        uint256 shares0 = \n            totalSupply() == 0 \n            ? liquidity\n            : FullMath.mulDiv(amount0, totalSupply(), usersAmount0);\n        \n        uint256 shares1 = \n            totalSupply() == 0 \n            ? liquidity\n            : FullMath.mulDiv(amount1, totalSupply(), usersAmount1);\n        shares =  shares0 < shares1 ? shares0 : shares1;\n\n        _mint(to, shares);\n        require(IOptimizerStrategy(strategy).maxTotalSupply() >= totalSupply(), \"MTS\");\n        emit Deposit(msg.sender, to, shares, amount0, amount1);\n    }\n\n\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n\n\n    function uniswapV3SwapCallback(\n        int256 amount0,\n        int256 amount1,\n        bytes calldata _data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        require(amount0 > 0 || amount1 > 0, \"LEZ\"); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        bool zeroForOne = data.zeroForOne;\n\n        if (zeroForOne) pay(token0, address(this), msg.sender, uint256(amount0)); \n        else pay(token1, address(this), msg.sender, uint256(amount1));\n    }\n\n\n    function withdraw(\n        uint256 shares,\n        address to\n    ) \n        external\n        override\n        nonReentrant\n        checkDeviation\n        whenNotPaused\n        returns (\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        require(shares > 0, \"S\");\n        require(to != address(0), \"WZA\");\n        _earnFees();\n        _compoundFees();\n        (amount0, amount1) = pool.burnLiquidityShare(tickLower, tickUpper, totalSupply(), shares,  to);\n        require(amount0 > 0 || amount1 > 0, \"EA\");\n        uint256 imbalancedAmount0 = FullMath.mulDiv(_balance0(), shares, totalSupply());\n        uint256 imbalancedAmount1 = FullMath.mulDiv(_balance1(), shares, totalSupply());\n        if (imbalancedAmount0 > 0) pay(token0, address(this), to, imbalancedAmount0);\n        if (imbalancedAmount1 > 0) pay(token1, address(this), to, imbalancedAmount1);\n        // Burn shares\n        _burn(msg.sender, shares);\n        \n        emit Withdraw(msg.sender, to, shares, amount0, amount1);\n    }\n",
        "formal_property": "// rule withdraw_amount(address to){\n//     env e;\n\n//     require governance() != currentContract;\n//     require governance() != pool;\n//     require (to!=governance() && to != pool && to != currentContract);\n//     require e.msg.sender != pool && e.msg.sender != currentContract && e.msg.sender != governance();\n//     require token0.balanceOf(currentContract) == 0 &&\n//             token1.balanceOf(currentContract) == 0;\n//             requireInvariant empty_pool_state();\n    ///// invariant empty_pool_state()\n    ////  verifies that pool liquidity == 0 IFF totalSupply == 0\n    ////  collectProtocolFees() - it breakes the rule\n    ////  uniswapV3MintCallback() - meaningless outside of the mint context\n    invariant empty_pool_state()\n    pool.liquidity() == 0 <=> totalSupply() == 0\n    filtered { f -> excludeCallback(f) }\n//             requireInvariant zero_totalSupply_zero_owed();\n    ///// invariant zero_totalSupply_zero_owed()\n    ////  verifies that all assets withdrawn - totalSupply == 0 - no owed assets left in the pool\n    invariant zero_totalSupply_zero_owed()\n    totalSupply() == 0 => (pool.owed0() == 0 && pool.owed1() == 0){ \n    preserved {\n        requireInvariant empty_pool_state();\n    } \n    }\n//             requireInvariant pool_balance_vs_owed();\n    ///// invariant pool_balance_vs_owed()\n    ////  verifies that pool balance greater equal to pool owed\n    invariant pool_balance_vs_owed()\n    pool.balance0() >= pool.owed0() && pool.balance1() >= pool.owed1()\n//             requireInvariant total_vs_protocol_Fees();\n    ///// invariant total_vs_protocol_Fees()\n    ////  verifies that total fees greater than protocol fees\n    invariant total_vs_protocol_Fees()\n    totalFees0() > protocolFees0() ||\n    totalFees0() == 0 &&  protocolFees0() == 0\n    {\n        preserved deposit(uint256 amount0Desired,uint256 amount1Desired, address to) with (env e){\n             require to != currentContract && to != pool && to != governance();\n             require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();\n         } \n//             requireInvariant liquidity_GE_poolBalance0();\n    ///// invariant liquidity_GE_poolBalance0()\n    ////  verifies that pool liquidity == pool balance - pool owed\n    ////  collectProtocolFees() - breaks the rule\n    invariant liquidity_GE_poolBalance0()\n    pool.liquidity() == pool.balance0() - pool.owed0()\n//             requireInvariant balance_contract_GE_protocolFees();\n    ///// invariant balance_contract_GE_protocolFees()\n    ////  verifies that balance of the conttract is greater than protocol fees\n    ////  uniswapV3SwapCallback() - meaningles outside of the swap context\n    ////  uniswapV3MintCallback() - meaningles outside of the mint context\n    invariant balance_contract_GE_protocolFees()\n    token0.balanceOf(currentContract) >= protocolFees0()\n    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector }\n//     uint256 shares;\n//     uint256 amount0;\n//     uint256 amount1;\n//     uint256 totalsupply = totalSupply();\n//     uint256 pool_balance0 = pool.balance0();\n//     uint256 pool_owed0 = pool.owed0();\n//             amount0,amount1 =  withdraw(e,shares, to);\n    \n//     // uint256 amount0_calc = (pool_balance0 - pool_owed0) * shares / totalsupply;\n//     mathint amount0_calc = pool_balance0 * shares / totalsupply;\n//     require amount0_calc >= 1;\n//     assert  amount0 <= amount0_calc;\n// }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "withdraw_amount",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "balanceOf",
                "totalSupply",
                "governance",
                "token0.balanceOf",
                "token1.balanceOf",
                "pool.balance0",
                "pool.owed0"
            ],
            "start_line": 423,
            "end_line": 456,
            "block_hash": "ca74932f31646ae75b1447b838e76810"
        }
    },
    {
        "id": "PopsicleV3Optimizer_zeroBalancesAfterRebalance_f31d64c6",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "rebalance",
        "text_chunk": "    function rebalance() external override nonReentrant checkDeviation {\n        require(_operatorApproved[msg.sender], \"ONA\");\n    //    _earnFees();\n        //Burn all liquidity from pool to rerange for Optimizer's balances.\n        pool.burnAllLiquidity(tickLower, tickUpper);\n        \n        //Calc base ticks\n        (uint160 sqrtPriceX96, int24 currentTick, , , , , ) = pool.slot0();\n        PoolVariables.Info memory cache;\n        int24 baseThreshold = tickSpacing * IOptimizerStrategy(strategy).tickRangeMultiplier();\n        (cache.tickLower, cache.tickUpper) = PoolVariables.baseTicks(currentTick, baseThreshold, tickSpacing);\n        \n        cache.amount0Desired = _balance0();\n        cache.amount1Desired = _balance1();\n        emit Snapshot(cache.amount0Desired, cache.amount1Desired);\n        // Calc liquidity for base ticks\n        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, cache.tickLower, cache.tickUpper);\n\n        // Get exact amounts for base ticks\n        (cache.amount0, cache.amount1) = pool.amountsForLiquidity(cache.liquidity, cache.tickLower, cache.tickUpper);\n\n        // Get imbalanced token\n        bool zeroForOne = PoolVariables.amountsDirection(cache.amount0Desired, cache.amount1Desired, cache.amount0, cache.amount1);\n        // Calculate the amount of imbalanced token that should be swapped. Calculations strive to achieve one to one ratio\n        int256 amountSpecified = \n            zeroForOne\n                ? int256(cache.amount0Desired.sub(cache.amount0).unsafeDiv(2))\n                : int256(cache.amount1Desired.sub(cache.amount1).unsafeDiv(2)); // always positive. \"overflow\" safe convertion cuz we are dividing by 2\n\n        // Calculate Price limit depending on price impact\n        uint160 exactSqrtPriceImpact = sqrtPriceX96.mul160(IOptimizerStrategy(strategy).priceImpactPercentage() / 2) / GLOBAL_DIVISIONER;\n        uint160 sqrtPriceLimitX96 = zeroForOne ?  sqrtPriceX96.sub160(exactSqrtPriceImpact) : sqrtPriceX96.add160(exactSqrtPriceImpact);\n\n        //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit\n        pool.swap(\n            address(this),\n            zeroForOne,\n            amountSpecified,\n            sqrtPriceLimitX96,\n            abi.encode(SwapCallbackData({zeroForOne: zeroForOne}))\n        );\n\n\n        (sqrtPriceX96, currentTick, , , , , ) = pool.slot0();\n\n        // Emit snapshot to record balances\n        cache.amount0Desired = _balance0();\n        cache.amount1Desired = _balance1();\n        emit Snapshot(cache.amount0Desired, cache.amount1Desired);\n        //Get exact ticks depending on Optimizer's new balances\n        (tickLower, tickUpper) = pool.getPositionTicks(cache.amount0Desired, cache.amount1Desired, baseThreshold, tickSpacing);\n\n        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, tickLower, tickUpper);\n\n        // Add liquidity to the pool\n        (cache.amount0, cache.amount1) = pool.mint(\n            address(this),\n            tickLower,\n            tickUpper,\n            cache.liquidity,\n            abi.encode(MintCallbackData({payer: address(this)})));\n\n        emit Rerange(tickLower, tickUpper, cache.amount0, cache.amount1);\n    }\n",
        "formal_property": "/* rule zeroBalancesAfterRebalance(){\n    env e;\n    rebalance(e);\n    assert (token0.balanceOf(e, currentContract)==0 && \n                             token1.balanceOf(e, currentContract)==0);\n} */\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "zeroBalancesAfterRebalance",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "balanceOf",
                "token0.balanceOf",
                "token1.balanceOf"
            ],
            "start_line": 458,
            "end_line": 463,
            "block_hash": "f31d64c605997439630566263d0168c5"
        }
    },
    {
        "id": "ERC1155Supply_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC1155Supply.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                _totalSupply[ids[i]] += amounts[i];\n            }\n        }\n\n        if (to == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 id = ids[i];\n                uint256 amount = amounts[i];\n                uint256 supply = _totalSupply[id];\n                require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");\n                unchecked {\n                    _totalSupply[id] = supply - amount;\n                }\n            }\n        }\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "totalSupply",
                "exists",
                "_beforeTokenTransfer"
            ],
            "state_variables": [
                "_totalSupply"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC1155Supply_total_supply_is_sum_of_balances_625f2010",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC1155Supply.sol",
        "target_function": "totalSupply",
        "text_chunk": "    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n",
        "formal_property": "invariant total_supply_is_sum_of_balances(uint256 token)\n    sumOfBalances[token] == totalSupply(token)\n    {\n        preserved {\n            requireInvariant balanceOfZeroAddressIsZero(token);\ninvariant balanceOfZeroAddressIsZero(uint256 token)\n    balanceOf(0, token) == 0\n\n/// If a user has a token, then the token should exist.\nrule held_tokens_should_exist {\n    address user; uint256 token;\n    requireInvariant balanceOfZeroAddressIsZero(token);\n    // This assumption is safe because of total_supply_is_sum_of_balances\n    require balanceOf(user, token) <= totalSupply(token);\n    // note: `exists_wrapper` just calls `exists`\n    assert balanceOf(user, token) > 0 => exists_wrapper(token),\n        \"if a user's balance for a token is positive, the token must exist\";\n}\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "total_supply_is_sum_of_balances",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "totalSupply",
                "balanceOf"
            ],
            "start_line": 45,
            "end_line": 51,
            "block_hash": "625f2010ecc0a6d2780b83ade6d7ed6b"
        }
    },
    {
        "id": "ERC1155Supply_balanceOfZeroAddressIsZero_835be1fa",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC1155Supply.sol",
        "target_function": "totalSupply",
        "text_chunk": "    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n",
        "formal_property": "invariant balanceOfZeroAddressIsZero(uint256 token)\n    balanceOf(0, token) == 0\n\n/// If a user has a token, then the token should exist.\nrule held_tokens_should_exist {\n    address user; uint256 token;\n    requireInvariant balanceOfZeroAddressIsZero(token);\n    // This assumption is safe because of total_supply_is_sum_of_balances\ninvariant total_supply_is_sum_of_balances(uint256 token)\n    sumOfBalances[token] == totalSupply(token)\n    {\n        preserved {\n            requireInvariant balanceOfZeroAddressIsZero(token);\n    require balanceOf(user, token) <= totalSupply(token);\n    // note: `exists_wrapper` just calls `exists`\n    assert balanceOf(user, token) > 0 => exists_wrapper(token),\n        \"if a user's balance for a token is positive, the token must exist\";\n}\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "balanceOfZeroAddressIsZero",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "totalSupply",
                "balanceOf",
                "exists_wrapper"
            ],
            "start_line": 56,
            "end_line": 71,
            "block_hash": "835be1fae97f8e9ebcc4092140b49551"
        }
    },
    {
        "id": "ERC1155Supply_token_totalSupply_independence_dc6e140a",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Supply.sol",
        "target_function": "totalSupply",
        "text_chunk": "    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n",
        "formal_property": "rule token_totalSupply_independence(method f)\nfiltered {\n    f -> f.selector != safeBatchTransferFrom(address,address,uint256[],uint256[],bytes).selector\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "token_totalSupply_independence",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "totalSupply"
            ],
            "start_line": 11,
            "end_line": 14,
            "block_hash": "dc6e140a7e616b86053cb791183477df"
        }
    },
    {
        "id": "ERC1155Supply_held_tokens_should_exist_2aa87e4b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Supply.sol",
        "target_function": "totalSupply",
        "text_chunk": "    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n",
        "formal_property": "rule held_tokens_should_exist {\n    address user; uint256 token;\n\n    requireInvariant balanceOfZeroAddressIsZero(token);\ninvariant balanceOfZeroAddressIsZero(uint256 token)\n    balanceOf(0, token) == 0\n/// If a user has a token, then the token should exist.\n    // This assumption is safe because of total_supply_is_sum_of_balances\ninvariant total_supply_is_sum_of_balances(uint256 token)\n    sumOfBalances[token] == totalSupply(token)\n    {\n        preserved {\n            requireInvariant balanceOfZeroAddressIsZero(token);\n    require balanceOf(user, token) <= totalSupply(token);\n    // note: `exists_wrapper` just calls `exists`\n    assert balanceOf(user, token) > 0 => exists_wrapper(token),\n        \"if a user's balance for a token is positive, the token must exist\";\n}\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "held_tokens_should_exist",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "totalSupply",
                "balanceOf",
                "exists_wrapper"
            ],
            "start_line": 60,
            "end_line": 71,
            "block_hash": "2aa87e4b0c18f4de91d6d33843bef97e"
        }
    },
    {
        "id": "ERC1155Supply_sanity_8c5c3208",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Supply.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                _totalSupply[ids[i]] += amounts[i];\n            }\n        }\n\n        if (to == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 id = ids[i];\n                uint256 amount = amounts[i];\n                uint256 supply = _totalSupply[id];\n                require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");\n                unchecked {\n                    _totalSupply[id] = supply - amount;\n                }\n            }\n        }\n    }\n}\n",
        "formal_property": "rule sanity {\n    method f; env e; calldataarg args;\n\n    f(e, args);\n    assert false;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sanity",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 75,
            "end_line": 81,
            "block_hash": "8c5c3208b3ec20693ea4068611567512"
        }
    },
    {
        "id": "ERC1155Burnable_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "burn",
                "burnBatch"
            ],
            "state_variables": [],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC1155Burnable_onlyHolderOrApprovedCanReduceBalance_edc154e9",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n",
        "formal_property": "rule onlyHolderOrApprovedCanReduceBalance(method f) \n{\n    address holder; uint256 token; uint256 amount;\n    uint256 balanceBefore = balanceOf(holder, token);\n\n    env e; calldataarg args;\n    f(e, args);\n    uint256 balanceAfter = balanceOf(holder, token);\n    assert balanceAfter < balanceBefore => e.msg.sender == holder || isApprovedForAll(holder, e.msg.sender), \n        \"An account balance may only be reduced by the holder or a holder-approved agent\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "onlyHolderOrApprovedCanReduceBalance",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "isApprovedForAll"
            ],
            "start_line": 8,
            "end_line": 20,
            "block_hash": "edc154e9e2ff4e00dc1db6146ef38b14"
        }
    },
    {
        "id": "ERC1155Burnable_holds_be8ac5a4",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burn",
        "text_chunk": "    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n",
        "formal_property": "/// n.b. This rule holds for `burnBatch` as well due to rules establishing \n/// appropriate equivance between `burn` and `burnBatch` methods.\nrule burnAmountProportionalToBalanceReduction {\n    storage beforeBurn = lastStorage;\n    env e;\n    \n    address holder; uint256 token;\n    mathint startingBalance = balanceOf(holder, token);\n    uint256 smallBurn; uint256 largeBurn;\n    require smallBurn < largeBurn;\n\n    // smaller burn amount\n    burn(e, holder, token, smallBurn) at beforeBurn;\n    mathint smallBurnBalanceChange = startingBalance - balanceOf(holder, token);\n    // larger burn amount\n    burn(e, holder, token, largeBurn) at beforeBurn;\n    mathint largeBurnBalanceChange = startingBalance - balanceOf(holder, token);\n    assert smallBurnBalanceChange < largeBurnBalanceChange, \n        \"A larger burn must lead to a larger decrease in balance\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "holds",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf"
            ],
            "start_line": 24,
            "end_line": 45,
            "block_hash": "be8ac5a4e06b236877dbcaff1ad69184"
        }
    },
    {
        "id": "ERC1155Burnable_holds_8dbc56a7",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burn",
        "text_chunk": "    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n",
        "formal_property": "/// This rule holds for `burnBatch` as well due to rules establishing \n/// appropriate equivance between `burn` and `burnBatch` methods.\nrule sequentialBurnsEquivalentToSingleBurnOfSum {\n    storage beforeBurns = lastStorage;\n    env e;\n\n    address holder; uint256 token;\n    mathint startingBalance = balanceOf(holder, token);\n    uint256 firstBurn; uint256 secondBurn; uint256 sumBurn;\n    require sumBurn == firstBurn + secondBurn;\n    // sequential burns\n    burn(e, holder, token, firstBurn) at beforeBurns;\n    burn(e, holder, token, secondBurn);\n    mathint sequentialBurnsBalanceChange = startingBalance - balanceOf(holder, token);\n    // burn of sum of sequential burns\n    burn(e, holder, token, sumBurn) at beforeBurns;\n    mathint sumBurnBalanceChange = startingBalance - balanceOf(holder, token);\n    assert sequentialBurnsBalanceChange == sumBurnBalanceChange, \n        \"Sequential burns must be equivalent to a burn of their sum\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "holds",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf"
            ],
            "start_line": 49,
            "end_line": 71,
            "block_hash": "8dbc56a783a5fc4b36d4da802036498d"
        }
    },
    {
        "id": "ERC1155Burnable_singleTokenBurnBurnBatchEquivalence_b36c808e",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burn/burnBatch",
        "text_chunk": "    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n",
        "formal_property": "rule singleTokenBurnBurnBatchEquivalence {\n    storage beforeBurn = lastStorage;\n    env e;\n\n    address holder;\n    uint256 token; uint256 burnAmount;\n    uint256[] tokens; uint256[] burnAmounts;\n    mathint startingBalance = balanceOf(holder, token);\n    require tokens.length == 1; require burnAmounts.length == 1;\n    require tokens[0] == token; require burnAmounts[0] == burnAmount;\n    // burning via burn\n    burn(e, holder, token, burnAmount) at beforeBurn;\n    mathint burnBalanceChange = startingBalance - balanceOf(holder, token);\n    // burning via burnBatch\n    burnBatch(e, holder, tokens, burnAmounts) at beforeBurn;\n    mathint burnBatchBalanceChange = startingBalance - balanceOf(holder, token);\n    assert burnBalanceChange == burnBatchBalanceChange, \n        \"Burning a single token via burn or burnBatch must be equivalent\";\n}   \n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "singleTokenBurnBurnBatchEquivalence",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf"
            ],
            "start_line": 75,
            "end_line": 98,
            "block_hash": "b36c808e5929b289985dd52ef07ecb44"
        }
    },
    {
        "id": "ERC1155Burnable_multipleTokenBurnBurnBatchEquivalence_910a5d21",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burn/burnBatch",
        "text_chunk": "    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n",
        "formal_property": "rule multipleTokenBurnBurnBatchEquivalence {\n    storage beforeBurns = lastStorage;\n    env e;\n\n    address holder;\n    uint256 tokenA; uint256 tokenB; uint256 tokenC;\n    uint256 burnAmountA; uint256 burnAmountB; uint256 burnAmountC;\n    uint256[] tokens; uint256[] burnAmounts;\n    mathint startingBalanceA = balanceOf(holder, tokenA);\n    mathint startingBalanceB = balanceOf(holder, tokenB);\n    mathint startingBalanceC = balanceOf(holder, tokenC);\n    require tokens.length == 3; require burnAmounts.length == 3;\n    require tokens[0] == tokenA; require burnAmounts[0] == burnAmountA;\n    require tokens[1] == tokenB; require burnAmounts[1] == burnAmountB;\n    require tokens[2] == tokenC; require burnAmounts[2] == burnAmountC;\n    // burning via burn\n    burn(e, holder, tokenA, burnAmountA) at beforeBurns;\n    burn(e, holder, tokenB, burnAmountB);\n    burn(e, holder, tokenC, burnAmountC);\n    mathint burnBalanceChangeA = startingBalanceA - balanceOf(holder, tokenA);\n    mathint burnBalanceChangeB = startingBalanceB - balanceOf(holder, tokenB);\n    mathint burnBalanceChangeC = startingBalanceC - balanceOf(holder, tokenC);\n    // burning via burnBatch\n    burnBatch(e, holder, tokens, burnAmounts) at beforeBurns;\n    mathint burnBatchBalanceChangeA = startingBalanceA - balanceOf(holder, tokenA);\n    mathint burnBatchBalanceChangeB = startingBalanceB - balanceOf(holder, tokenB);\n    mathint burnBatchBalanceChangeC = startingBalanceC - balanceOf(holder, tokenC);\n    assert burnBalanceChangeA == burnBatchBalanceChangeA\n        && burnBalanceChangeB == burnBatchBalanceChangeB\n        && burnBalanceChangeC == burnBatchBalanceChangeC, \n        \"Burning multiple tokens via burn or burnBatch must be equivalent\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "multipleTokenBurnBurnBatchEquivalence",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf"
            ],
            "start_line": 102,
            "end_line": 138,
            "block_hash": "910a5d2195a02737956a9660023e47e4"
        }
    },
    {
        "id": "ERC1155Burnable_burnBatchOnEmptyArraysChangesNothing_1e0543c1",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burnBatch",
        "text_chunk": "    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n",
        "formal_property": "rule burnBatchOnEmptyArraysChangesNothing {\n    uint256 token; address nonHolderA; address nonHolderB;\n\n    uint256 startingBalance = balanceOf(nonHolderA, token);\n    bool startingPermission = isApprovedForAll(nonHolderA, nonHolderB);\n    env e; address holder; uint256[] noTokens; uint256[] noBurnAmounts;\n    require noTokens.length == 0; require noBurnAmounts.length == 0;\n    burnBatch(e, holder, noTokens, noBurnAmounts);\n    \n    uint256 endingBalance = balanceOf(nonHolderA, token);\n    bool endingPermission = isApprovedForAll(nonHolderA, nonHolderB);\n    assert startingBalance == endingBalance, \n        \"burnBatch must not change token balances if passed empty arrays\";\n    assert startingPermission == endingPermission, \n        \"burnBatch must not change account permissions if passed empty arrays\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burnBatchOnEmptyArraysChangesNothing",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "isApprovedForAll"
            ],
            "start_line": 142,
            "end_line": 160,
            "block_hash": "1e0543c135155bb4e5be455688fa2007"
        }
    },
    {
        "id": "ERC1155Burnable_should_450cab67",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n",
        "formal_property": "/// This rule should always fail.\nrule sanity {\n    method f; env e; calldataarg args;\n\n    f(e, args);\n    assert false, \n        \"This rule should always fail\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "should",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 163,
            "end_line": 171,
            "block_hash": "450cab677b62d88c95aed0ef1036d926"
        }
    },
    {
        "id": "ERC1155Pausable_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "_beforeTokenTransfer"
            ],
            "state_variables": [],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC1155Pausable_balancesUnchangedWhenPaused_40127c8c",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": "rule balancesUnchangedWhenPaused() {\n    address user; uint256 token;\n    uint256 balanceBefore = balanceOf(user, token);\n\n    require paused();\n    method f; calldataarg arg; env e;\n    f(e, arg);\n    uint256 balanceAfter = balanceOf(user, token);\n    assert balanceBefore == balanceAfter, \n        \"Token balance for a user must not change in a paused contract\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "balancesUnchangedWhenPaused",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "paused"
            ],
            "start_line": 8,
            "end_line": 21,
            "block_hash": "40127c8c91fd7bd1ec8ce6324e8b6efb"
        }
    },
    {
        "id": "ERC1155Pausable_transferMethodsRevertWhenPaused_7df3a081",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": "rule transferMethodsRevertWhenPaused (method f)\nfiltered {\n    f -> f.selector == safeTransferFrom(address,address,uint256,uint256,bytes).selector\n      || f.selector == safeBatchTransferFrom(address,address,uint256[],uint256[],bytes).selector\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferMethodsRevertWhenPaused",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 24,
            "end_line": 28,
            "block_hash": "7df3a0810c70c39e4a624bc097d4acba"
        }
    },
    {
        "id": "ERC1155Pausable_pauseMethodPausesContract_b63ddc2f",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": "rule pauseMethodPausesContract {\n    require !paused();\n\n    env e;\n    pause(e);\n    assert paused(), \n        \"Calling pause must pause an unpaused contract\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "pauseMethodPausesContract",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "paused"
            ],
            "start_line": 40,
            "end_line": 48,
            "block_hash": "b63ddc2f199c427c663148a640f7df87"
        }
    },
    {
        "id": "ERC1155Pausable_unpauseMethodUnpausesContract_2bdf8208",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": "rule unpauseMethodUnpausesContract {\n    require paused();\n\n    env e;\n    unpause(e);\n    assert !paused(), \n        \"Calling unpause must unpause a paused contract\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "unpauseMethodUnpausesContract",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "paused"
            ],
            "start_line": 51,
            "end_line": 59,
            "block_hash": "2bdf8208c2b1127fb7ffb9838e4373e6"
        }
    },
    {
        "id": "ERC1155Pausable_cannotPauseWhilePaused_8045b327",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": "rule cannotPauseWhilePaused {\n    require paused();\n\n    env e;\n    pause@withrevert(e);\n    assert lastReverted, \n        \"A call to pause when already paused must revert\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cannotPauseWhilePaused",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "paused"
            ],
            "start_line": 62,
            "end_line": 70,
            "block_hash": "8045b32760096caf36678b2c21c2e21c"
        }
    },
    {
        "id": "ERC1155Pausable_cannotUnpauseWhileUnpaused_de22c5cc",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": "rule cannotUnpauseWhileUnpaused {\n    require !paused();\n\n    env e;\n    unpause@withrevert(e);\n    assert lastReverted, \n        \"A call to unpause when already unpaused must revert\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cannotUnpauseWhileUnpaused",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "paused"
            ],
            "start_line": 73,
            "end_line": 81,
            "block_hash": "de22c5cc0f707dbb18b2b42f3a1db065"
        }
    },
    {
        "id": "ERC1155Pausable_whenNotPausedModifierCausesRevertIfPaused_9f165b3f",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": "rule whenNotPausedModifierCausesRevertIfPaused {\n    require paused();\n\n    env e; calldataarg args;\n    onlyWhenNotPausedMethod@withrevert(e, args);\n    assert lastReverted, \n        \"Functions with the whenNotPaused modifier must revert if the contract is paused\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "whenNotPausedModifierCausesRevertIfPaused",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "paused"
            ],
            "start_line": 85,
            "end_line": 93,
            "block_hash": "9f165b3f3bd23455e9ceb6cb32ac9df0"
        }
    },
    {
        "id": "ERC1155Pausable_whenPausedModifierCausesRevertIfUnpaused_9110e90d",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": "rule whenPausedModifierCausesRevertIfUnpaused {\n    require !paused();\n\n    env e; calldataarg args;\n    onlyWhenPausedMethod@withrevert(e, args);\n    assert lastReverted, \n        \"Functions with the whenPaused modifier must revert if the contract is not paused\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "whenPausedModifierCausesRevertIfUnpaused",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "paused"
            ],
            "start_line": 97,
            "end_line": 105,
            "block_hash": "9110e90dd69437e9ccf117212bde2eb7"
        }
    },
    {
        "id": "ERC1155Pausable_should_bb03a4e4",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Pausable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\nimport \"../../../security/Pausable.sol\";\n\nabstract contract ERC1155Pausable is ERC1155, Pausable {\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n}\n",
        "formal_property": "/// This rule should always fail.\nrule sanity {\n    method f; env e; calldataarg args;\n\n    f(e, args);\n    assert false, \n        \"This rule should always fail\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "should",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 107,
            "end_line": 115,
            "block_hash": "bb03a4e48c1f9486dc9b4d80b3a50387"
        }
    },
    {
        "id": "AccessControl_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "AccessControl.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "supportsInterface",
                "hasRole",
                "_checkRole",
                "getRoleAdmin",
                "grantRole",
                "revokeRole",
                "renounceRole",
                "_setupRole",
                "_setRoleAdmin",
                "_grantRole",
                "_revokeRole"
            ],
            "state_variables": [
                "_roles",
                "members",
                "adminRole"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "AccessControl_onlyRoleModifierCheckGrant_8232504e",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "AccessControl.sol",
        "target_function": "_checkRole/getRoleAdmin/grantRole",
        "text_chunk": "    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n",
        "formal_property": "rule onlyRoleModifierCheckGrant(env e){\n    bytes32 role; address account;\n\n    _checkRole@withrevert(e, getRoleAdmin(role));\n    bool checkRevert = lastReverted;\n    grantRole@withrevert(e, role, account);\n    bool grantRevert = lastReverted;\n    assert checkRevert => grantRevert, \"modifier goes bananas\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "onlyRoleModifierCheckGrant",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "grantRole",
                "_checkRole",
                "getRoleAdmin"
            ],
            "start_line": 15,
            "end_line": 25,
            "block_hash": "8232504e5c1ce2f3073a01b0a236dacf"
        }
    },
    {
        "id": "AccessControl_onlyRoleModifierCheckRevoke_e572ecc0",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "AccessControl.sol",
        "target_function": "_checkRole/getRoleAdmin/revokeRole",
        "text_chunk": "    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n",
        "formal_property": "rule onlyRoleModifierCheckRevoke(env e){\n    bytes32 role; address account;\n\n    _checkRole@withrevert(e, getRoleAdmin(role));\n    bool checkRevert = lastReverted;\n    revokeRole@withrevert(e, role, account);\n    bool revokeRevert = lastReverted;\n    assert checkRevert => revokeRevert, \"modifier goes bananas\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "onlyRoleModifierCheckRevoke",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "revokeRole",
                "_checkRole",
                "getRoleAdmin"
            ],
            "start_line": 30,
            "end_line": 40,
            "block_hash": "e572ecc0490748a062af664bc4d17d71"
        }
    },
    {
        "id": "AccessControl_grantRoleEffect_83e15d77",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "AccessControl.sol",
        "target_function": "grantRole/hasRole",
        "text_chunk": "    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n",
        "formal_property": "rule grantRoleEffect(env e){\n    bytes32 role; address account; \n    bytes32 anotherRole; address nonEffectedAcc;\n    require account != nonEffectedAcc;\n\n    bool hasRoleBefore = hasRole(anotherRole, nonEffectedAcc);\n    grantRole(e, role, account);\n    bool hasRoleAfter = hasRole(anotherRole, nonEffectedAcc);\n    assert hasRoleBefore == hasRoleAfter, \"modifier goes bananas\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "grantRoleEffect",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "grantRole",
                "hasRole"
            ],
            "start_line": 45,
            "end_line": 57,
            "block_hash": "83e15d775796166e9d8d04c38f460241"
        }
    },
    {
        "id": "AccessControl_revokeRoleEffect_382b0739",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "AccessControl.sol",
        "target_function": "hasRole/revokeRole",
        "text_chunk": "    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n",
        "formal_property": "rule revokeRoleEffect(env e){\n    bytes32 role; address account; \n    bytes32 anotherRole; address nonEffectedAcc;\n    require account != nonEffectedAcc;\n\n    bool hasRoleBefore = hasRole(anotherRole, nonEffectedAcc);\n    revokeRole(e, role, account);\n    bool hasRoleAfter = hasRole(anotherRole, nonEffectedAcc);\n    assert hasRoleBefore == hasRoleAfter, \"modifier goes bananas\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "revokeRoleEffect",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "revokeRole",
                "hasRole"
            ],
            "start_line": 62,
            "end_line": 74,
            "block_hash": "382b073948f6f3998d1f49f1ffca4561"
        }
    },
    {
        "id": "Governance_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "Governance.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/utils/Address.sol\";\n\nimport \"./interfaces/IGovernance.sol\";\nimport \"./Proposals.sol\";\nimport \"../common/interfaces/IAccounts.sol\";\nimport \"../common/ExtractFunctionSignature.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/linkedlists/IntegerSortedLinkedList.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/UsingPrecompiles.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\n/**\n * @title A contract for making, passing, and executing on-chain governance proposals.\n */\ncontract Governance is\n  IGovernance,\n  ICeloVersionedContract,\n  Ownable,\n  Initializable,\n  ReentrancyGuard,\n  UsingRegistry,\n  UsingPrecompiles\n{\n  using Proposals for Proposals.Proposal;\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n  using IntegerSortedLinkedList for SortedLinkedList.List;\n  using BytesLib for bytes;\n  using Address for address payable; // prettier-ignore\n\n  uint256 private constant FIXED_HALF = 500000000000000000000000;\n\n  enum VoteValue { None, Abstain, No, Yes }\n\n  struct UpvoteRecord {\n    uint256 proposalId;\n    uint256 weight;\n  }\n\n  struct VoteRecord {\n    Proposals.VoteValue deprecated_value; // obsolete\n    uint256 proposalId;\n    uint256 deprecated_weight; // obsolete\n    uint256 yesVotes;\n    uint256 noVotes;\n    uint256 abstainVotes;\n  }\n\n  struct Voter {\n    // Key of the proposal voted for in the proposal queue\n    UpvoteRecord upvote;\n    uint256 mostRecentReferendumProposal;\n    // Maps a `dequeued` index to a voter's vote record.\n    mapping(uint256 => VoteRecord) referendumVotes;\n  }\n\n  struct ContractConstitution {\n    FixidityLib.Fraction defaultThreshold;\n    // Maps a function ID to a corresponding threshold, overriding the default.\n    mapping(bytes4 => FixidityLib.Fraction) functionThresholds;\n  }\n\n  struct HotfixRecord {\n    bool executed;\n    bool approved;\n    uint256 preparedEpoch;\n    mapping(address => bool) whitelisted;\n  }\n\n  // The baseline is updated as\n  // max{floor, (1 - baselineUpdateFactor) * baseline + baselineUpdateFactor * participation}\n  struct ParticipationParameters {\n    // The average network participation in governance, weighted toward recent proposals.\n    FixidityLib.Fraction baseline;\n    // The lower bound on the participation baseline.\n    FixidityLib.Fraction baselineFloor;\n    // The weight of the most recent proposal's participation on the baseline.\n    FixidityLib.Fraction baselineUpdateFactor;\n    // The proportion of the baseline that constitutes quorum.\n    FixidityLib.Fraction baselineQuorumFactor;\n  }\n\n  Proposals.StageDurations public stageDurations;\n  uint256 public queueExpiry;\n  uint256 public dequeueFrequency;\n  address public approver;\n  uint256 public lastDequeue;\n  uint256 public concurrentProposals;\n  uint256 public proposalCount;\n  uint256 public minDeposit;\n  mapping(address => uint256) public refundedDeposits;\n  mapping(address => ContractConstitution) private constitution;\n  mapping(uint256 => Proposals.Proposal) private proposals;\n  mapping(address => Voter) internal voters;\n  mapping(bytes32 => HotfixRecord) public hotfixes;\n  SortedLinkedList.List private queue;\n  uint256[] public dequeued;\n  uint256[] public emptyIndices;\n  ParticipationParameters private participationParameters;\n\n  event ApproverSet(address indexed approver);\n\n  event ConcurrentProposalsSet(uint256 concurrentProposals);\n\n  event MinDepositSet(uint256 minDeposit);\n\n  event QueueExpirySet(uint256 queueExpiry);\n\n  event DequeueFrequencySet(uint256 dequeueFrequency);\n\n  event ReferendumStageDurationSet(uint256 referendumStageDuration);\n\n  event ExecutionStageDurationSet(uint256 executionStageDuration);\n\n  event ConstitutionSet(address indexed destination, bytes4 indexed functionId, uint256 threshold);\n\n  event ProposalQueued(\n    uint256 indexed proposalId,\n    address indexed proposer,\n    uint256 transactionCount,\n    uint256 deposit,\n    uint256 timestamp\n  );\n\n  event ProposalUpvoted(uint256 indexed proposalId, address indexed account, uint256 upvotes);\n\n  event ProposalUpvoteRevoked(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 revokedUpvotes\n  );\n\n  event ProposalDequeued(uint256 indexed proposalId, uint256 timestamp);\n\n  event ProposalApproved(uint256 indexed proposalId);\n\n  event ProposalVoted(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 value,\n    uint256 weight\n  );\n\n  event ProposalVotedV2(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 yesVotes,\n    uint256 noVotes,\n    uint256 abstainVotes\n  );\n\n  event ProposalVoteRevoked(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 value,\n    uint256 weight\n  );\n\n  event ProposalVoteRevokedV2(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 yesVotes,\n    uint256 noVotes,\n    uint256 abstainVotes\n  );\n\n  event ProposalExecuted(uint256 indexed proposalId);\n\n  event ProposalExpired(uint256 indexed proposalId);\n\n  event ParticipationBaselineUpdated(uint256 participationBaseline);\n\n  event ParticipationFloorSet(uint256 participationFloor);\n\n  event ParticipationBaselineUpdateFactorSet(uint256 baselineUpdateFactor);\n\n  event ParticipationBaselineQuorumFactorSet(uint256 baselineQuorumFactor);\n\n  event HotfixWhitelisted(bytes32 indexed hash, address whitelister);\n\n  event HotfixApproved(bytes32 indexed hash);\n\n  event HotfixPrepared(bytes32 indexed hash, uint256 indexed epoch);\n\n  event HotfixExecuted(bytes32 indexed hash);\n\n  modifier hotfixNotExecuted(bytes32 hash) {\n    require(!hotfixes[hash].executed, \"hotfix already executed\");\n    _;\n  }\n\n  modifier onlyApprover() {\n    require(msg.sender == approver, \"msg.sender not approver\");\n    _;\n  }\n\n  modifier onlyLockedGold() {\n    require(msg.sender == address(getLockedGold()), \"msg.sender not lockedGold\");\n    _;\n  }\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  function() external payable {\n    require(msg.data.length == 0, \"unknown method\");\n  }\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return Storage version of the contract.\n   * @return Major version of the contract.\n   * @return Minor version of the contract.\n   * @return Patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 4, 1, 0);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry contract.\n   * @param _approver The address that needs to approve proposals to move to the referendum stage.\n   * @param _concurrentProposals The number of proposals to dequeue at once.\n   * @param _minDeposit The minimum CELO deposit needed to make a proposal.\n   * @param _queueExpiry The number of seconds a proposal can stay in the queue before expiring.\n   * @param _dequeueFrequency The number of seconds before the next batch of proposals can be\n   *   dequeued.\n   * @param referendumStageDuration The number of seconds users have to vote on a dequeued proposal\n   *   after the approval stage ends.\n   * @param executionStageDuration The number of seconds users have to execute a passed proposal\n   *   after the referendum stage ends.\n   * @param participationBaseline The initial value of the participation baseline.\n   * @param participationFloor The participation floor.\n   * @param baselineUpdateFactor The weight of the new participation in the baseline update rule.\n   * @param baselineQuorumFactor The proportion of the baseline that constitutes quorum.\n   * @dev Should be called only once.\n   */\n  function initialize(\n    address registryAddress,\n    address _approver,\n    uint256 _concurrentProposals,\n    uint256 _minDeposit,\n    uint256 _queueExpiry,\n    uint256 _dequeueFrequency,\n    uint256 referendumStageDuration,\n    uint256 executionStageDuration,\n    uint256 participationBaseline,\n    uint256 participationFloor,\n    uint256 baselineUpdateFactor,\n    uint256 baselineQuorumFactor\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setApprover(_approver);\n    setConcurrentProposals(_concurrentProposals);\n    setMinDeposit(_minDeposit);\n    setQueueExpiry(_queueExpiry);\n    setDequeueFrequency(_dequeueFrequency);\n    setReferendumStageDuration(referendumStageDuration);\n    setExecutionStageDuration(executionStageDuration);\n    setParticipationBaseline(participationBaseline);\n    setParticipationFloor(participationFloor);\n    setBaselineUpdateFactor(baselineUpdateFactor);\n    setBaselineQuorumFactor(baselineQuorumFactor);\n    // solhint-disable-next-line not-rely-on-time\n    lastDequeue = now;\n  }\n\n  /**\n   * @notice Updates the address that has permission to approve proposals in the approval stage.\n   * @param _approver The address that has permission to approve proposals in the approval stage.\n   */\n  function setApprover(address _approver) public onlyOwner {\n    require(_approver != address(0), \"Approver cannot be 0\");\n    require(_approver != approver, \"Approver unchanged\");\n    approver = _approver;\n    emit ApproverSet(_approver);\n  }\n\n  /**\n   * @notice Updates the number of proposals to dequeue at a time.\n   * @param _concurrentProposals The number of proposals to dequeue at at a time.\n   */\n  function setConcurrentProposals(uint256 _concurrentProposals) public onlyOwner {\n    require(_concurrentProposals != 0, \"Number of proposals must be larger than zero\");\n    require(_concurrentProposals != concurrentProposals, \"Number of proposals unchanged\");\n    concurrentProposals = _concurrentProposals;\n    emit ConcurrentProposalsSet(_concurrentProposals);\n  }\n\n  /**\n   * @notice Updates the minimum deposit needed to make a proposal.\n   * @param _minDeposit The minimum CELO deposit needed to make a proposal.\n   */\n  function setMinDeposit(uint256 _minDeposit) public onlyOwner {\n    require(_minDeposit != 0, \"minDeposit must be larger than 0\");\n    require(_minDeposit != minDeposit, \"Minimum deposit unchanged\");\n    minDeposit = _minDeposit;\n    emit MinDepositSet(_minDeposit);\n  }\n\n  /**\n   * @notice Updates the number of seconds before a queued proposal expires.\n   * @param _queueExpiry The number of seconds a proposal can stay in the queue before expiring.\n   */\n  function setQueueExpiry(uint256 _queueExpiry) public onlyOwner {\n    require(_queueExpiry != 0, \"QueueExpiry must be larger than 0\");\n    require(_queueExpiry != queueExpiry, \"QueueExpiry unchanged\");\n    queueExpiry = _queueExpiry;\n    emit QueueExpirySet(_queueExpiry);\n  }\n\n  /**\n   * @notice Updates the minimum number of seconds before the next batch of proposals can be\n   *   dequeued.\n   * @param _dequeueFrequency The number of seconds before the next batch of proposals can be\n   *   dequeued.\n   */\n  function setDequeueFrequency(uint256 _dequeueFrequency) public onlyOwner {\n    require(_dequeueFrequency != 0, \"dequeueFrequency must be larger than 0\");\n    require(_dequeueFrequency != dequeueFrequency, \"dequeueFrequency unchanged\");\n    dequeueFrequency = _dequeueFrequency;\n    emit DequeueFrequencySet(_dequeueFrequency);\n  }\n\n  /**\n   * @notice Updates the number of seconds proposals stay in the referendum stage.\n   * @param referendumStageDuration The number of seconds proposals stay in the referendum stage.\n   */\n  function setReferendumStageDuration(uint256 referendumStageDuration) public onlyOwner {\n    require(referendumStageDuration != 0, \"Duration must be larger than 0\");\n    require(referendumStageDuration != stageDurations.referendum, \"Duration unchanged\");\n    stageDurations.referendum = referendumStageDuration;\n    emit ReferendumStageDurationSet(referendumStageDuration);\n  }\n\n  /**\n   * @notice Updates the number of seconds proposals stay in the execution stage.\n   * @param executionStageDuration The number of seconds proposals stay in the execution stage.\n   */\n  function setExecutionStageDuration(uint256 executionStageDuration) public onlyOwner {\n    require(executionStageDuration != 0, \"Duration must be larger than 0\");\n    require(executionStageDuration != stageDurations.execution, \"Duration unchanged\");\n    stageDurations.execution = executionStageDuration;\n    emit ExecutionStageDurationSet(executionStageDuration);\n  }\n\n  /**\n   * @notice Updates the participation baseline.\n   * @param participationBaseline The value of the baseline.\n   */\n  function setParticipationBaseline(uint256 participationBaseline) public onlyOwner {\n    FixidityLib.Fraction memory participationBaselineFrac = FixidityLib.wrap(participationBaseline);\n    require(\n      FixidityLib.isProperFraction(participationBaselineFrac),\n      \"Participation baseline greater than one\"\n    );\n    require(\n      !participationBaselineFrac.equals(participationParameters.baseline),\n      \"Participation baseline unchanged\"\n    );\n    participationParameters.baseline = participationBaselineFrac;\n    emit ParticipationBaselineUpdated(participationBaseline);\n  }\n\n  /**\n   * @notice Updates the floor of the participation baseline.\n   * @param participationFloor The value at which the baseline is floored.\n   */\n  function setParticipationFloor(uint256 participationFloor) public onlyOwner {\n    FixidityLib.Fraction memory participationFloorFrac = FixidityLib.wrap(participationFloor);\n    require(\n      FixidityLib.isProperFraction(participationFloorFrac),\n      \"Participation floor greater than one\"\n    );\n    require(\n      !participationFloorFrac.equals(participationParameters.baselineFloor),\n      \"Participation baseline floor unchanged\"\n    );\n    participationParameters.baselineFloor = participationFloorFrac;\n    emit ParticipationFloorSet(participationFloor);\n  }\n\n  /**\n   * @notice Updates the weight of the new participation in the baseline update rule.\n   * @param baselineUpdateFactor The new baseline update factor.\n   */\n  function setBaselineUpdateFactor(uint256 baselineUpdateFactor) public onlyOwner {\n    FixidityLib.Fraction memory baselineUpdateFactorFrac = FixidityLib.wrap(baselineUpdateFactor);\n    require(\n      FixidityLib.isProperFraction(baselineUpdateFactorFrac),\n      \"Baseline update factor greater than one\"\n    );\n    require(\n      !baselineUpdateFactorFrac.equals(participationParameters.baselineUpdateFactor),\n      \"Baseline update factor unchanged\"\n    );\n    participationParameters.baselineUpdateFactor = baselineUpdateFactorFrac;\n    emit ParticipationBaselineUpdateFactorSet(baselineUpdateFactor);\n  }\n\n  /**\n   * @notice Updates the proportion of the baseline that constitutes quorum.\n   * @param baselineQuorumFactor The new baseline quorum factor.\n   */\n  function setBaselineQuorumFactor(uint256 baselineQuorumFactor) public onlyOwner {\n    FixidityLib.Fraction memory baselineQuorumFactorFrac = FixidityLib.wrap(baselineQuorumFactor);\n    require(\n      FixidityLib.isProperFraction(baselineQuorumFactorFrac),\n      \"Baseline quorum factor greater than one\"\n    );\n    require(\n      !baselineQuorumFactorFrac.equals(participationParameters.baselineQuorumFactor),\n      \"Baseline quorum factor unchanged\"\n    );\n    participationParameters.baselineQuorumFactor = baselineQuorumFactorFrac;\n    emit ParticipationBaselineQuorumFactorSet(baselineQuorumFactor);\n  }\n\n  /**\n   * @notice Updates the ratio of yes:yes+no votes needed for a specific class of proposals to pass.\n   * @param destination The destination of proposals for which this threshold should apply.\n   * @param functionId The function ID of proposals for which this threshold should apply. Zero\n   *   will set the default.\n   * @param threshold The threshold.\n   * @dev If no constitution is explicitly set the default is a simple majority, i.e. 1:2.\n   */\n  function setConstitution(address destination, bytes4 functionId, uint256 threshold)\n    external\n    onlyOwner\n  {\n    require(destination != address(0), \"Destination cannot be zero\");\n    require(\n      threshold > FIXED_HALF && threshold <= FixidityLib.fixed1().unwrap(),\n      \"Threshold has to be greater than majority and not greater than unanimity\"\n    );\n    if (functionId == 0) {\n      constitution[destination].defaultThreshold = FixidityLib.wrap(threshold);\n    } else {\n      constitution[destination].functionThresholds[functionId] = FixidityLib.wrap(threshold);\n    }\n    emit ConstitutionSet(destination, functionId, threshold);\n  }\n\n  /**\n   * @notice Creates a new proposal and adds it to end of the queue with no upvotes.\n   * @param values The values of CELO to be sent in the proposed transactions.\n   * @param destinations The destination addresses of the proposed transactions.\n   * @param data The concatenated data to be included in the proposed transactions.\n   * @param dataLengths The lengths of each transaction's data.\n   * @return The ID of the newly proposed proposal.\n   * @dev The minimum deposit must be included with the proposal, returned if/when the proposal is\n   *   dequeued.\n   */\n  function propose(\n    uint256[] calldata values,\n    address[] calldata destinations,\n    bytes calldata data,\n    uint256[] calldata dataLengths,\n    string calldata descriptionUrl\n  ) external payable returns (uint256) {\n    dequeueProposalsIfReady();\n    require(msg.value >= minDeposit, \"Too small deposit\");\n\n    proposalCount = proposalCount.add(1);\n    Proposals.Proposal storage proposal = proposals[proposalCount];\n    proposal.make(values, destinations, data, dataLengths, msg.sender, msg.value);\n    proposal.setDescriptionUrl(descriptionUrl);\n    queue.push(proposalCount);\n    // solhint-disable-next-line not-rely-on-time\n    emit ProposalQueued(proposalCount, msg.sender, proposal.transactions.length, msg.value, now);\n    return proposalCount;\n  }\n\n  /**\n   * @notice Removes a proposal if it is queued and expired.\n   * @param proposalId The ID of the proposal to remove.\n   * @return Whether the proposal was removed.\n   */\n  function removeIfQueuedAndExpired(uint256 proposalId) private returns (bool) {\n    if (isQueued(proposalId) && isQueuedProposalExpired(proposalId)) {\n      queue.remove(proposalId);\n      emit ProposalExpired(proposalId);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @notice Requires a proposal is dequeued and removes it if expired.\n   * @param proposalId The ID of the proposal.\n   * @return The proposal storage struct corresponding to `proposalId`.\n   * @return The proposal stage corresponding to `proposalId`.\n   */\n  function requireDequeuedAndDeleteExpired(uint256 proposalId, uint256 index)\n    private\n    returns (Proposals.Proposal storage, Proposals.Stage)\n  {\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    require(_isDequeuedProposal(proposal, proposalId, index), \"Proposal not dequeued\");\n    Proposals.Stage stage = getProposalDequeuedStage(proposal);\n    if (_isDequeuedProposalExpired(proposal, stage)) {\n      deleteDequeuedProposal(proposal, proposalId, index);\n      return (proposal, Proposals.Stage.Expiration);\n    }\n    return (proposal, stage);\n  }\n\n  /**\n   * @notice Upvotes a queued proposal.\n   * @param proposalId The ID of the proposal to upvote.\n   * @param lesser The ID of the proposal that will be just behind `proposalId` in the queue.\n   * @param greater The ID of the proposal that will be just ahead `proposalId` in the queue.\n   * @return Whether or not the upvote was made successfully.\n   * @dev Provide 0 for `lesser`/`greater` when the proposal will be at the tail/head of the queue.\n   * @dev Reverts if the account has already upvoted a proposal in the queue.\n   */\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n  /**\n   * @notice Returns stage of governance process given proposal is in\n   * @param proposalId The ID of the proposal to query.\n   * @return proposal stage\n   */\n  function getProposalStage(uint256 proposalId) external view returns (Proposals.Stage) {\n    if (proposalId == 0 || proposalId > proposalCount) {\n      return Proposals.Stage.None;\n    }\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    if (isQueued(proposalId)) {\n      return\n        _isQueuedProposalExpired(proposal) ? Proposals.Stage.Expiration : Proposals.Stage.Queued;\n    } else {\n      Proposals.Stage stage = getProposalDequeuedStage(proposal);\n      return _isDequeuedProposalExpired(proposal, stage) ? Proposals.Stage.Expiration : stage;\n    }\n  }\n\n  /**\n   * @notice Revokes an upvote on a queued proposal.\n   * @param lesser The ID of the proposal that will be just behind the previously upvoted proposal\n   *   in the queue.\n   * @param greater The ID of the proposal that will be just ahead of the previously upvoted\n   *   proposal in the queue.\n   * @return Whether or not the upvote was revoked successfully.\n   * @dev Provide 0 for `lesser`/`greater` when the proposal will be at the tail/head of the queue.\n   */\n  function revokeUpvote(uint256 lesser, uint256 greater) external nonReentrant returns (bool) {\n    dequeueProposalsIfReady();\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    uint256 proposalId = voter.upvote.proposalId;\n    require(proposalId != 0, \"Account has no historical upvote\");\n    removeIfQueuedAndExpired(proposalId);\n    if (queue.contains(proposalId)) {\n      queue.update(\n        proposalId,\n        queue.getValue(proposalId).sub(voter.upvote.weight),\n        lesser,\n        greater\n      );\n      emit ProposalUpvoteRevoked(proposalId, account, voter.upvote.weight);\n    }\n    voter.upvote = UpvoteRecord(0, 0);\n    return true;\n  }\n\n  /**\n   * @notice Approves a proposal in the approval stage.\n   * @param proposalId The ID of the proposal to approve.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @return Whether or not the approval was made successfully.\n   */\n  function approve(uint256 proposalId, uint256 index) external onlyApprover returns (bool) {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(!proposal.isApproved(), \"Proposal already approved\");\n    require(\n      stage == Proposals.Stage.Referendum || stage == Proposals.Stage.Execution,\n      \"Proposal not in correct stage\"\n    );\n    proposal.approved = true;\n    // Ensures networkWeight is set by the end of the Referendum stage, even if 0 votes are cast.\n    proposal.networkWeight = getLockedGold().getTotalLockedGold();\n    emit ProposalApproved(proposalId);\n    return true;\n  }\n\n  /**\n   * @notice Votes on a proposal in the referendum stage.\n   * @param proposalId The ID of the proposal to vote on.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @param value Whether to vote yes, no, or abstain.\n   * @return Whether or not the vote was cast successfully.\n   */\n  /* solhint-disable code-complexity */\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n\n  /**\n   * @notice Votes partially on a proposal in the referendum stage.\n   * @param proposalId The ID of the proposal to vote on.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @param yesVotes The yes votes weight.\n   * @param noVotes The no votes weight.\n   * @param abstainVotes The abstain votes weight.\n   * @return Whether or not the vote was cast successfully.\n   */\n  /* solhint-disable code-complexity */\n  function votePartially(\n    uint256 proposalId,\n    uint256 index,\n    uint256 yesVotes,\n    uint256 noVotes,\n    uint256 abstainVotes\n  ) external nonReentrant returns (bool) {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 totalVotingPower = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n\n    require(\n      totalVotingPower >= yesVotes.add(noVotes).add(abstainVotes),\n      \"Voter doesn't have enough locked Celo (formerly known as Celo Gold)\"\n    );\n    _vote(proposal, proposalId, index, account, yesVotes, noVotes, abstainVotes);\n\n    return true;\n  }\n\n  /**\n   * @notice Votes on a proposal in the referendum stage.\n   * @param proposal The proposal struct.\n   * @param proposalId The ID of the proposal to vote on.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @param account Account based on signer.\n   * @param yesVotes The yes votes weight.\n   * @param noVotes The no votes weight.\n   * @param abstainVotes The abstain votes weight.\n   * @return Whether or not the proposal is passing.\n   */\n  function _vote(\n    Proposals.Proposal storage proposal,\n    uint256 proposalId,\n    uint256 index,\n    address account,\n    uint256 yesVotes,\n    uint256 noVotes,\n    uint256 abstainVotes\n  ) private {\n    Voter storage voter = voters[account];\n\n    VoteRecord storage previousVoteRecord = voter.referendumVotes[index];\n\n    if (previousVoteRecord.proposalId != proposalId) {\n      // VoteRecord is being stored based on index (in `dequeued`) rather than proposalId.\n      // It can happen that user voted on proposal that later gets deleted.\n      // VoteRecord will still stay in `referendumVotes` mapping.\n      // Once new proposal is created it might get same index as previous proposal.\n      // In such case we need to check whether existing VoteRecord is relevant to new\n      // proposal of whether it is just left over data.\n      proposal.updateVote(0, 0, 0, yesVotes, noVotes, abstainVotes);\n    } else if (previousVoteRecord.deprecated_weight != 0) {\n      // backward compatibility for transition period - this should be deleted later on\n      proposal.updateVote(\n        previousVoteRecord.deprecated_value == Proposals.VoteValue.Yes\n          ? previousVoteRecord.deprecated_weight\n          : 0,\n        previousVoteRecord.deprecated_value == Proposals.VoteValue.No\n          ? previousVoteRecord.deprecated_weight\n          : 0,\n        previousVoteRecord.deprecated_value == Proposals.VoteValue.Abstain\n          ? previousVoteRecord.deprecated_weight\n          : 0,\n        yesVotes,\n        noVotes,\n        abstainVotes\n      );\n    } else {\n      proposal.updateVote(\n        previousVoteRecord.yesVotes,\n        previousVoteRecord.noVotes,\n        previousVoteRecord.abstainVotes,\n        yesVotes,\n        noVotes,\n        abstainVotes\n      );\n    }\n\n    proposal.networkWeight = getLockedGold().getTotalLockedGold();\n    voter.referendumVotes[index] = VoteRecord(\n      Proposals.VoteValue.None,\n      proposalId,\n      0,\n      yesVotes,\n      noVotes,\n      abstainVotes\n    );\n    if (proposal.timestamp > proposals[voter.mostRecentReferendumProposal].timestamp) {\n      voter.mostRecentReferendumProposal = proposalId;\n    }\n\n    emit ProposalVotedV2(proposalId, account, yesVotes, noVotes, abstainVotes);\n  }\n\n  /* solhint-enable code-complexity */\n\n  /**\n   * @notice Revoke votes on all proposals of sender in the referendum stage.\n   * @return Whether or not all votes of an account were successfully revoked.\n   */\n  function revokeVotes() external nonReentrant returns (bool) {\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    for (\n      uint256 dequeueIndex = 0;\n      dequeueIndex < dequeued.length;\n      dequeueIndex = dequeueIndex.add(1)\n    ) {\n      VoteRecord storage voteRecord = voter.referendumVotes[dequeueIndex];\n\n      // Skip proposals where there was no vote cast by the user AND\n      // ensure vote record proposal matches identifier of dequeued index proposal.\n      if (\n        voteRecord.proposalId == dequeued[dequeueIndex] &&\n        (voteRecord.yesVotes != 0 ||\n          voteRecord.noVotes != 0 ||\n          voteRecord.abstainVotes != 0 ||\n          voteRecord.deprecated_weight != 0)\n      ) {\n        (Proposals.Proposal storage proposal, Proposals.Stage stage) =\n          requireDequeuedAndDeleteExpired(voteRecord.proposalId, dequeueIndex); // prettier-ignore\n\n        // only revoke from proposals which are still in referendum\n        if (stage == Proposals.Stage.Referendum) {\n          if (voteRecord.deprecated_weight != 0) {\n            // backward compatibility for transition period - this should be deleted later on\n            uint256 previousYes = voteRecord.deprecated_value == Proposals.VoteValue.Yes\n              ? voteRecord.deprecated_weight\n              : 0;\n            uint256 previousNo = voteRecord.deprecated_value == Proposals.VoteValue.No\n              ? voteRecord.deprecated_weight\n              : 0;\n            uint256 previousAbstain = voteRecord.deprecated_value == Proposals.VoteValue.Abstain\n              ? voteRecord.deprecated_weight\n              : 0;\n            proposal.updateVote(previousYes, previousNo, previousAbstain, 0, 0, 0);\n\n            proposal.networkWeight = getLockedGold().getTotalLockedGold();\n            emit ProposalVoteRevokedV2(\n              voteRecord.proposalId,\n              account,\n              previousYes,\n              previousNo,\n              previousAbstain\n            );\n          } else {\n            proposal.updateVote(\n              voteRecord.yesVotes,\n              voteRecord.noVotes,\n              voteRecord.abstainVotes,\n              0,\n              0,\n              0\n            );\n            proposal.networkWeight = getLockedGold().getTotalLockedGold();\n            emit ProposalVoteRevokedV2(\n              voteRecord.proposalId,\n              account,\n              voteRecord.yesVotes,\n              voteRecord.noVotes,\n              voteRecord.abstainVotes\n            );\n          }\n        }\n\n        // always delete dequeue vote records for gas refund as they must be expired or revoked\n        delete voter.referendumVotes[dequeueIndex];\n      }\n    }\n\n    // reset most recent referendum proposal ID to guarantee isVotingReferendum == false\n    voter.mostRecentReferendumProposal = 0;\n    return true;\n  }\n\n  /**\n   * @notice Executes a proposal in the execution stage, removing it from `dequeued`.\n   * @param proposalId The ID of the proposal to vote on.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @return Whether or not the proposal was executed successfully.\n   * @dev Does not remove the proposal if the execution fails.\n   */\n  function execute(uint256 proposalId, uint256 index) external nonReentrant returns (bool) {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    bool notExpired = proposal.exists();\n    if (notExpired) {\n      require(proposal.isApproved(), \"Proposal not approved\");\n      require(\n        stage == Proposals.Stage.Execution && _isProposalPassing(proposal),\n        \"Proposal not in execution stage or not passing\"\n      );\n      proposal.execute();\n      emit ProposalExecuted(proposalId);\n      deleteDequeuedProposal(proposal, proposalId, index);\n    }\n    return notExpired;\n  }\n\n  /**\n   * @notice Approves the hash of a hotfix transaction(s).\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction(s) to be approved.\n   */\n  function approveHotfix(bytes32 hash) external hotfixNotExecuted(hash) onlyApprover {\n    hotfixes[hash].approved = true;\n    emit HotfixApproved(hash);\n  }\n\n  /**\n   * @notice Returns whether given hotfix hash has been whitelisted by given address.\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction(s) to be whitelisted.\n   * @param whitelister Address to check whitelist status of.\n   */\n  function isHotfixWhitelistedBy(bytes32 hash, address whitelister) public view returns (bool) {\n    return hotfixes[hash].whitelisted[whitelister];\n  }\n\n  /**\n   * @notice Whitelists the hash of a hotfix transaction(s).\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction(s) to be whitelisted.\n   */\n  function whitelistHotfix(bytes32 hash) external hotfixNotExecuted(hash) {\n    hotfixes[hash].whitelisted[msg.sender] = true;\n    emit HotfixWhitelisted(hash, msg.sender);\n  }\n\n  /**\n   * @notice Gives hotfix a prepared epoch for execution.\n   * @param hash The hash of the hotfix to be prepared.\n   */\n  function prepareHotfix(bytes32 hash) external hotfixNotExecuted(hash) {\n    require(isHotfixPassing(hash), \"hotfix not whitelisted by 2f+1 validators\");\n    uint256 epoch = getEpochNumber();\n    require(hotfixes[hash].preparedEpoch < epoch, \"hotfix already prepared for this epoch\");\n    hotfixes[hash].preparedEpoch = epoch;\n    emit HotfixPrepared(hash, epoch);\n  }\n\n  /**\n   * @notice Executes a whitelisted proposal.\n   * @param values The values of CELO to be sent in the proposed transactions.\n   * @param destinations The destination addresses of the proposed transactions.\n   * @param data The concatenated data to be included in the proposed transactions.\n   * @param dataLengths The lengths of each transaction's data.\n   * @param salt Arbitrary salt associated with hotfix which guarantees uniqueness of hash.\n   * @dev Reverts if hotfix is already executed, not approved, or not prepared for current epoch.\n   */\n  function executeHotfix(\n    uint256[] calldata values,\n    address[] calldata destinations,\n    bytes calldata data,\n    uint256[] calldata dataLengths,\n    bytes32 salt\n  ) external {\n    bytes32 hash = keccak256(abi.encode(values, destinations, data, dataLengths, salt));\n\n    (bool approved, bool executed, uint256 preparedEpoch) = getHotfixRecord(hash);\n    require(!executed, \"hotfix already executed\");\n    require(approved, \"hotfix not approved\");\n    require(preparedEpoch == getEpochNumber(), \"hotfix must be prepared for this epoch\");\n\n    Proposals.makeMem(values, destinations, data, dataLengths, msg.sender, 0).executeMem();\n\n    hotfixes[hash].executed = true;\n    emit HotfixExecuted(hash);\n  }\n\n  /**\n   * @notice Withdraws refunded CELO deposits.\n   * @return Whether or not the withdraw was successful.\n   */\n  function withdraw() external nonReentrant returns (bool) {\n    uint256 value = refundedDeposits[msg.sender];\n    require(value != 0, \"Nothing to withdraw\");\n    require(value <= address(this).balance, \"Inconsistent balance\");\n    refundedDeposits[msg.sender] = 0;\n    msg.sender.sendValue(value);\n    return true;\n  }\n\n  /**\n   * @notice Returns whether or not a particular account is voting on proposals.\n   * @param account The address of the account.\n   * @return Whether or not the account is voting on proposals.\n   */\n  function isVoting(address account) external view returns (bool) {\n    Voter storage voter = voters[account];\n    uint256 upvotedProposal = voter.upvote.proposalId;\n    bool isVotingQueue = upvotedProposal != 0 &&\n      isQueued(upvotedProposal) &&\n      !isQueuedProposalExpired(upvotedProposal);\n    Proposals.Proposal storage proposal = proposals[voter.mostRecentReferendumProposal];\n    bool isVotingReferendum = (getProposalDequeuedStage(proposal) == Proposals.Stage.Referendum);\n    return isVotingQueue || isVotingReferendum;\n  }\n\n  /**\n   * @notice Returns the number of seconds proposals stay in the referendum stage.\n   * @return The number of seconds proposals stay in the referendum stage.\n   */\n  function getReferendumStageDuration() external view returns (uint256) {\n    return stageDurations.referendum;\n  }\n\n  /**\n   * @notice Returns the number of seconds proposals stay in the execution stage.\n   * @return The number of seconds proposals stay in the execution stage.\n   */\n  function getExecutionStageDuration() external view returns (uint256) {\n    return stageDurations.execution;\n  }\n\n  /**\n   * @notice Returns the participation parameters.\n   * @return baseline The participation baseline parameter.\n   * @return baselineFloor The participation baseline floor parameter.\n   * @return baselineUpdateFactor The participation baseline update factor parameter.\n   * @return baselineQuorumFactor The participation baseline quorum factor parameter.\n   */\n  function getParticipationParameters() external view returns (uint256, uint256, uint256, uint256) {\n    return (\n      participationParameters.baseline.unwrap(),\n      participationParameters.baselineFloor.unwrap(),\n      participationParameters.baselineUpdateFactor.unwrap(),\n      participationParameters.baselineQuorumFactor.unwrap()\n    );\n  }\n\n  /**\n   * @notice Returns whether or not a proposal exists.\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the proposal exists.\n   */\n  function proposalExists(uint256 proposalId) external view returns (bool) {\n    return proposals[proposalId].exists();\n  }\n\n  /**\n   * @notice Returns an unpacked proposal struct with its transaction count.\n   * @param proposalId The ID of the proposal to unpack.\n   * @return proposer\n   * @return deposit\n   * @return timestamp\n   * @return transaction Transaction count.\n   * @return description Description url.\n   */\n  function getProposal(uint256 proposalId)\n    external\n    view\n    returns (address, uint256, uint256, uint256, string memory, uint256, bool)\n  {\n    return proposals[proposalId].unpack();\n  }\n\n  /**\n   * @notice Returns a specified transaction in a proposal.\n   * @param proposalId The ID of the proposal to query.\n   * @param index The index of the specified transaction in the proposal's transaction list.\n   * @return value Transaction value.\n   * @return destination Transaction destination.\n   * @return data Transaction data.\n   */\n  function getProposalTransaction(uint256 proposalId, uint256 index)\n    external\n    view\n    returns (uint256, address, bytes memory)\n  {\n    return proposals[proposalId].getTransaction(index);\n  }\n\n  /**\n   * @notice Returns whether or not a proposal has been approved.\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the proposal has been approved.\n   */\n  function isApproved(uint256 proposalId) external view returns (bool) {\n    return proposals[proposalId].isApproved();\n  }\n\n  /**\n   * @notice Returns the referendum vote totals for a proposal.\n   * @param proposalId The ID of the proposal.\n   * @return yes The yes vote totals.\n   * @return no The no vote totals.\n   * @return abstain The abstain vote totals.\n   */\n  function getVoteTotals(uint256 proposalId) external view returns (uint256, uint256, uint256) {\n    return proposals[proposalId].getVoteTotals();\n  }\n\n  /**\n   * @notice Returns an accounts vote record on a particular index in `dequeued`.\n   * @param account The address of the account to get the record for.\n   * @param index The index in `dequeued`.\n   * @return The corresponding proposal ID, vote value, and weight.\n   * @return The depreciated vote value.\n   * @return The deprecieated weight.\n   * @return The yes weight.\n   * @return The no weight.\n   * @return The abstain weight.\n   */\n  function getVoteRecord(address account, uint256 index)\n    external\n    view\n    returns (uint256, uint256, uint256, uint256, uint256, uint256)\n  {\n    VoteRecord storage record = voters[account].referendumVotes[index];\n    return (\n      record.proposalId,\n      uint256(record.deprecated_value),\n      record.deprecated_weight,\n      record.yesVotes,\n      record.noVotes,\n      record.abstainVotes\n    );\n  }\n\n  /**\n   * @notice Returns the number of proposals in the queue.\n   * @return The number of proposals in the queue.\n   */\n  function getQueueLength() external view returns (uint256) {\n    return queue.list.numElements;\n  }\n\n  /**\n   * @notice Returns the number of upvotes the queued proposal has received.\n   * @param proposalId The ID of the proposal.\n   * @return The number of upvotes a queued proposal has received.\n   */\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n  /**\n   * @notice Returns the proposal ID and upvote total for all queued proposals.\n   * @return proposalID The proposal ID for all queued proposals.\n   * @return total The upvote total for all queued proposals.\n   * @dev Note that this includes expired proposals that have yet to be removed from the queue.\n   */\n  function getQueue() external view returns (uint256[] memory, uint256[] memory) {\n    return queue.getElements();\n  }\n\n  /**\n   * @notice Returns the dequeued proposal IDs.\n   * @return The dequeued proposal IDs.\n   * @dev Note that this includes unused indices with proposalId == 0 from deleted proposals.\n   */\n  function getDequeue() external view returns (uint256[] memory) {\n    return dequeued;\n  }\n\n  /**\n   * @notice Returns the ID of the proposal upvoted by `account` and the weight of that upvote.\n   * @param account The address of the account.\n   * @return The ID of the proposal upvoted by `account`.\n   * @return The weight of that upvote.\n   */\n  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n  /**\n   * @notice Returns the ID of the most recently dequeued proposal voted on by `account`.\n   * @param account The address of the account.\n   * @return The ID of the most recently dequeued proposal voted on by `account`..\n   */\n  function getMostRecentReferendumProposal(address account) external view returns (uint256) {\n    return voters[account].mostRecentReferendumProposal;\n  }\n\n  /**\n   * @notice Returns number of validators from current set which have whitelisted the given hotfix.\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction.\n   * @return Whitelist tally\n   */\n  function hotfixWhitelistValidatorTally(bytes32 hash) public view returns (uint256) {\n    uint256 tally = 0;\n    uint256 n = numberValidatorsInCurrentSet();\n    IAccounts accounts = getAccounts();\n    for (uint256 i = 0; i < n; i = i.add(1)) {\n      address validatorSigner = validatorSignerAddressFromCurrentSet(i);\n      address validatorAccount = accounts.signerToAccount(validatorSigner);\n      if (\n        isHotfixWhitelistedBy(hash, validatorSigner) ||\n        isHotfixWhitelistedBy(hash, validatorAccount)\n      ) {\n        tally = tally.add(1);\n      }\n    }\n    return tally;\n  }\n\n  /**\n   * @notice Checks if a byzantine quorum of validators has whitelisted the given hotfix.\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction.\n   * @return Whether validator whitelist tally >= validator byzantine quorum\n   */\n  function isHotfixPassing(bytes32 hash) public view returns (bool) {\n    return hotfixWhitelistValidatorTally(hash) >= minQuorumSizeInCurrentSet();\n  }\n\n  /**\n   * @notice Gets information about a hotfix.\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction.\n   * @return Hotfix approved.\n   * @return Hotfix executed.\n   * @return Hotfix preparedEpoch.\n   */\n  function getHotfixRecord(bytes32 hash) public view returns (bool, bool, uint256) {\n    return (hotfixes[hash].approved, hotfixes[hash].executed, hotfixes[hash].preparedEpoch);\n  }\n\n  /**\n   * @notice Removes the proposals with the most upvotes from the queue, moving them to the\n   *   approval stage.\n   * @dev If any of the top proposals have expired, they are deleted.\n   */\n  function dequeueProposalsIfReady() public {\n    // solhint-disable-next-line not-rely-on-time\n    if (now >= lastDequeue.add(dequeueFrequency)) {\n      uint256 numProposalsToDequeue = Math.min(concurrentProposals, queue.list.numElements);\n      uint256[] memory dequeuedIds = queue.popN(numProposalsToDequeue);\n\n      bool wasAnyProposalDequeued = false;\n      for (uint256 i = 0; i < numProposalsToDequeue; i = i.add(1)) {\n        uint256 proposalId = dequeuedIds[i];\n        Proposals.Proposal storage proposal = proposals[proposalId];\n        if (_isQueuedProposalExpired(proposal)) {\n          emit ProposalExpired(proposalId);\n          continue;\n        }\n        refundedDeposits[proposal.proposer] = refundedDeposits[proposal.proposer].add(\n          proposal.deposit\n        );\n        // solhint-disable-next-line not-rely-on-time\n        proposal.timestamp = now;\n        if (emptyIndices.length != 0) {\n          uint256 indexOfLastEmptyIndex = emptyIndices.length.sub(1);\n          dequeued[emptyIndices[indexOfLastEmptyIndex]] = proposalId;\n          delete emptyIndices[indexOfLastEmptyIndex];\n          emptyIndices.length = indexOfLastEmptyIndex;\n        } else {\n          dequeued.push(proposalId);\n        }\n        // solhint-disable-next-line not-rely-on-time\n        emit ProposalDequeued(proposalId, now);\n        wasAnyProposalDequeued = true;\n      }\n      if (wasAnyProposalDequeued) {\n        // solhint-disable-next-line not-rely-on-time\n        lastDequeue = now;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns whether or not a proposal is in the queue.\n   * @dev NOTE: proposal may be expired\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the proposal is in the queue.\n   */\n  function isQueued(uint256 proposalId) public view returns (bool) {\n    return queue.contains(proposalId);\n  }\n\n  /**\n   * @notice Returns whether or not a particular proposal is passing according to the constitution\n   *   and the participation levels.\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the proposal is passing.\n   */\n  function isProposalPassing(uint256 proposalId) external view returns (bool) {\n    return _isProposalPassing(proposals[proposalId]);\n  }\n\n  /**\n   * @notice Returns whether or not a particular proposal is passing according to the constitution\n   *   and the participation levels.\n   * @param proposal The proposal struct.\n   * @return Whether or not the proposal is passing.\n   */\n  function _isProposalPassing(Proposals.Proposal storage proposal) private view returns (bool) {\n    FixidityLib.Fraction memory support = proposal.getSupportWithQuorumPadding(\n      participationParameters.baseline.multiply(participationParameters.baselineQuorumFactor)\n    );\n\n    if (proposal.transactions.length == 0) {\n      // default treshold\n      FixidityLib.Fraction memory threshold = _getConstitution(address(0), \"\");\n      return support.gt(threshold);\n    }\n\n    for (uint256 i = 0; i < proposal.transactions.length; i = i.add(1)) {\n      bytes4 functionId = ExtractFunctionSignature.extractFunctionSignature(\n        proposal.transactions[i].data\n      );\n      FixidityLib.Fraction memory threshold = _getConstitution(\n        proposal.transactions[i].destination,\n        functionId\n      );\n      if (support.lte(threshold)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @notice Returns whether a proposal is dequeued at the given index.\n   * @param proposalId The ID of the proposal.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @return Whether the proposal is in `dequeued`.\n   */\n  function isDequeuedProposal(uint256 proposalId, uint256 index) external view returns (bool) {\n    return _isDequeuedProposal(proposals[proposalId], proposalId, index);\n  }\n\n  /**\n   * @notice Returns whether a proposal is dequeued at the given index.\n   * @param proposal The proposal struct.\n   * @param proposalId The ID of the proposal.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @return Whether the proposal is in `dequeued` at index.\n   */\n  function _isDequeuedProposal(\n    Proposals.Proposal storage proposal,\n    uint256 proposalId,\n    uint256 index\n  ) private view returns (bool) {\n    require(index < dequeued.length, \"Provided index greater than dequeue length.\");\n    return proposal.exists() && dequeued[index] == proposalId;\n  }\n\n  /**\n   * @notice Returns whether or not a dequeued proposal has expired.\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the dequeued proposal has expired.\n   */\n  function isDequeuedProposalExpired(uint256 proposalId) external view returns (bool) {\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    return _isDequeuedProposalExpired(proposal, getProposalDequeuedStage(proposal));\n  }\n\n  /**\n   * @notice Returns whether or not a dequeued proposal has expired.\n   * @param proposal The proposal struct.\n   * @return Whether or not the dequeued proposal has expired.\n   */\n  function _isDequeuedProposalExpired(Proposals.Proposal storage proposal, Proposals.Stage stage)\n    private\n    view\n    returns (bool)\n  {\n    // The proposal is considered expired under the following conditions:\n    //   1. Past the referendum stage and not passing.\n    //   2. Past the execution stage.\n    return ((stage > Proposals.Stage.Execution) ||\n      (stage > Proposals.Stage.Referendum && !_isProposalPassing(proposal)));\n  }\n\n  /**\n   * @notice Returns whether or not a queued proposal has expired.\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the dequeued proposal has expired.\n   */\n  function isQueuedProposalExpired(uint256 proposalId) public view returns (bool) {\n    return _isQueuedProposalExpired(proposals[proposalId]);\n  }\n\n  /**\n   * @notice Returns whether or not a queued proposal has expired.\n   * @param proposal The proposal struct.\n   * @return Whether or not the dequeued proposal has expired.\n   */\n  function _isQueuedProposalExpired(Proposals.Proposal storage proposal)\n    private\n    view\n    returns (bool)\n  {\n    // solhint-disable-next-line not-rely-on-time\n    return now >= proposal.timestamp.add(queueExpiry);\n  }\n\n  /**\n   * @notice Deletes a dequeued proposal.\n   * @param proposal The proposal struct.\n   * @param proposalId The ID of the proposal to delete.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @dev Must always be preceded by `isDequeuedProposal`, which checks `index`.\n   */\n  function deleteDequeuedProposal(\n    Proposals.Proposal storage proposal,\n    uint256 proposalId,\n    uint256 index\n  ) private {\n    if (proposal.isApproved() && proposal.networkWeight != 0) {\n      updateParticipationBaseline(proposal);\n    }\n    dequeued[index] = 0;\n    emptyIndices.push(index);\n    delete proposals[proposalId];\n  }\n\n  /**\n   * @notice Updates the participation baseline based on the proportion of BondedDeposit weight\n   *   that participated in the proposal's Referendum stage.\n   * @param proposal The proposal struct.\n   */\n  function updateParticipationBaseline(Proposals.Proposal storage proposal) private {\n    FixidityLib.Fraction memory participation = proposal.getParticipation();\n    FixidityLib.Fraction memory participationComponent = participation.multiply(\n      participationParameters.baselineUpdateFactor\n    );\n    FixidityLib.Fraction memory baselineComponent = participationParameters.baseline.multiply(\n      FixidityLib.fixed1().subtract(participationParameters.baselineUpdateFactor)\n    );\n    participationParameters.baseline = participationComponent.add(baselineComponent);\n    if (participationParameters.baseline.lt(participationParameters.baselineFloor)) {\n      participationParameters.baseline = participationParameters.baselineFloor;\n    }\n    emit ParticipationBaselineUpdated(participationParameters.baseline.unwrap());\n  }\n\n  /**\n   * @notice Returns the constitution for a particular destination and function ID.\n   * @param destination The destination address to get the constitution for.\n   * @param functionId The function ID to get the constitution for, zero for the destination\n   *   default.\n   * @return The ratio of yes:no votes needed to exceed in order to pass the proposal.\n   */\n  function getConstitution(address destination, bytes4 functionId) external view returns (uint256) {\n    return _getConstitution(destination, functionId).unwrap();\n  }\n\n  function _getConstitution(address destination, bytes4 functionId)\n    internal\n    view\n    returns (FixidityLib.Fraction memory)\n  {\n    // Default to a simple majority.\n    FixidityLib.Fraction memory threshold = FixidityLib.wrap(FIXED_HALF);\n    if (constitution[destination].functionThresholds[functionId].unwrap() != 0) {\n      threshold = constitution[destination].functionThresholds[functionId];\n    } else if (constitution[destination].defaultThreshold.unwrap() != 0) {\n      threshold = constitution[destination].defaultThreshold;\n    }\n    return threshold;\n  }\n\n  /**\n   * @notice Returns max number of votes cast by an account.\n   * @param account The address of the account.\n   * @return The total number of votes cast by an account.\n   */\n  function getAmountOfGoldUsedForVoting(address account) public view returns (uint256) {\n    Voter storage voter = voters[account];\n\n    uint256 upvotedProposalId = voter.upvote.proposalId;\n    bool isVotingQueue = upvotedProposalId != 0 &&\n      isQueued(upvotedProposalId) &&\n      !isQueuedProposalExpired(upvotedProposalId);\n\n    if (isVotingQueue) {\n      uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n      return weight;\n    }\n\n    uint256 maxUsed = 0;\n    for (uint256 index = 0; index < dequeued.length; index = index.add(1)) {\n      Proposals.Proposal storage proposal = proposals[dequeued[index]];\n      bool isVotingReferendum = (getProposalDequeuedStage(proposal) == Proposals.Stage.Referendum);\n\n      if (!isVotingReferendum) {\n        continue;\n      }\n\n      VoteRecord storage voteRecord = voter.referendumVotes[index];\n      uint256 votesCast = voteRecord.yesVotes.add(voteRecord.noVotes).add(voteRecord.abstainVotes);\n      maxUsed = Math.max(\n        maxUsed,\n        // backward compatibility for transition period - this should be updated later on\n        votesCast == 0 ? voteRecord.deprecated_weight : votesCast\n      );\n    }\n    return maxUsed;\n  }\n\n  /**\n   * @notice When delegator removes votes from delegatee during the time when delegator is voting\n   * for governance proposal, this method will remove votes from voted proposal proportionally.\n   * @param account The address of the account.\n   * @param newVotingPower The adjusted voting power of delegatee.\n   */\n  function removeVotesWhenRevokingDelegatedVotes(address account, uint256 newVotingPower)\n    public\n    onlyLockedGold\n  {\n    _removeVotesWhenRevokingDelegatedVotes(account, newVotingPower);\n  }\n\n  /**\n   * @notice When delegator removes votes from delegatee during the time when delegator is voting\n   * for governance proposal, this method will remove votes from voted proposal proportionally.\n   * @param account The address of the account.\n   * @param newVotingPower The adjusted voting power of delegatee.\n   */\n  function _removeVotesWhenRevokingDelegatedVotes(address account, uint256 newVotingPower)\n    internal\n  {\n    Voter storage voter = voters[account];\n\n    for (uint256 index = 0; index < dequeued.length; index = index.add(1)) {\n      Proposals.Proposal storage proposal = proposals[dequeued[index]];\n      bool isVotingReferendum = (getProposalDequeuedStage(proposal) == Proposals.Stage.Referendum);\n\n      if (!isVotingReferendum) {\n        continue;\n      }\n\n      VoteRecord storage voteRecord = voter.referendumVotes[index];\n      uint256 sumOfVotes = voteRecord.yesVotes.add(voteRecord.noVotes).add(voteRecord.abstainVotes);\n\n      if (sumOfVotes > newVotingPower) {\n        uint256 toRemove = sumOfVotes.sub(newVotingPower);\n\n        uint256 abstainToRemove = getVotesPortion(toRemove, voteRecord.abstainVotes, sumOfVotes);\n        uint256 yesToRemove = getVotesPortion(toRemove, voteRecord.yesVotes, sumOfVotes);\n        uint256 noToRemove = getVotesPortion(toRemove, voteRecord.noVotes, sumOfVotes);\n\n        uint256 totalRemoved = abstainToRemove.add(yesToRemove).add(noToRemove);\n\n        uint256 yesVotes = voteRecord.yesVotes.sub(yesToRemove);\n        uint256 noVotes = voteRecord.noVotes.sub(noToRemove);\n        uint256 abstainVotes = voteRecord.abstainVotes.sub(abstainToRemove);\n\n        if (totalRemoved < toRemove) {\n          // in case of rounding error\n          uint256 roundingToRemove = toRemove.sub(totalRemoved);\n\n          uint256 toRemoveRounding = Math.min(roundingToRemove, yesVotes);\n          yesVotes = yesVotes.sub(toRemoveRounding);\n          roundingToRemove = roundingToRemove.sub(toRemoveRounding);\n\n          if (roundingToRemove != 0) {\n            toRemoveRounding = Math.min(roundingToRemove, noVotes);\n            noVotes = noVotes.sub(toRemoveRounding);\n            roundingToRemove = roundingToRemove.sub(toRemoveRounding);\n          }\n\n          if (roundingToRemove != 0) {\n            toRemoveRounding = Math.min(roundingToRemove, abstainVotes);\n            abstainVotes = abstainVotes.sub(toRemoveRounding);\n          }\n        }\n\n        proposal.updateVote(\n          voteRecord.yesVotes,\n          voteRecord.noVotes,\n          voteRecord.abstainVotes,\n          yesVotes,\n          noVotes,\n          abstainVotes\n        );\n\n        voteRecord.abstainVotes = abstainVotes;\n        voteRecord.yesVotes = yesVotes;\n        voteRecord.noVotes = noVotes;\n      }\n    }\n  }\n\n  /**\n   * Returns amount of votes that should be removed from delegatee's proposal voting.\n   * @param totalToRemove Total votes to be removed.\n   * @param votes Yes/no/abstrain votes\n   * @param sumOfAllVotes Sum of yes, no, and abstain votes.\n   */\n  function getVotesPortion(uint256 totalToRemove, uint256 votes, uint256 sumOfAllVotes)\n    private\n    pure\n    returns (uint256)\n  {\n    return\n      FixidityLib\n        .newFixed(totalToRemove)\n        .multiply(FixidityLib.newFixedFraction(votes, sumOfAllVotes))\n        .fromFixed();\n  }\n\n  /**\n   * @param values The values of CELO to be sent in the proposed transactions.\n   * @param destinations The destination addresses of the proposed transactions.\n   * @param data The concatenated data to be included in the proposed transactions.\n   * @param dataLengths The lengths of each transaction's data.\n   * @param salt Arbitrary salt associated with hotfix which guarantees uniqueness of hash.\n   * @return The hash of the hotfix.\n   */\n  function getHotfixHash(\n    uint256[] calldata values,\n    address[] calldata destinations,\n    bytes calldata data,\n    uint256[] calldata dataLengths,\n    bytes32 salt\n  ) external pure returns (bytes32) {\n    return keccak256(abi.encode(values, destinations, data, dataLengths, salt));\n  }\n\n  /**\n   * @notice Returns the stage of a dequeued proposal.\n   * @param proposal The proposal struct.\n   * @return The stage of the dequeued proposal.\n   * @dev Must be called on a dequeued proposal.\n   */\n  function getProposalDequeuedStage(Proposals.Proposal storage proposal)\n    internal\n    view\n    returns (Proposals.Stage)\n  {\n    uint256 stageStartTime = proposal.timestamp.add(stageDurations.referendum).add(\n      stageDurations.execution\n    );\n    // solhint-disable-next-line not-rely-on-time\n    if (\n      now >= stageStartTime &&\n      (proposal.transactions.length != 0 ||\n        // proposals with 0 transactions can expire only when not approved or not passing\n        !proposal.isApproved() ||\n        !_isProposalPassing(proposal))\n    ) {\n      return Proposals.Stage.Expiration;\n    }\n    stageStartTime = stageStartTime.sub(stageDurations.execution);\n    // solhint-disable-next-line not-rely-on-time\n    if (now >= stageStartTime) {\n      return Proposals.Stage.Execution;\n    }\n    return Proposals.Stage.Referendum;\n  }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "ID",
                "getVersionNumber",
                "initialize",
                "setApprover",
                "setConcurrentProposals",
                "setMinDeposit",
                "setQueueExpiry",
                "setDequeueFrequency",
                "setReferendumStageDuration",
                "setExecutionStageDuration",
                "setParticipationBaseline",
                "setParticipationFloor",
                "setBaselineUpdateFactor",
                "setBaselineQuorumFactor",
                "propose",
                "removeIfQueuedAndExpired",
                "requireDequeuedAndDeleteExpired",
                "upvote",
                "getProposalStage",
                "revokeUpvote",
                "approve",
                "vote",
                "votePartially",
                "_vote",
                "revokeVotes",
                "execute",
                "approveHotfix",
                "isHotfixWhitelistedBy",
                "whitelistHotfix",
                "prepareHotfix",
                "executeHotfix",
                "withdraw",
                "isVoting",
                "getReferendumStageDuration",
                "getExecutionStageDuration",
                "getParticipationParameters",
                "proposalExists",
                "getProposal",
                "getProposalTransaction",
                "isApproved",
                "getVoteTotals",
                "getVoteRecord",
                "getQueueLength",
                "getUpvotes",
                "getQueue",
                "getDequeue",
                "getUpvoteRecord",
                "getMostRecentReferendumProposal",
                "hotfixWhitelistValidatorTally",
                "isHotfixPassing",
                "getHotfixRecord",
                "dequeueProposalsIfReady",
                "isQueued",
                "isProposalPassing",
                "_isProposalPassing",
                "isDequeuedProposal",
                "_isDequeuedProposal",
                "isDequeuedProposalExpired",
                "_isDequeuedProposalExpired",
                "isQueuedProposalExpired",
                "_isQueuedProposalExpired",
                "deleteDequeuedProposal",
                "updateParticipationBaseline",
                "_getConstitution",
                "getAmountOfGoldUsedForVoting",
                "removeVotesWhenRevokingDelegatedVotes",
                "_removeVotesWhenRevokingDelegatedVotes",
                "getVotesPortion",
                "getHotfixHash",
                "getProposalDequeuedStage"
            ],
            "state_variables": [
                "weight",
                "emptyIndices",
                "approver",
                "proposalCount",
                "whitelisted",
                "stageDurations",
                "proposalId",
                "proposals",
                "mostRecentReferendumProposal",
                "queue",
                "hotfixes",
                "voters",
                "preparedEpoch",
                "minDeposit",
                "dequeueFrequency",
                "executed",
                "referendumVotes",
                "refundedDeposits",
                "abstainVotes",
                "concurrentProposals",
                "payable",
                "lastDequeue",
                "queueExpiry",
                "dequeued",
                "yesVotes",
                "deprecated_weight",
                "noVotes",
                "approved",
                "participationParameters",
                "functionThresholds",
                "constitution"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "Governance_dequeuedIsWithinRange_b5176708",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Governance.sol",
        "target_function": "getUpvoteRecord/getUpvotes/upvote/vote",
        "text_chunk": "  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n",
        "formal_property": "invariant dequeuedIsWithinRange(uint i) getFromDequeued(i) <= proposalCount()\n\n// upvoting\nrule upvotesConsistency(address u, method f) filtered { f -> !f.isView } {\n    // the invariant is upvoteInv, defined here\n} \ndefinition upvoteInv(uint p, uint w) returns bool \n    = (p != 0 && w > 0) || (p == 0 && w == 0)\n    ;\nrule no_double_upvote(uint256 p, address u) {\n\tuint256 _upvotes = getUpvotes(p);\n\tuint256 _usersUpvotedProposal = getUpvotedProposal(u);\n\tenv e;\n\trequire e.msg.sender == u && u != 0; // note that the sender is the signer here\n    require accounts.voteSignerToAccount(u) == u;\n\tuint256 lesser; \n    uint256 greater;\n\tupvote(e, p, lesser, greater);\n\tuint256 upvotes_ = getUpvotes(p);\n\t\n    uint voteRecordP;\n    uint voteRecordW;\n    voteRecordP, voteRecordW = getUpvoteRecord(u);\n    require upvoteInv(voteRecordP, voteRecordW);\n\tassert _usersUpvotedProposal == p => upvotes_ <= _upvotes, \n\t\t\"Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "dequeuedIsWithinRange",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "vote",
                "proposalCount",
                "getFromDequeued"
            ],
            "start_line": 58,
            "end_line": 62,
            "block_hash": "b51767088f523f877916b3270ef437e0"
        }
    },
    {
        "id": "Governance_is_6a2f1725",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Governance.sol",
        "target_function": "getUpvoteRecord/getUpvotes/upvote/vote",
        "text_chunk": "  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n",
        "formal_property": "    // the invariant is upvoteInv, defined here\n} \n\ndefinition upvoteInv(uint p, uint w) returns bool \n    = (p != 0 && w > 0) || (p == 0 && w == 0)\n    ;\nrule no_double_upvote(uint256 p, address u) {\n\tuint256 _upvotes = getUpvotes(p);\n\tuint256 _usersUpvotedProposal = getUpvotedProposal(u);\n\tenv e;\n\trequire e.msg.sender == u && u != 0; // note that the sender is the signer here\n    require accounts.voteSignerToAccount(u) == u;\n\tuint256 lesser; \n    uint256 greater;\n\tupvote(e, p, lesser, greater);\n\tuint256 upvotes_ = getUpvotes(p);\n\t\n    uint voteRecordP;\n    uint voteRecordW;\n    voteRecordP, voteRecordW = getUpvoteRecord(u);\n    require upvoteInv(voteRecordP, voteRecordW);\n\tassert _usersUpvotedProposal == p => upvotes_ <= _upvotes, \n\t\t\"Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "is",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "vote",
                "getUpvotes",
                "getUpvotedProposal",
                "getUpvoteRecord",
                "voteSignerToAccount",
                "accounts.voteSignerToAccount"
            ],
            "start_line": 73,
            "end_line": 97,
            "block_hash": "6a2f1725b96c0fc09fd267f71f60c14d"
        }
    },
    {
        "id": "Governance_referendumVoteIDIsLessThanOrEqCounter_fcfd0268",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Governance.sol",
        "target_function": "getUpvoteRecord/getUpvotes/upvote/vote",
        "text_chunk": "  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n",
        "formal_property": "invariant referendumVoteIDIsLessThanOrEqCounter(address v, uint p) votedFor(v,p) => p <= proposalCount() {\n    preserved vote(uint256 _, uint256 indx, uint8 vr) with (env e) {\n        requireInvariant dequeuedIsWithinRange(indx); \ninvariant dequeuedIsWithinRange(uint i) getFromDequeued(i) <= proposalCount()\n\n// upvoting\nrule upvotesConsistency(address u, method f) filtered { f -> !f.isView } {\n    // the invariant is upvoteInv, defined here\n} \ndefinition upvoteInv(uint p, uint w) returns bool \n    = (p != 0 && w > 0) || (p == 0 && w == 0)\n    ;\nrule no_double_upvote(uint256 p, address u) {\n\tuint256 _upvotes = getUpvotes(p);\n\tuint256 _usersUpvotedProposal = getUpvotedProposal(u);\n\tenv e;\n\trequire e.msg.sender == u && u != 0; // note that the sender is the signer here\n    require accounts.voteSignerToAccount(u) == u;\n\tuint256 lesser; \n    uint256 greater;\n\tupvote(e, p, lesser, greater);\n\tuint256 upvotes_ = getUpvotes(p);\n\t\n    uint voteRecordP;\n    uint voteRecordW;\n    voteRecordP, voteRecordW = getUpvoteRecord(u);\n    require upvoteInv(voteRecordP, voteRecordW);\n\tassert _usersUpvotedProposal == p => upvotes_ <= _upvotes, \n\t\t\"Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p\";\n}\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "referendumVoteIDIsLessThanOrEqCounter",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "vote",
                "proposalCount"
            ],
            "start_line": 211,
            "end_line": 215,
            "block_hash": "fcfd0268d2634b4b50851c5dfba6702f"
        }
    },
    {
        "id": "Governance_upvotesConsistency_8fcca43b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Governance.sol",
        "target_function": "getUpvoteRecord/getUpvotes/upvote/vote",
        "text_chunk": "  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n",
        "formal_property": "rule upvotesConsistency(address u, method f) filtered { f -> !f.isView } {\n    // the invariant is upvoteInv, defined here\n} \n\ndefinition upvoteInv(uint p, uint w) returns bool \n    = (p != 0 && w > 0) || (p == 0 && w == 0)\n    ;\nrule no_double_upvote(uint256 p, address u) {\n\tuint256 _upvotes = getUpvotes(p);\n\tuint256 _usersUpvotedProposal = getUpvotedProposal(u);\n\tenv e;\n\trequire e.msg.sender == u && u != 0; // note that the sender is the signer here\n    require accounts.voteSignerToAccount(u) == u;\n\tuint256 lesser; \n    uint256 greater;\n\tupvote(e, p, lesser, greater);\n\tuint256 upvotes_ = getUpvotes(p);\n\t\n    uint voteRecordP;\n    uint voteRecordW;\n    voteRecordP, voteRecordW = getUpvoteRecord(u);\n    require upvoteInv(voteRecordP, voteRecordW);\n\tassert _usersUpvotedProposal == p => upvotes_ <= _upvotes, \n\t\t\"Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "upvotesConsistency",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "vote"
            ],
            "start_line": 62,
            "end_line": 62,
            "block_hash": "8fcca43bd589f612eacb63d0ca776f6d"
        }
    },
    {
        "id": "Governance_no_double_upvote_6e4742dc",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Governance.sol",
        "target_function": "getUpvoteRecord/getUpvotes/upvote/vote",
        "text_chunk": "  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n",
        "formal_property": "rule no_double_upvote(uint256 p, address u) {\n\tuint256 _upvotes = getUpvotes(p);\n\tuint256 _usersUpvotedProposal = getUpvotedProposal(u);\n\tenv e;\n\trequire e.msg.sender == u && u != 0; // note that the sender is the signer here\n    // the invariant is upvoteInv, defined here\n} \n\ndefinition upvoteInv(uint p, uint w) returns bool \n    = (p != 0 && w > 0) || (p == 0 && w == 0)\n    ;\n    require accounts.voteSignerToAccount(u) == u;\n\tuint256 lesser; \n    uint256 greater;\n\tupvote(e, p, lesser, greater);\n\tuint256 upvotes_ = getUpvotes(p);\n\t\n    uint voteRecordP;\n    uint voteRecordW;\n    voteRecordP, voteRecordW = getUpvoteRecord(u);\n    require upvoteInv(voteRecordP, voteRecordW);\n\tassert _usersUpvotedProposal == p => upvotes_ <= _upvotes, \n\t\t\"Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "no_double_upvote",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "vote",
                "getUpvotes",
                "getUpvotedProposal",
                "getUpvoteRecord",
                "voteSignerToAccount",
                "accounts.voteSignerToAccount"
            ],
            "start_line": 80,
            "end_line": 97,
            "block_hash": "6e4742dc5a71e9541285050492a414be"
        }
    },
    {
        "id": "Governance_proposal_count_monotonic_increasing_d16f9539",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Governance.sol",
        "target_function": "getUpvoteRecord/getUpvotes/upvote/vote",
        "text_chunk": "  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n",
        "formal_property": "rule proposal_count_monotonic_increasing(method f) filtered { f -> !f.isView } {\n    // the invariant is upvoteInv, defined here\n} \n\ndefinition upvoteInv(uint p, uint w) returns bool \n    = (p != 0 && w > 0) || (p == 0 && w == 0)\n    ;\nrule no_double_upvote(uint256 p, address u) {\n\tuint256 _upvotes = getUpvotes(p);\n\tuint256 _usersUpvotedProposal = getUpvotedProposal(u);\n\tenv e;\n\trequire e.msg.sender == u && u != 0; // note that the sender is the signer here\n    require accounts.voteSignerToAccount(u) == u;\n\tuint256 lesser; \n    uint256 greater;\n\tupvote(e, p, lesser, greater);\n\tuint256 upvotes_ = getUpvotes(p);\n\t\n    uint voteRecordP;\n    uint voteRecordW;\n    voteRecordP, voteRecordW = getUpvoteRecord(u);\n    require upvoteInv(voteRecordP, voteRecordW);\n\tassert _usersUpvotedProposal == p => upvotes_ <= _upvotes, \n\t\t\"Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "proposal_count_monotonic_increasing",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 99,
            "end_line": 99,
            "block_hash": "d16f95390bb1db937787fae7f2d5c5b7"
        }
    },
    {
        "id": "Governance_no_referendum_votes_unless_approved_c7f6a6e2",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Governance.sol",
        "target_function": "getUpvoteRecord/getUpvotes/upvote/vote",
        "text_chunk": "  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n",
        "formal_property": "rule no_referendum_votes_unless_approved(method f, uint256 p) filtered { f -> !f.isView } {\n    // the invariant is upvoteInv, defined here\n} \n\ndefinition upvoteInv(uint p, uint w) returns bool \n    = (p != 0 && w > 0) || (p == 0 && w == 0)\n    ;\nrule no_double_upvote(uint256 p, address u) {\n\tuint256 _upvotes = getUpvotes(p);\n\tuint256 _usersUpvotedProposal = getUpvotedProposal(u);\n\tenv e;\n\trequire e.msg.sender == u && u != 0; // note that the sender is the signer here\n    require accounts.voteSignerToAccount(u) == u;\n\tuint256 lesser; \n    uint256 greater;\n\tupvote(e, p, lesser, greater);\n\tuint256 upvotes_ = getUpvotes(p);\n\t\n    uint voteRecordP;\n    uint voteRecordW;\n    voteRecordP, voteRecordW = getUpvoteRecord(u);\n    require upvoteInv(voteRecordP, voteRecordW);\n\tassert _usersUpvotedProposal == p => upvotes_ <= _upvotes, \n\t\t\"Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "no_referendum_votes_unless_approved",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "vote"
            ],
            "start_line": 118,
            "end_line": 118,
            "block_hash": "c7f6a6e2add672e8915140858fc3cb48"
        }
    },
    {
        "id": "Governance_cant_unvote_1572097d",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Governance.sol",
        "target_function": "getUpvoteRecord/getUpvotes/getVoteRecord/upvote/vote",
        "text_chunk": "  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n\n  function getVoteRecord(address account, uint256 index)\n    external\n    view\n    returns (uint256, uint256, uint256, uint256, uint256, uint256)\n  {\n    VoteRecord storage record = voters[account].referendumVotes[index];\n    return (\n      record.proposalId,\n      uint256(record.deprecated_value),\n      record.deprecated_weight,\n      record.yesVotes,\n      record.noVotes,\n      record.abstainVotes\n    );\n  }\n\n\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n",
        "formal_property": "rule cant_unvote(uint256 deqIndex, uint8 voteValue) {\t\n    env eF;\n\tuint256 NONE_ENUM = getNoneVoteEnum();\n\t// get the voting delegate\n\taddress voterDelegate = accounts.getVoteSigner(eF.msg.sender);\n\t\n\t// check if voted\n    uint256 p;\n\tuint256 recordValue;\n    uint256 weight;\n\tp, recordValue, weight = getVoteRecord(voterDelegate,deqIndex);\n\tbool result = vote(eF,p,deqIndex,voteValue);\n\tuint256 recordValue_;\n    uint256 weight_;\n\t_, recordValue_, weight_ = getVoteRecord(voterDelegate,deqIndex);\n\tassert voteValue == NONE_ENUM => (!result && recordValue_ == recordValue && weight_ == weight), \"Cannot vote for none: function either returns false and did not update the vote, or it reverted\"; // not voting none. reverting is fine and is encoded by the safe invoke\n    // the invariant is upvoteInv, defined here\n} \n\ndefinition upvoteInv(uint p, uint w) returns bool \n    = (p != 0 && w > 0) || (p == 0 && w == 0)\n    ;\nrule no_double_upvote(uint256 p, address u) {\n\tuint256 _upvotes = getUpvotes(p);\n\tuint256 _usersUpvotedProposal = getUpvotedProposal(u);\n\tenv e;\n\trequire e.msg.sender == u && u != 0; // note that the sender is the signer here\n    require accounts.voteSignerToAccount(u) == u;\n\tuint256 lesser; \n    uint256 greater;\n\tupvote(e, p, lesser, greater);\n\tuint256 upvotes_ = getUpvotes(p);\n    uint voteRecordP;\n    uint voteRecordW;\n    voteRecordP, voteRecordW = getUpvoteRecord(u);\n    require upvoteInv(voteRecordP, voteRecordW);\n\tassert _usersUpvotedProposal == p => upvotes_ <= _upvotes, \n\t\t\"Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cant_unvote",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "vote",
                "getNoneVoteEnum",
                "getVoteRecord",
                "getVoteSigner",
                "accounts.getVoteSigner"
            ],
            "start_line": 143,
            "end_line": 161,
            "block_hash": "1572097dde1aff4f0807edf352aa89d7"
        }
    },
    {
        "id": "Governance_no_double_vote_referendum_all_but_vote_eebd0f2e",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Governance.sol",
        "target_function": "_vote/getUpvoteRecord/getUpvotes/upvote/vote",
        "text_chunk": "  function _vote(\n    Proposals.Proposal storage proposal,\n    uint256 proposalId,\n    uint256 index,\n    address account,\n    uint256 yesVotes,\n    uint256 noVotes,\n    uint256 abstainVotes\n  ) private {\n    Voter storage voter = voters[account];\n\n    VoteRecord storage previousVoteRecord = voter.referendumVotes[index];\n\n    if (previousVoteRecord.proposalId != proposalId) {\n      // VoteRecord is being stored based on index (in `dequeued`) rather than proposalId.\n      // It can happen that user voted on proposal that later gets deleted.\n      // VoteRecord will still stay in `referendumVotes` mapping.\n      // Once new proposal is created it might get same index as previous proposal.\n      // In such case we need to check whether existing VoteRecord is relevant to new\n      // proposal of whether it is just left over data.\n      proposal.updateVote(0, 0, 0, yesVotes, noVotes, abstainVotes);\n    } else if (previousVoteRecord.deprecated_weight != 0) {\n      // backward compatibility for transition period - this should be deleted later on\n      proposal.updateVote(\n        previousVoteRecord.deprecated_value == Proposals.VoteValue.Yes\n          ? previousVoteRecord.deprecated_weight\n          : 0,\n        previousVoteRecord.deprecated_value == Proposals.VoteValue.No\n          ? previousVoteRecord.deprecated_weight\n          : 0,\n        previousVoteRecord.deprecated_value == Proposals.VoteValue.Abstain\n          ? previousVoteRecord.deprecated_weight\n          : 0,\n        yesVotes,\n        noVotes,\n        abstainVotes\n      );\n    } else {\n      proposal.updateVote(\n        previousVoteRecord.yesVotes,\n        previousVoteRecord.noVotes,\n        previousVoteRecord.abstainVotes,\n        yesVotes,\n        noVotes,\n        abstainVotes\n      );\n    }\n\n    proposal.networkWeight = getLockedGold().getTotalLockedGold();\n    voter.referendumVotes[index] = VoteRecord(\n      Proposals.VoteValue.None,\n      proposalId,\n      0,\n      yesVotes,\n      noVotes,\n      abstainVotes\n    );\n    if (proposal.timestamp > proposals[voter.mostRecentReferendumProposal].timestamp) {\n      voter.mostRecentReferendumProposal = proposalId;\n    }\n\n    emit ProposalVotedV2(proposalId, account, yesVotes, noVotes, abstainVotes);\n  }\n\n\n  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n",
        "formal_property": "rule no_double_vote_referendum_all_but_vote(method f, address account, uint256 deqIndex) filtered { f -> !f.isView } {\n    // the invariant is upvoteInv, defined here\n} \n\ndefinition upvoteInv(uint p, uint w) returns bool \n    = (p != 0 && w > 0) || (p == 0 && w == 0)\n    ;\nrule no_double_upvote(uint256 p, address u) {\n\tuint256 _upvotes = getUpvotes(p);\n\tuint256 _usersUpvotedProposal = getUpvotedProposal(u);\n\tenv e;\n\trequire e.msg.sender == u && u != 0; // note that the sender is the signer here\n    require accounts.voteSignerToAccount(u) == u;\n\tuint256 lesser; \n    uint256 greater;\n\tupvote(e, p, lesser, greater);\n\tuint256 upvotes_ = getUpvotes(p);\n\t\n    uint voteRecordP;\n    uint voteRecordW;\n    voteRecordP, voteRecordW = getUpvoteRecord(u);\n    require upvoteInv(voteRecordP, voteRecordW);\n\tassert _usersUpvotedProposal == p => upvotes_ <= _upvotes, \n\t\t\"Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "no_double_vote_referendum_all_but_vote",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "vote"
            ],
            "start_line": 164,
            "end_line": 164,
            "block_hash": "eebd0f2e5430b0c1cf57854f227008ba"
        }
    },
    {
        "id": "Governance_approval_only_if_promoted_and_allowed_6c8b5c49",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Governance.sol",
        "target_function": "approve/getUpvoteRecord/getUpvotes/isApproved/isDequeuedProposalExpired/upvote/vote",
        "text_chunk": "  function approve(uint256 proposalId, uint256 index) external onlyApprover returns (bool) {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(!proposal.isApproved(), \"Proposal already approved\");\n    require(\n      stage == Proposals.Stage.Referendum || stage == Proposals.Stage.Execution,\n      \"Proposal not in correct stage\"\n    );\n    proposal.approved = true;\n    // Ensures networkWeight is set by the end of the Referendum stage, even if 0 votes are cast.\n    proposal.networkWeight = getLockedGold().getTotalLockedGold();\n    emit ProposalApproved(proposalId);\n    return true;\n  }\n\n\n  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n\n  function isApproved(uint256 proposalId) external view returns (bool) {\n    return proposals[proposalId].isApproved();\n  }\n\n\n  function isDequeuedProposalExpired(uint256 proposalId) external view returns (bool) {\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    return _isDequeuedProposalExpired(proposal, getProposalDequeuedStage(proposal));\n  }\n\n\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n",
        "formal_property": "rule approval_only_if_promoted_and_allowed(uint256 p, uint256 index) {\n\t// A proposal should never be able to be approved unless it was promoted from the queue\n\tenv eF;\n    env eGet;\n    require eF.block.timestamp == eGet.block.timestamp;\n    require eF.block.number == eGet.block.number;\n\t\n\tbool _isProposalApproved = isApproved(p);\n    // the invariant is upvoteInv, defined here\n} \n\ndefinition upvoteInv(uint p, uint w) returns bool \n    = (p != 0 && w > 0) || (p == 0 && w == 0)\n    ;\nrule no_double_upvote(uint256 p, address u) {\n\tuint256 _upvotes = getUpvotes(p);\n\tuint256 _usersUpvotedProposal = getUpvotedProposal(u);\n\tenv e;\n\trequire e.msg.sender == u && u != 0; // note that the sender is the signer here\n    require accounts.voteSignerToAccount(u) == u;\n\tuint256 lesser; \n    uint256 greater;\n\tupvote(e, p, lesser, greater);\n\tuint256 upvotes_ = getUpvotes(p);\n    uint voteRecordP;\n    uint voteRecordW;\n    voteRecordP, voteRecordW = getUpvoteRecord(u);\n    require upvoteInv(voteRecordP, voteRecordW);\n\tassert _usersUpvotedProposal == p => upvotes_ <= _upvotes, \n\t\t\"Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p\";\n}\n\tbool _isDequeued = getFromDequeued(index) == p;\n\tbool _isExpired = isDequeuedProposalExpired(eGet, p);\n\taddress _approver = approver();\n\trequire !_isProposalApproved; // we assume not approved yet\n\trequire !_isExpired; // we also assume it did not expire\n\t\t\n\tapprove(eF,p,index);\n\t// should check if dequeued right during approve\n\tbool isDequeued_ = getFromDequeued(index) == p;\n\tbool isProposalApproved_ = isApproved(p);\n\tassert isProposalApproved_ => _isDequeued || (!_isDequeued && isDequeued_), \"Cannot approve proposal $p unless $index points to it before approve or during it\"; // index has p\n\tassert isProposalApproved_ => eF.msg.sender == _approver, \"Only approver ${_approver} can approve\";\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "approval_only_if_promoted_and_allowed",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "getFromDequeued",
                "isApproved",
                "isDequeuedProposalExpired",
                "approver"
            ],
            "start_line": 218,
            "end_line": 241,
            "block_hash": "6c8b5c493616cec648c2cdab86c96365"
        }
    },
    {
        "id": "Governance_approved_proposals_invariants_a79b1f78",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Governance.sol",
        "target_function": "getUpvoteRecord/getUpvotes/upvote/vote",
        "text_chunk": "  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n",
        "formal_property": "rule approved_proposals_invariants(method f, uint256 p) filtered { f -> !f.isView } {\n    // the invariant is upvoteInv, defined here\n} \n\ndefinition upvoteInv(uint p, uint w) returns bool \n    = (p != 0 && w > 0) || (p == 0 && w == 0)\n    ;\nrule no_double_upvote(uint256 p, address u) {\n\tuint256 _upvotes = getUpvotes(p);\n\tuint256 _usersUpvotedProposal = getUpvotedProposal(u);\n\tenv e;\n\trequire e.msg.sender == u && u != 0; // note that the sender is the signer here\n    require accounts.voteSignerToAccount(u) == u;\n\tuint256 lesser; \n    uint256 greater;\n\tupvote(e, p, lesser, greater);\n\tuint256 upvotes_ = getUpvotes(p);\n\t\n    uint voteRecordP;\n    uint voteRecordW;\n    voteRecordP, voteRecordW = getUpvoteRecord(u);\n    require upvoteInv(voteRecordP, voteRecordW);\n\tassert _usersUpvotedProposal == p => upvotes_ <= _upvotes, \n\t\t\"Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "approved_proposals_invariants",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 244,
            "end_line": 244,
            "block_hash": "a79b1f786a4aee991e06ff8e62cd5516"
        }
    },
    {
        "id": "Governance_execute_preconds_52d5f30f",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Governance.sol",
        "target_function": "execute/getVoteTotals/vote",
        "text_chunk": "  function execute(uint256 proposalId, uint256 index) external nonReentrant returns (bool) {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    bool notExpired = proposal.exists();\n    if (notExpired) {\n      require(proposal.isApproved(), \"Proposal not approved\");\n      require(\n        stage == Proposals.Stage.Execution && _isProposalPassing(proposal),\n        \"Proposal not in execution stage or not passing\"\n      );\n      proposal.execute();\n      emit ProposalExecuted(proposalId);\n      deleteDequeuedProposal(proposal, proposalId, index);\n    }\n    return notExpired;\n  }\n\n\n  function getVoteTotals(uint256 proposalId) external view returns (uint256, uint256, uint256) {\n    return proposals[proposalId].getVoteTotals();\n  }\n\n\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n",
        "formal_property": "rule execute_preconds(uint256 p, uint256 index) {\n\t// A proposal should never be executable when there are at least as many no votes as yes votes\n\t// TODO: A proposal should never be executable unless it received a yes:no vote ratio greater than that specified in the constitution\n\tenv _e;\n\tenv eF;\n\t\n\tuint256 _yes;\n\tuint256 _no;\n\tuint256 _abstain;\n\t_yes, _no, _abstain = getVoteTotals(p);\n\tbool executeRetval = execute@withrevert(eF,p,index);\n\tbool executeReverted = lastReverted;\n\tassert _no >= _yes => (!executeRetval || executeReverted), \"If there are more no votes than yes votes, then we cannot succeed in executing\";\n\t// TODO: may require to make sure that all constitutions demand at least majority\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "execute_preconds",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "vote",
                "getVoteTotals"
            ],
            "start_line": 271,
            "end_line": 287,
            "block_hash": "52d5f30f2207cb32f795d2c230dc7b5a"
        }
    },
    {
        "id": "Governance_modifying_stageDuration_5433b59c",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Governance.sol",
        "target_function": "getUpvoteRecord/getUpvotes/initialize/setExecutionStageDuration/setReferendumStageDuration/upvote/vote",
        "text_chunk": "  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n\n  function initialize(\n    address registryAddress,\n    address _approver,\n    uint256 _concurrentProposals,\n    uint256 _minDeposit,\n    uint256 _queueExpiry,\n    uint256 _dequeueFrequency,\n    uint256 referendumStageDuration,\n    uint256 executionStageDuration,\n    uint256 participationBaseline,\n    uint256 participationFloor,\n    uint256 baselineUpdateFactor,\n    uint256 baselineQuorumFactor\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setApprover(_approver);\n    setConcurrentProposals(_concurrentProposals);\n    setMinDeposit(_minDeposit);\n    setQueueExpiry(_queueExpiry);\n    setDequeueFrequency(_dequeueFrequency);\n    setReferendumStageDuration(referendumStageDuration);\n    setExecutionStageDuration(executionStageDuration);\n    setParticipationBaseline(participationBaseline);\n    setParticipationFloor(participationFloor);\n    setBaselineUpdateFactor(baselineUpdateFactor);\n    setBaselineQuorumFactor(baselineQuorumFactor);\n    // solhint-disable-next-line not-rely-on-time\n    lastDequeue = now;\n  }\n\n\n  function setExecutionStageDuration(uint256 executionStageDuration) public onlyOwner {\n    require(executionStageDuration != 0, \"Duration must be larger than 0\");\n    require(executionStageDuration != stageDurations.execution, \"Duration unchanged\");\n    stageDurations.execution = executionStageDuration;\n    emit ExecutionStageDurationSet(executionStageDuration);\n  }\n\n\n  function setReferendumStageDuration(uint256 referendumStageDuration) public onlyOwner {\n    require(referendumStageDuration != 0, \"Duration must be larger than 0\");\n    require(referendumStageDuration != stageDurations.referendum, \"Duration unchanged\");\n    stageDurations.referendum = referendumStageDuration;\n    emit ReferendumStageDurationSet(referendumStageDuration);\n  }\n\n\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n",
        "formal_property": "rule modifying_stageDuration(method f) filtered { f -> \n    !f.isView \n    // the invariant is upvoteInv, defined here\n} \n\ndefinition upvoteInv(uint p, uint w) returns bool \n    = (p != 0 && w > 0) || (p == 0 && w == 0)\n    ;\nrule no_double_upvote(uint256 p, address u) {\n\tuint256 _upvotes = getUpvotes(p);\n\tuint256 _usersUpvotedProposal = getUpvotedProposal(u);\n\tenv e;\n\trequire e.msg.sender == u && u != 0; // note that the sender is the signer here\n    require accounts.voteSignerToAccount(u) == u;\n\tuint256 lesser; \n    uint256 greater;\n\tupvote(e, p, lesser, greater);\n\tuint256 upvotes_ = getUpvotes(p);\n\t\n    uint voteRecordP;\n    uint voteRecordW;\n    voteRecordP, voteRecordW = getUpvoteRecord(u);\n    require upvoteInv(voteRecordP, voteRecordW);\n\tassert _usersUpvotedProposal == p => upvotes_ <= _upvotes, \n\t\t\"Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p\";\n}\n    && f.selector != initialize(address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256).selector\n    && f.selector != setApprovalStageDuration(uint256).selector\n    && f.selector != setExecutionStageDuration(uint256).selector\n    && f.selector != setReferendumStageDuration(uint256).selector\n} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "modifying_stageDuration",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 291,
            "end_line": 297,
            "block_hash": "5433b59c8679606b1070439b6f712ebe"
        }
    },
    {
        "id": "Governance_can_add_to_queue_3a238569",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Governance.sol",
        "target_function": "getUpvoteRecord/getUpvotes/propose/upvote/vote",
        "text_chunk": "  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n\n  function propose(\n    uint256[] calldata values,\n    address[] calldata destinations,\n    bytes calldata data,\n    uint256[] calldata dataLengths,\n    string calldata descriptionUrl\n  ) external payable returns (uint256) {\n    dequeueProposalsIfReady();\n    require(msg.value >= minDeposit, \"Too small deposit\");\n\n    proposalCount = proposalCount.add(1);\n    Proposals.Proposal storage proposal = proposals[proposalCount];\n    proposal.make(values, destinations, data, dataLengths, msg.sender, msg.value);\n    proposal.setDescriptionUrl(descriptionUrl);\n    queue.push(proposalCount);\n    // solhint-disable-next-line not-rely-on-time\n    emit ProposalQueued(proposalCount, msg.sender, proposal.transactions.length, msg.value, now);\n    return proposalCount;\n  }\n\n\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n",
        "formal_property": "rule can_add_to_queue(method f) filtered { f -> \n    !f.isView\n    // the invariant is upvoteInv, defined here\n} \n\ndefinition upvoteInv(uint p, uint w) returns bool \n    = (p != 0 && w > 0) || (p == 0 && w == 0)\n    ;\nrule no_double_upvote(uint256 p, address u) {\n\tuint256 _upvotes = getUpvotes(p);\n\tuint256 _usersUpvotedProposal = getUpvotedProposal(u);\n\tenv e;\n\trequire e.msg.sender == u && u != 0; // note that the sender is the signer here\n    require accounts.voteSignerToAccount(u) == u;\n\tuint256 lesser; \n    uint256 greater;\n\tupvote(e, p, lesser, greater);\n\tuint256 upvotes_ = getUpvotes(p);\n\t\n    uint voteRecordP;\n    uint voteRecordW;\n    voteRecordP, voteRecordW = getUpvoteRecord(u);\n    require upvoteInv(voteRecordP, voteRecordW);\n\tassert _usersUpvotedProposal == p => upvotes_ <= _upvotes, \n\t\t\"Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p\";\n}\n    && f.selector != propose(uint256[],address[],bytes,uint256[],string).selector\n} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "can_add_to_queue",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 311,
            "end_line": 314,
            "block_hash": "3a238569cb33458cbc45f86680090d5e"
        }
    },
    {
        "id": "Governance_constitution_change_68b66e46",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Governance.sol",
        "target_function": "getUpvoteRecord/getUpvotes/upvote/vote",
        "text_chunk": "  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n",
        "formal_property": "rule constitution_change(method f) filtered { f -> \n    !f.isView\n    // the invariant is upvoteInv, defined here\n} \n\ndefinition upvoteInv(uint p, uint w) returns bool \n    = (p != 0 && w > 0) || (p == 0 && w == 0)\n    ;\nrule no_double_upvote(uint256 p, address u) {\n\tuint256 _upvotes = getUpvotes(p);\n\tuint256 _usersUpvotedProposal = getUpvotedProposal(u);\n\tenv e;\n\trequire e.msg.sender == u && u != 0; // note that the sender is the signer here\n    require accounts.voteSignerToAccount(u) == u;\n\tuint256 lesser; \n    uint256 greater;\n\tupvote(e, p, lesser, greater);\n\tuint256 upvotes_ = getUpvotes(p);\n\t\n    uint voteRecordP;\n    uint voteRecordW;\n    voteRecordP, voteRecordW = getUpvoteRecord(u);\n    require upvoteInv(voteRecordP, voteRecordW);\n\tassert _usersUpvotedProposal == p => upvotes_ <= _upvotes, \n\t\t\"Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p\";\n}\n        && f.selector != setConstitution(address,bytes4,uint256).selector\n} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "constitution_change",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 325,
            "end_line": 328,
            "block_hash": "68b66e4697230045d45b33e1baa8f737"
        }
    },
    {
        "id": "Governance_only_initializer_changes_initialized_field_bd84e1ef",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Governance.sol",
        "target_function": "getUpvoteRecord/getUpvotes/upvote/vote",
        "text_chunk": "  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n",
        "formal_property": "rule only_initializer_changes_initialized_field(method f) filtered { f -> !f.isView } {\n    // the invariant is upvoteInv, defined here\n} \n\ndefinition upvoteInv(uint p, uint w) returns bool \n    = (p != 0 && w > 0) || (p == 0 && w == 0)\n    ;\nrule no_double_upvote(uint256 p, address u) {\n\tuint256 _upvotes = getUpvotes(p);\n\tuint256 _usersUpvotedProposal = getUpvotedProposal(u);\n\tenv e;\n\trequire e.msg.sender == u && u != 0; // note that the sender is the signer here\n    require accounts.voteSignerToAccount(u) == u;\n\tuint256 lesser; \n    uint256 greater;\n\tupvote(e, p, lesser, greater);\n\tuint256 upvotes_ = getUpvotes(p);\n\t\n    uint voteRecordP;\n    uint voteRecordW;\n    voteRecordP, voteRecordW = getUpvoteRecord(u);\n    require upvoteInv(voteRecordP, voteRecordW);\n\tassert _usersUpvotedProposal == p => upvotes_ <= _upvotes, \n\t\t\"Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "only_initializer_changes_initialized_field",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 350,
            "end_line": 350,
            "block_hash": "bd84e1eff3eaa606d6be1019fa76224f"
        }
    },
    {
        "id": "Governance_check_initializer_b69a2659",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Governance.sol",
        "target_function": "getUpvoteRecord/getUpvotes/initialize/upvote/vote",
        "text_chunk": "  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n\n  function initialize(\n    address registryAddress,\n    address _approver,\n    uint256 _concurrentProposals,\n    uint256 _minDeposit,\n    uint256 _queueExpiry,\n    uint256 _dequeueFrequency,\n    uint256 referendumStageDuration,\n    uint256 executionStageDuration,\n    uint256 participationBaseline,\n    uint256 participationFloor,\n    uint256 baselineUpdateFactor,\n    uint256 baselineQuorumFactor\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setApprover(_approver);\n    setConcurrentProposals(_concurrentProposals);\n    setMinDeposit(_minDeposit);\n    setQueueExpiry(_queueExpiry);\n    setDequeueFrequency(_dequeueFrequency);\n    setReferendumStageDuration(referendumStageDuration);\n    setExecutionStageDuration(executionStageDuration);\n    setParticipationBaseline(participationBaseline);\n    setParticipationFloor(participationFloor);\n    setBaselineUpdateFactor(baselineUpdateFactor);\n    setBaselineQuorumFactor(baselineQuorumFactor);\n    // solhint-disable-next-line not-rely-on-time\n    lastDequeue = now;\n  }\n\n\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n",
        "formal_property": "rule check_initializer {\n\tenv _e;\n\tenv eF;\n\tenv e_;\n\t\n\tbool _isInitialized = initialized(_e);\n    // the invariant is upvoteInv, defined here\n} \n\ndefinition upvoteInv(uint p, uint w) returns bool \n    = (p != 0 && w > 0) || (p == 0 && w == 0)\n    ;\nrule no_double_upvote(uint256 p, address u) {\n\tuint256 _upvotes = getUpvotes(p);\n\tuint256 _usersUpvotedProposal = getUpvotedProposal(u);\n\tenv e;\n\trequire e.msg.sender == u && u != 0; // note that the sender is the signer here\n    require accounts.voteSignerToAccount(u) == u;\n\tuint256 lesser; \n    uint256 greater;\n\tupvote(e, p, lesser, greater);\n\tuint256 upvotes_ = getUpvotes(p);\n    uint voteRecordP;\n    uint voteRecordW;\n    voteRecordP, voteRecordW = getUpvoteRecord(u);\n    require upvoteInv(voteRecordP, voteRecordW);\n\tassert _usersUpvotedProposal == p => upvotes_ <= _upvotes, \n\t\t\"Upvotes increased from ${_upvotes} to ${upvotes_} even though upvoted by user $u who already upvoted $p\";\n}\n\tcalldataarg arg;\n\tinitialize@withrevert(eF,arg);\n\tbool successInit = !lastReverted;\n\tbool isInitialized_ = initialized(e_);\n\tassert _isInitialized => !successInit, \"initialize() must revert if already initialized\";\n\tassert successInit => isInitialized_, \"When initialize() succeeds, must set initialization field to true\";\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "check_initializer",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 366,
            "end_line": 381,
            "block_hash": "b69a265934c9d37d938e9dd4c203626d"
        }
    },
    {
        "id": "Accounts_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "Accounts.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is\n  IAccounts,\n  ICeloVersionedContract,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct SignerAuthorization {\n    bool started;\n    bool completed;\n  }\n\n  struct Account {\n    bool exists;\n    // [Deprecated] Each account may authorize signing keys to use for voting,\n    // validating or attestation. These keys may not be keys of other accounts,\n    // and may not be authorized by any other account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  struct PaymentDelegation {\n    // Address that should receive a fraction of validator payments.\n    address beneficiary;\n    // Fraction of payment to delegate to `beneficiary`.\n    FixidityLib.Fraction fraction;\n  }\n\n  mapping(address => Account) internal accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n  // Default signers by account (replaces the legacy Signers struct on Account)\n  mapping(address => mapping(bytes32 => address)) defaultSigners;\n  // All signers and their roles for a given account\n  // solhint-disable-next-line max-line-length\n  mapping(address => mapping(bytes32 => mapping(address => SignerAuthorization))) signerAuthorizations;\n\n  bytes32 public constant EIP712_AUTHORIZE_SIGNER_TYPEHASH = keccak256(\n    \"AuthorizeSigner(address account,address signer,bytes32 role)\"\n  );\n  bytes32 public eip712DomainSeparator;\n\n  // A per-account list of CIP8 storage roots, bypassing CIP3.\n  mapping(address => bytes[]) public offchainStorageRoots;\n\n  // Optional per-account validator payment delegation information.\n  mapping(address => PaymentDelegation) internal paymentDelegations;\n\n  bytes32 constant ValidatorSigner = keccak256(abi.encodePacked(\"celo.org/core/validator\"));\n  bytes32 constant AttestationSigner = keccak256(abi.encodePacked(\"celo.org/core/attestation\"));\n  bytes32 constant VoteSigner = keccak256(abi.encodePacked(\"celo.org/core/vote\"));\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event SignerAuthorized(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationStarted(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationCompleted(address indexed account, address signer, bytes32 indexed role);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event IndexedSignerSet(address indexed account, address signer, bytes32 role);\n  event IndexedSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event DefaultSignerSet(address indexed account, address signer, bytes32 role);\n  event DefaultSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event LegacySignerSet(address indexed account, address signer, bytes32 role);\n  event LegacySignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event SignerRemoved(address indexed account, address oldSigner, bytes32 indexed role);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n  event OffchainStorageRootAdded(address indexed account, bytes url);\n  event OffchainStorageRootRemoved(address indexed account, bytes url, uint256 index);\n  event PaymentDelegationSet(address indexed beneficiary, uint256 fraction);\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return Storage version of the contract.\n   * @return Major version of the contract.\n   * @return Minor version of the contract.\n   * @return Patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 4, 1);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setEip712DomainSeparator();\n  }\n\n  /**\n   * @notice Sets the EIP712 domain separator for the Celo Accounts abstraction.\n   */\n  function setEip712DomainSeparator() public {\n    uint256 chainId;\n    assembly {\n      chainId := chainid\n    }\n\n    eip712DomainSeparator = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(\"Celo Core Contracts\")),\n        keccak256(\"1.0\"),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),\n      \"Account already exists or address is an authorized signer for another account\"\n    );\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Register with createAccount to set account name\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Adds a new CIP8 storage root.\n   * @param url The URL pointing to the offchain storage root.\n   */\n  function addStorageRoot(bytes calldata url) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    offchainStorageRoots[msg.sender].push(url);\n    emit OffchainStorageRootAdded(msg.sender, url);\n  }\n\n  /**\n   * @notice Removes a CIP8 storage root.\n   * @param index The index of the storage root to be removed in the account's\n   * list of storage roots.\n   * @dev The order of storage roots may change after this operation (the last\n   * storage root will be moved to `index`), be aware of this if removing\n   * multiple storage roots at a time.\n   */\n  function removeStorageRoot(uint256 index) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(index < offchainStorageRoots[msg.sender].length, \"Invalid storage root index\");\n    uint256 lastIndex = offchainStorageRoots[msg.sender].length - 1;\n    bytes memory url = offchainStorageRoots[msg.sender][index];\n    offchainStorageRoots[msg.sender][index] = offchainStorageRoots[msg.sender][lastIndex];\n    offchainStorageRoots[msg.sender].length--;\n    emit OffchainStorageRootRemoved(msg.sender, url, index);\n  }\n\n  /**\n   * @notice Returns the full list of offchain storage roots for an account.\n   * @param account The account whose storage roots to return.\n   * @return Concatenated storage root URLs.\n   * @return Lengths of storage root URLs.\n   */\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n  /**\n   * @notice Sets validator payment delegation settings.\n   * @param beneficiary The address that should receive a portion of validator\n   * payments.\n   * @param fraction The fraction of the validator's payment that should be\n   * diverted to `beneficiary` every epoch, given as FixidityLib value. Must not\n   * be greater than 1.\n   * @dev Use `deletePaymentDelegation` to unset the payment delegation.\n   */\n  function setPaymentDelegation(address beneficiary, uint256 fraction) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(beneficiary != address(0), \"Beneficiary cannot be address 0x0\");\n    FixidityLib.Fraction memory f = FixidityLib.wrap(fraction);\n    require(f.lte(FixidityLib.fixed1()), \"Fraction must not be greater than 1\");\n    paymentDelegations[msg.sender] = PaymentDelegation(beneficiary, f);\n    emit PaymentDelegationSet(beneficiary, fraction);\n  }\n\n  /**\n   * @notice Removes a validator's payment delegation by setting benficiary and\n   * fraction to 0.\n   */\n  function deletePaymentDelegation() public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    paymentDelegations[msg.sender] = PaymentDelegation(address(0x0), FixidityLib.wrap(0));\n    emit PaymentDelegationSet(address(0x0), 0);\n  }\n\n  /**\n   * @notice Gets validator payment delegation settings.\n   * @param account Account of the validator.\n   * @return Beneficiary address of payment delegated.\n   * @return Fraction of payment delegated.\n   */\n  function getPaymentDelegation(address account) external view returns (address, uint256) {\n    PaymentDelegation storage delegation = paymentDelegations[account];\n    return (delegation.beneficiary, delegation.fraction.unwrap());\n  }\n\n  /**\n   * @notice Set the indexed signer for a specific role\n   * @param signer the address to set as default\n   * @param role the role to register a default signer for\n   */\n  function setIndexedSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(isNotAccount(signer), \"Cannot authorize account as signer\");\n    require(\n      isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Not a signer for this account\"\n    );\n    require(isSigner(msg.sender, signer, role), \"Must authorize signer before setting as default\");\n\n    Account storage account = accounts[msg.sender];\n    if (isLegacyRole(role)) {\n      if (role == VoteSigner) {\n        account.signers.vote = signer;\n      } else if (role == AttestationSigner) {\n        account.signers.attestation = signer;\n      } else if (role == ValidatorSigner) {\n        account.signers.validator = signer;\n      }\n      emit LegacySignerSet(msg.sender, signer, role);\n    } else {\n      defaultSigners[msg.sender][role] = signer;\n      emit DefaultSignerSet(msg.sender, signer, role);\n    }\n\n    emit IndexedSignerSet(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to act as a signer, for `role`, on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s EIP712 signature over `role`, `msg.sender`\n   *      and `signer`.\n   */\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  function legacyAuthorizeSignerWithSignature(\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) private {\n    authorizeAddress(signer, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Begin the process of authorizing an address to sign on behalf of the account\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   */\n  function authorizeSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register sender with Account.createAccount\");\n    require(\n      isNotAccount(signer) && isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Cannot re-authorize address signer\"\n    );\n\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: false\n    });\n    emit SignerAuthorizationStarted(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Finish the process of authorizing an address to sign on behalf of the account.\n   * @param account The address of account that authorized signing.\n   * @param role The role to finish authorizing for.\n   */\n  function completeSignerAuthorization(address account, bytes32 role) public {\n    require(\n      isAccount(account),\n      \"Unknown Account: Address that authorized signing must be a registered Account\"\n    );\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSignerForAnotherAccount(account, msg.sender),\n      \"Cannot re-authorize address signer\"\n    );\n    require(\n      signerAuthorizations[account][role][msg.sender].started == true,\n      \"Signer authorization not started\"\n    );\n\n    authorizedBy[msg.sender] = account;\n    signerAuthorizations[account][role][msg.sender].completed = true;\n    emit SignerAuthorizationCompleted(account, msg.sender, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the legacy signer for role\n   * @param _account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isLegacySigner(address _account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    Account storage account = accounts[_account];\n    if (role == ValidatorSigner && account.signers.validator == signer) {\n      return true;\n    } else if (role == AttestationSigner && account.signers.attestation == signer) {\n      return true;\n    } else if (role == VoteSigner && account.signers.vote == signer) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the default signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isDefaultSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return defaultSigners[account][role] == signer;\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as an indexed signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isIndexedSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return\n      isLegacyRole(role)\n        ? isLegacySigner(account, signer, role)\n        : isDefaultSigner(account, signer, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as a signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isSigner(address account, address signer, bytes32 role) public view returns (bool) {\n    return\n      isLegacySigner(account, signer, role) ||\n      (signerAuthorizations[account][role][signer].completed && authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Removes the signer for a default role.\n   * @param role The role that has been authorized.\n   */\n  function removeDefaultSigner(bytes32 role) public {\n    address signer = defaultSigners[msg.sender][role];\n    defaultSigners[msg.sender][role] = address(0);\n    emit DefaultSignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Remove one of the Validator, Attestation or\n   * Vote signers from an account. Should only be called from\n   * methods that check the role is a legacy signer.\n   * @param role The role that has been authorized.\n   */\n  function removeLegacySigner(bytes32 role) private {\n    Account storage account = accounts[msg.sender];\n\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n      account.signers.validator = address(0);\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n      account.signers.attestation = address(0);\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n      account.signers.vote = address(0);\n    }\n    emit LegacySignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized and indexed signer\n   * for a specific role\n   * @param role The role of the signer.\n   */\n  function removeIndexedSigner(bytes32 role) public {\n    address oldSigner = getIndexedSigner(msg.sender, role);\n    isLegacyRole(role) ? removeLegacySigner(role) : removeDefaultSigner(role);\n\n    emit IndexedSignerRemoved(msg.sender, oldSigner, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized signer for a specific role and\n   * if the signer is indexed, remove that as well.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function removeSigner(address signer, bytes32 role) public {\n    if (isIndexedSigner(msg.sender, signer, role)) {\n      removeIndexedSigner(role);\n    }\n\n    delete signerAuthorizations[msg.sender][role][signer];\n    emit SignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized vote signer for the account.\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeVoteSigner() public {\n    address signer = getLegacySigner(msg.sender, VoteSigner);\n    removeSigner(signer, VoteSigner);\n    emit VoteSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized validator signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeValidatorSigner() public {\n    address signer = getLegacySigner(msg.sender, ValidatorSigner);\n    removeSigner(signer, ValidatorSigner);\n    emit ValidatorSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized attestation signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeAttestationSigner() public {\n    address signer = getLegacySigner(msg.sender, AttestationSigner);\n    removeSigner(signer, AttestationSigner);\n    emit AttestationSignerRemoved(msg.sender, signer);\n  }\n\n  function signerToAccountWithRole(address signer, bytes32 role) internal view returns (address) {\n    address account = authorizedBy[signer];\n    if (account != address(0)) {\n      require(isSigner(account, signer, role), \"not active authorized signer for role\");\n      return account;\n    }\n\n    require(isAccount(signer), \"Must first register address with Account.createAccount\");\n    return signer;\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account that the signer is authorized to attest for.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account that signer is authorized to validate for.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account that signer is authorized to vote for.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Checks whether the role is one of Vote, Validator or Attestation\n   * @param role The role to check\n   */\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n\n  /**\n   * @notice Returns the legacy signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param _account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n  /**\n   * @notice Returns the default signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n  /**\n   * @notice Returns the indexed signer for the specified account and role.\n   * If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for one of the legacy roles\n   */\n  function hasLegacySigner(address account, bytes32 role) public view returns (bool) {\n    return getLegacySigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for a role\n   */\n  function hasDefaultSigner(address account, bytes32 role) public view returns (bool) {\n    return getDefaultSigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for the role\n   */\n  function hasIndexedSigner(address account, bytes32 role) public view returns (bool) {\n    return isLegacyRole(role) ? hasLegacySigner(account, role) : hasDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Checks whether or not the account has a signer\n   * registered for the plaintext role.\n   * @dev See `hasIndexedSigner` for more gas efficient call.\n   */\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated vote signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated vote signer.\n   */\n  function hasAuthorizedVoteSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated validator signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated validator signer.\n   */\n  function hasAuthorizedValidatorSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated attestation signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated attestation signer.\n   */\n  function hasAuthorizedAttestationSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return The length of each string in bytes.\n   * @return All strings concatenated.\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has not been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Check if `signer` has not been authorized, and if it has been previously\n   *         authorized that it was authorized by `account`.\n   * @param account The authorizing account address.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSignerForAnotherAccount(address account, address signer)\n    internal\n    view\n    returns (bool)\n  {\n    return (authorizedBy[signer] == address(0) || authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Authorizes some role of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `authorized`'s signature on `msg.sender`.\n   */\n  function authorizeAddress(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Returns the address that signed the provided role authorization.\n   * @param account The `account` property signed over in the EIP712 signature\n   * @param signer The `signer` property signed over in the EIP712 signature\n   * @param role The `role` property signed over in the EIP712 signature\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The address that signed the provided role authorization.\n   */\n  function getRoleAuthorizationSigner(\n    address account,\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 structHash = keccak256(\n      abi.encode(EIP712_AUTHORIZE_SIGNER_TYPEHASH, account, signer, role)\n    );\n    return Signatures.getSignerOfTypedDataHash(eip712DomainSeparator, structHash, v, r, s);\n  }\n\n  /**\n   * @notice Authorizes a role of `msg.sender`'s account to another address (`authorized`).\n   * @param authorized The address to authorize.\n   * @param role The role to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that this signature is EIP712 compliant over the authorizing `account`\n   * (`msg.sender`), `signer` (`authorized`) and `role`.\n   */\n  function authorizeAddressWithRole(address authorized, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    private\n  {\n    address signer = getRoleAuthorizationSigner(msg.sender, authorized, role, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Authorizes an address to `msg.sender`'s account\n   * @param authorized The address to authorize.\n   * @dev Fails if the address is already authorized for another account or is an account itself.\n   */\n  function authorize(address authorized) private {\n    require(\n      isAccount(msg.sender),\n      \"Unknown account: sender must register with createAccount first\"\n    );\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSignerForAnotherAccount(msg.sender, authorized),\n      \"Cannot re-authorize address or locked gold account for another account\"\n    );\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "getVersionNumber",
                "initialize",
                "setEip712DomainSeparator",
                "setAccount",
                "createAccount",
                "setName",
                "setWalletAddress",
                "setAccountDataEncryptionKey",
                "setMetadataURL",
                "addStorageRoot",
                "removeStorageRoot",
                "getOffchainStorageRoots",
                "setPaymentDelegation",
                "deletePaymentDelegation",
                "getPaymentDelegation",
                "setIndexedSigner",
                "authorizeSignerWithSignature",
                "legacyAuthorizeSignerWithSignature",
                "authorizeVoteSigner",
                "authorizeValidatorSigner",
                "authorizeValidatorSignerWithPublicKey",
                "authorizeValidatorSignerWithKeys",
                "authorizeAttestationSigner",
                "authorizeSigner",
                "completeSignerAuthorization",
                "isLegacySigner",
                "isDefaultSigner",
                "isIndexedSigner",
                "isSigner",
                "removeDefaultSigner",
                "removeLegacySigner",
                "removeIndexedSigner",
                "removeSigner",
                "removeVoteSigner",
                "removeValidatorSigner",
                "removeAttestationSigner",
                "signerToAccountWithRole",
                "attestationSignerToAccount",
                "validatorSignerToAccount",
                "voteSignerToAccount",
                "signerToAccount",
                "isLegacyRole",
                "getLegacySigner",
                "getDefaultSigner",
                "getIndexedSigner",
                "getVoteSigner",
                "getValidatorSigner",
                "getAttestationSigner",
                "hasLegacySigner",
                "hasDefaultSigner",
                "hasIndexedSigner",
                "hasAuthorizedSigner",
                "hasAuthorizedVoteSigner",
                "hasAuthorizedValidatorSigner",
                "hasAuthorizedAttestationSigner",
                "getName",
                "getMetadataURL",
                "batchGetMetadataURL",
                "getDataEncryptionKey",
                "getWalletAddress",
                "isAccount",
                "isNotAccount",
                "isAuthorizedSigner",
                "isNotAuthorizedSigner",
                "isNotAuthorizedSignerForAnotherAccount",
                "authorizeAddress",
                "getRoleAuthorizationSigner",
                "authorizeAddressWithRole",
                "authorize"
            ],
            "state_variables": [
                "metadataURL",
                "offchainStorageRoots",
                "beneficiary",
                "authorizedBy",
                "completed",
                "attestation",
                "name",
                "walletAddress",
                "dataEncryptionKey",
                "vote",
                "exists",
                "chainId",
                "eip712DomainSeparator",
                "accounts",
                "validator",
                "paymentDelegations",
                "signer",
                "started"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "Accounts_account_empty_if_not_exist_e007ab3e",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Accounts.sol",
        "target_function": "getAttestationSigner/getDefaultSigner/getValidatorSigner/getVoteSigner/getWalletAddress/isAccount",
        "text_chunk": "  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n",
        "formal_property": "invariant account_empty_if_not_exist(env e, address x) \n  !isAccount(x) => \n    getWalletAddress(x) == 0 &&\n    _getAttestationSigner(x) == 0 &&\n    _getVoteSigner(x) == 0 &&\n    _getValidatorSigner(x) == 0\n\n/**\n * An address d that is authorized by some account x can not become an account\n */\ninvariant address_cant_be_both_account_and_signer(address x, address d) \n  (x != 0 && d != 0 && x != d && _getAuthorizedBy(d) == x) => \n    (isAccount(x) && !isAccount(d))\n * A current signer d or account x should be authorizedby for legacy roles\ninvariant address_signer_if_authorizedby_legacy(address x, address d) \n  (x != d && x != 0 && d != 0 &&\n  \t(_getAttestationSigner(x) == d || _getVoteSigner(x) == d || _getValidatorSigner(x) == d))\n    \t=> (isAccount(x) && _getAuthorizedBy(d) == x)\n * A current signer d or account x should be authorizedby for new roles\ninvariant address_signer_if_authroizedby_new(address x, address d, bytes32 role)\n\t(x != d && x != 0 && d != 0 &&\n\t\t_getDefaultSigner(x,role) == d)\n\t\t\t=> (isAccount(x) && _getAuthorizedBy(d) == x)\n * Given account x, address d a current signer, then d can not be a current signer of account y\n * (Expensive rule)\n /*\nrule address_cant_be_both_authorizedby_of_two_address(address x, address y, address d, bytes32 r1, bytes32 r2, method f) filtered { f -> !f.isView } { \n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "account_empty_if_not_exist",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "isAccount",
                "_getAuthorizedBy",
                "getWalletAddress",
                "getAttestationSigner",
                "_getAttestationSigner",
                "getVoteSigner",
                "_getVoteSigner",
                "getValidatorSigner",
                "_getValidatorSigner",
                "getDefaultSigner",
                "_getDefaultSigner"
            ],
            "start_line": 35,
            "end_line": 72,
            "block_hash": "e007ab3e7d7d7a0118948426e3af8acf"
        }
    },
    {
        "id": "Accounts_legacyRolesAreNotUsedInNewRoles_38e6f3a0",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Accounts.sol",
        "target_function": "batchGetMetadataURL/getDefaultSigner/getMetadataURL/getOffchainStorageRoots/hasAuthorizedSigner/isLegacyRole",
        "text_chunk": "  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n\n\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n",
        "formal_property": "invariant legacyRolesAreNotUsedInNewRoles(address account, bytes32 role) \n\tisLegacyRole(role) => _getDefaultSigner(account, role) == 0\n\n/**\n * view functions in general should not revert.\n * Some exceptions and more refined revert-characteristics are provided.\n */\nrule viewFunctionsDoNotRevert(method f) filtered { f -> \n\tf.isView \n\t// some functions we ignore, and the reasons:\n\t&& f.selector != hasAuthorizedSigner(address,string).selector // Calldatasize may not match\n\t&& f.selector != batchGetMetadataURL(address[]).selector // Calldatasize may not match\n  // These require an account to exist\n\t&& f.selector != getOffchainStorageRoots(address).selector\n\t&& f.selector != offchainStorageRoots(address,uint256).selector\n} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "legacyRolesAreNotUsedInNewRoles",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "getDefaultSigner",
                "_getDefaultSigner",
                "isLegacyRole"
            ],
            "start_line": 196,
            "end_line": 212,
            "block_hash": "38e6f3a01013b0cca9b780f3973b31ee"
        }
    },
    {
        "id": "Accounts_authorizedByIsNeverReflexive_5b37fffa",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Accounts.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is\n  IAccounts,\n  ICeloVersionedContract,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct SignerAuthorization {\n    bool started;\n    bool completed;\n  }\n\n  struct Account {\n    bool exists;\n    // [Deprecated] Each account may authorize signing keys to use for voting,\n    // validating or attestation. These keys may not be keys of other accounts,\n    // and may not be authorized by any other account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  struct PaymentDelegation {\n    // Address that should receive a fraction of validator payments.\n    address beneficiary;\n    // Fraction of payment to delegate to `beneficiary`.\n    FixidityLib.Fraction fraction;\n  }\n\n  mapping(address => Account) internal accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n  // Default signers by account (replaces the legacy Signers struct on Account)\n  mapping(address => mapping(bytes32 => address)) defaultSigners;\n  // All signers and their roles for a given account\n  // solhint-disable-next-line max-line-length\n  mapping(address => mapping(bytes32 => mapping(address => SignerAuthorization))) signerAuthorizations;\n\n  bytes32 public constant EIP712_AUTHORIZE_SIGNER_TYPEHASH = keccak256(\n    \"AuthorizeSigner(address account,address signer,bytes32 role)\"\n  );\n  bytes32 public eip712DomainSeparator;\n\n  // A per-account list of CIP8 storage roots, bypassing CIP3.\n  mapping(address => bytes[]) public offchainStorageRoots;\n\n  // Optional per-account validator payment delegation information.\n  mapping(address => PaymentDelegation) internal paymentDelegations;\n\n  bytes32 constant ValidatorSigner = keccak256(abi.encodePacked(\"celo.org/core/validator\"));\n  bytes32 constant AttestationSigner = keccak256(abi.encodePacked(\"celo.org/core/attestation\"));\n  bytes32 constant VoteSigner = keccak256(abi.encodePacked(\"celo.org/core/vote\"));\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event SignerAuthorized(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationStarted(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationCompleted(address indexed account, address signer, bytes32 indexed role);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event IndexedSignerSet(address indexed account, address signer, bytes32 role);\n  event IndexedSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event DefaultSignerSet(address indexed account, address signer, bytes32 role);\n  event DefaultSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event LegacySignerSet(address indexed account, address signer, bytes32 role);\n  event LegacySignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event SignerRemoved(address indexed account, address oldSigner, bytes32 indexed role);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n  event OffchainStorageRootAdded(address indexed account, bytes url);\n  event OffchainStorageRootRemoved(address indexed account, bytes url, uint256 index);\n  event PaymentDelegationSet(address indexed beneficiary, uint256 fraction);\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return Storage version of the contract.\n   * @return Major version of the contract.\n   * @return Minor version of the contract.\n   * @return Patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 4, 1);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setEip712DomainSeparator();\n  }\n\n  /**\n   * @notice Sets the EIP712 domain separator for the Celo Accounts abstraction.\n   */\n  function setEip712DomainSeparator() public {\n    uint256 chainId;\n    assembly {\n      chainId := chainid\n    }\n\n    eip712DomainSeparator = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(\"Celo Core Contracts\")),\n        keccak256(\"1.0\"),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),\n      \"Account already exists or address is an authorized signer for another account\"\n    );\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Register with createAccount to set account name\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Adds a new CIP8 storage root.\n   * @param url The URL pointing to the offchain storage root.\n   */\n  function addStorageRoot(bytes calldata url) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    offchainStorageRoots[msg.sender].push(url);\n    emit OffchainStorageRootAdded(msg.sender, url);\n  }\n\n  /**\n   * @notice Removes a CIP8 storage root.\n   * @param index The index of the storage root to be removed in the account's\n   * list of storage roots.\n   * @dev The order of storage roots may change after this operation (the last\n   * storage root will be moved to `index`), be aware of this if removing\n   * multiple storage roots at a time.\n   */\n  function removeStorageRoot(uint256 index) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(index < offchainStorageRoots[msg.sender].length, \"Invalid storage root index\");\n    uint256 lastIndex = offchainStorageRoots[msg.sender].length - 1;\n    bytes memory url = offchainStorageRoots[msg.sender][index];\n    offchainStorageRoots[msg.sender][index] = offchainStorageRoots[msg.sender][lastIndex];\n    offchainStorageRoots[msg.sender].length--;\n    emit OffchainStorageRootRemoved(msg.sender, url, index);\n  }\n\n  /**\n   * @notice Returns the full list of offchain storage roots for an account.\n   * @param account The account whose storage roots to return.\n   * @return Concatenated storage root URLs.\n   * @return Lengths of storage root URLs.\n   */\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n  /**\n   * @notice Sets validator payment delegation settings.\n   * @param beneficiary The address that should receive a portion of validator\n   * payments.\n   * @param fraction The fraction of the validator's payment that should be\n   * diverted to `beneficiary` every epoch, given as FixidityLib value. Must not\n   * be greater than 1.\n   * @dev Use `deletePaymentDelegation` to unset the payment delegation.\n   */\n  function setPaymentDelegation(address beneficiary, uint256 fraction) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(beneficiary != address(0), \"Beneficiary cannot be address 0x0\");\n    FixidityLib.Fraction memory f = FixidityLib.wrap(fraction);\n    require(f.lte(FixidityLib.fixed1()), \"Fraction must not be greater than 1\");\n    paymentDelegations[msg.sender] = PaymentDelegation(beneficiary, f);\n    emit PaymentDelegationSet(beneficiary, fraction);\n  }\n\n  /**\n   * @notice Removes a validator's payment delegation by setting benficiary and\n   * fraction to 0.\n   */\n  function deletePaymentDelegation() public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    paymentDelegations[msg.sender] = PaymentDelegation(address(0x0), FixidityLib.wrap(0));\n    emit PaymentDelegationSet(address(0x0), 0);\n  }\n\n  /**\n   * @notice Gets validator payment delegation settings.\n   * @param account Account of the validator.\n   * @return Beneficiary address of payment delegated.\n   * @return Fraction of payment delegated.\n   */\n  function getPaymentDelegation(address account) external view returns (address, uint256) {\n    PaymentDelegation storage delegation = paymentDelegations[account];\n    return (delegation.beneficiary, delegation.fraction.unwrap());\n  }\n\n  /**\n   * @notice Set the indexed signer for a specific role\n   * @param signer the address to set as default\n   * @param role the role to register a default signer for\n   */\n  function setIndexedSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(isNotAccount(signer), \"Cannot authorize account as signer\");\n    require(\n      isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Not a signer for this account\"\n    );\n    require(isSigner(msg.sender, signer, role), \"Must authorize signer before setting as default\");\n\n    Account storage account = accounts[msg.sender];\n    if (isLegacyRole(role)) {\n      if (role == VoteSigner) {\n        account.signers.vote = signer;\n      } else if (role == AttestationSigner) {\n        account.signers.attestation = signer;\n      } else if (role == ValidatorSigner) {\n        account.signers.validator = signer;\n      }\n      emit LegacySignerSet(msg.sender, signer, role);\n    } else {\n      defaultSigners[msg.sender][role] = signer;\n      emit DefaultSignerSet(msg.sender, signer, role);\n    }\n\n    emit IndexedSignerSet(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to act as a signer, for `role`, on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s EIP712 signature over `role`, `msg.sender`\n   *      and `signer`.\n   */\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  function legacyAuthorizeSignerWithSignature(\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) private {\n    authorizeAddress(signer, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Begin the process of authorizing an address to sign on behalf of the account\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   */\n  function authorizeSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register sender with Account.createAccount\");\n    require(\n      isNotAccount(signer) && isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Cannot re-authorize address signer\"\n    );\n\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: false\n    });\n    emit SignerAuthorizationStarted(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Finish the process of authorizing an address to sign on behalf of the account.\n   * @param account The address of account that authorized signing.\n   * @param role The role to finish authorizing for.\n   */\n  function completeSignerAuthorization(address account, bytes32 role) public {\n    require(\n      isAccount(account),\n      \"Unknown Account: Address that authorized signing must be a registered Account\"\n    );\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSignerForAnotherAccount(account, msg.sender),\n      \"Cannot re-authorize address signer\"\n    );\n    require(\n      signerAuthorizations[account][role][msg.sender].started == true,\n      \"Signer authorization not started\"\n    );\n\n    authorizedBy[msg.sender] = account;\n    signerAuthorizations[account][role][msg.sender].completed = true;\n    emit SignerAuthorizationCompleted(account, msg.sender, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the legacy signer for role\n   * @param _account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isLegacySigner(address _account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    Account storage account = accounts[_account];\n    if (role == ValidatorSigner && account.signers.validator == signer) {\n      return true;\n    } else if (role == AttestationSigner && account.signers.attestation == signer) {\n      return true;\n    } else if (role == VoteSigner && account.signers.vote == signer) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the default signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isDefaultSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return defaultSigners[account][role] == signer;\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as an indexed signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isIndexedSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return\n      isLegacyRole(role)\n        ? isLegacySigner(account, signer, role)\n        : isDefaultSigner(account, signer, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as a signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isSigner(address account, address signer, bytes32 role) public view returns (bool) {\n    return\n      isLegacySigner(account, signer, role) ||\n      (signerAuthorizations[account][role][signer].completed && authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Removes the signer for a default role.\n   * @param role The role that has been authorized.\n   */\n  function removeDefaultSigner(bytes32 role) public {\n    address signer = defaultSigners[msg.sender][role];\n    defaultSigners[msg.sender][role] = address(0);\n    emit DefaultSignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Remove one of the Validator, Attestation or\n   * Vote signers from an account. Should only be called from\n   * methods that check the role is a legacy signer.\n   * @param role The role that has been authorized.\n   */\n  function removeLegacySigner(bytes32 role) private {\n    Account storage account = accounts[msg.sender];\n\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n      account.signers.validator = address(0);\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n      account.signers.attestation = address(0);\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n      account.signers.vote = address(0);\n    }\n    emit LegacySignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized and indexed signer\n   * for a specific role\n   * @param role The role of the signer.\n   */\n  function removeIndexedSigner(bytes32 role) public {\n    address oldSigner = getIndexedSigner(msg.sender, role);\n    isLegacyRole(role) ? removeLegacySigner(role) : removeDefaultSigner(role);\n\n    emit IndexedSignerRemoved(msg.sender, oldSigner, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized signer for a specific role and\n   * if the signer is indexed, remove that as well.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function removeSigner(address signer, bytes32 role) public {\n    if (isIndexedSigner(msg.sender, signer, role)) {\n      removeIndexedSigner(role);\n    }\n\n    delete signerAuthorizations[msg.sender][role][signer];\n    emit SignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized vote signer for the account.\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeVoteSigner() public {\n    address signer = getLegacySigner(msg.sender, VoteSigner);\n    removeSigner(signer, VoteSigner);\n    emit VoteSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized validator signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeValidatorSigner() public {\n    address signer = getLegacySigner(msg.sender, ValidatorSigner);\n    removeSigner(signer, ValidatorSigner);\n    emit ValidatorSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized attestation signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeAttestationSigner() public {\n    address signer = getLegacySigner(msg.sender, AttestationSigner);\n    removeSigner(signer, AttestationSigner);\n    emit AttestationSignerRemoved(msg.sender, signer);\n  }\n\n  function signerToAccountWithRole(address signer, bytes32 role) internal view returns (address) {\n    address account = authorizedBy[signer];\n    if (account != address(0)) {\n      require(isSigner(account, signer, role), \"not active authorized signer for role\");\n      return account;\n    }\n\n    require(isAccount(signer), \"Must first register address with Account.createAccount\");\n    return signer;\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account that the signer is authorized to attest for.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account that signer is authorized to validate for.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account that signer is authorized to vote for.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Checks whether the role is one of Vote, Validator or Attestation\n   * @param role The role to check\n   */\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n\n  /**\n   * @notice Returns the legacy signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param _account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n  /**\n   * @notice Returns the default signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n  /**\n   * @notice Returns the indexed signer for the specified account and role.\n   * If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for one of the legacy roles\n   */\n  function hasLegacySigner(address account, bytes32 role) public view returns (bool) {\n    return getLegacySigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for a role\n   */\n  function hasDefaultSigner(address account, bytes32 role) public view returns (bool) {\n    return getDefaultSigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for the role\n   */\n  function hasIndexedSigner(address account, bytes32 role) public view returns (bool) {\n    return isLegacyRole(role) ? hasLegacySigner(account, role) : hasDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Checks whether or not the account has a signer\n   * registered for the plaintext role.\n   * @dev See `hasIndexedSigner` for more gas efficient call.\n   */\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated vote signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated vote signer.\n   */\n  function hasAuthorizedVoteSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated validator signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated validator signer.\n   */\n  function hasAuthorizedValidatorSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated attestation signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated attestation signer.\n   */\n  function hasAuthorizedAttestationSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return The length of each string in bytes.\n   * @return All strings concatenated.\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has not been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Check if `signer` has not been authorized, and if it has been previously\n   *         authorized that it was authorized by `account`.\n   * @param account The authorizing account address.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSignerForAnotherAccount(address account, address signer)\n    internal\n    view\n    returns (bool)\n  {\n    return (authorizedBy[signer] == address(0) || authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Authorizes some role of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `authorized`'s signature on `msg.sender`.\n   */\n  function authorizeAddress(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Returns the address that signed the provided role authorization.\n   * @param account The `account` property signed over in the EIP712 signature\n   * @param signer The `signer` property signed over in the EIP712 signature\n   * @param role The `role` property signed over in the EIP712 signature\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The address that signed the provided role authorization.\n   */\n  function getRoleAuthorizationSigner(\n    address account,\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 structHash = keccak256(\n      abi.encode(EIP712_AUTHORIZE_SIGNER_TYPEHASH, account, signer, role)\n    );\n    return Signatures.getSignerOfTypedDataHash(eip712DomainSeparator, structHash, v, r, s);\n  }\n\n  /**\n   * @notice Authorizes a role of `msg.sender`'s account to another address (`authorized`).\n   * @param authorized The address to authorize.\n   * @param role The role to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that this signature is EIP712 compliant over the authorizing `account`\n   * (`msg.sender`), `signer` (`authorized`) and `role`.\n   */\n  function authorizeAddressWithRole(address authorized, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    private\n  {\n    address signer = getRoleAuthorizationSigner(msg.sender, authorized, role, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Authorizes an address to `msg.sender`'s account\n   * @param authorized The address to authorize.\n   * @dev Fails if the address is already authorized for another account or is an account itself.\n   */\n  function authorize(address authorized) private {\n    require(\n      isAccount(msg.sender),\n      \"Unknown account: sender must register with createAccount first\"\n    );\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSignerForAnotherAccount(msg.sender, authorized),\n      \"Cannot re-authorize address or locked gold account for another account\"\n    );\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}\n",
        "formal_property": "invariant authorizedByIsNeverReflexive(address a)\n\ta != 0 => _getAuthorizedBy(a) != a\n\n/**\n * If we set signerAuthroization to be completed, it means the signer is marked as authorizedBy the account.\n * The other direction may not be correct because authorizedBy is persistent while signer authorizations can be removed. \n */\ninvariant mustHaveAuthorizedByIfCompletedSignerAuthorization(address account, bytes32 role, address signer) \n\taccount != 0 => (isCompletedSignerAuthorization(account, role, signer) => _getAuthorizedBy(signer) == account)\n * For signerAuthorization, a signer can only appear as a signer of a single account.\ninvariant noMultipleAccountsPerSignerInARole(address account, address account2, bytes32 role, bytes32 role2, address signer)\n\taccount != 0 && account2 != 0\n\t\t=> (isCompletedSignerAuthorization(account, role, signer) && isCompletedSignerAuthorization(account2, role2, signer) \n\t\t\t=> account == account2) {\n\t\n\tpreserved {\n\t\trequireInvariant mustHaveAuthorizedByIfCompletedSignerAuthorization(account, role, signer);\n\t\trequireInvariant mustHaveAuthorizedByIfCompletedSignerAuthorization(account2, role2, signer);\n\t}\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "authorizedByIsNeverReflexive",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "_getAuthorizedBy",
                "isCompletedSignerAuthorization"
            ],
            "start_line": 263,
            "end_line": 285,
            "block_hash": "5b37fffa2117e0f95df799da60c427b0"
        }
    },
    {
        "id": "Accounts_accountToSignerAndInverseVote_aef3833f",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Accounts.sol",
        "target_function": "getVoteSigner/signerToAccount/voteSignerToAccount",
        "text_chunk": "  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n",
        "formal_property": "invariant accountToSignerAndInverseVote(address a, address s, bytes32 r)\n\tr == _getVoteRole() => (s == getVoteSigner(a) => voteSignerToAccount(s) == a)\n{\n\t\tpreserved {\n\t\t\trequire a != s;\n\t\t}\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "accountToSignerAndInverseVote",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "getVoteSigner",
                "voteSignerToAccount",
                "_getVoteRole"
            ],
            "start_line": 436,
            "end_line": 442,
            "block_hash": "aef3833fe58239c376185c06674cb25d"
        }
    },
    {
        "id": "Accounts_accountToSignerAndInverseValidator_77280ded",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Accounts.sol",
        "target_function": "getValidatorSigner/signerToAccount/validatorSignerToAccount",
        "text_chunk": "  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n",
        "formal_property": "invariant accountToSignerAndInverseValidator(address a, address s, bytes32 r)\t\n\tr == _getValidatorRole() => (s == getValidatorSigner(a) => validatorSignerToAccount(s) == a)\n{\n\t\tpreserved {\n\t\t\trequire a != s;\n\t\t}\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "accountToSignerAndInverseValidator",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "getValidatorSigner",
                "validatorSignerToAccount",
                "_getValidatorRole"
            ],
            "start_line": 444,
            "end_line": 450,
            "block_hash": "77280ded36b0b794efe9d6206edf7a6d"
        }
    },
    {
        "id": "Accounts_accountToSignerAndInverseAttestation_70acb189",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Accounts.sol",
        "target_function": "attestationSignerToAccount/getAttestationSigner/signerToAccount",
        "text_chunk": "  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n\n  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n",
        "formal_property": "invariant accountToSignerAndInverseAttestation(address a, address s, bytes32 r)\n\tr == _getAttestationRole() => (s == getAttestationSigner(a) => attestationSignerToAccount(s) == a)\n{\n\t\tpreserved {\n\t\t\trequire a != s;\n\t\t}\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "accountToSignerAndInverseAttestation",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "getAttestationSigner",
                "attestationSignerToAccount",
                "_getAttestationRole"
            ],
            "start_line": 452,
            "end_line": 458,
            "block_hash": "70acb189ead786e3f9b86f085c0f3e30"
        }
    },
    {
        "id": "Accounts_accountToSignerAndInverseNewRoles_fa950e98",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Accounts.sol",
        "target_function": "getIndexedSigner/signerToAccount",
        "text_chunk": "  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n",
        "formal_property": "invariant accountToSignerAndInverseNewRoles(address a, address s, bytes32 r)\t\n\tgetIndexedSigner(a, r) == s => signerToAccount(s) == a \n{\n\t\tpreserved {\n\t\t\trequire a != s;\n\t\t}\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "accountToSignerAndInverseNewRoles",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "signerToAccount",
                "getIndexedSigner"
            ],
            "start_line": 460,
            "end_line": 466,
            "block_hash": "fa950e98d9da74f07868f37a06e5d24f"
        }
    },
    {
        "id": "Accounts_address_cant_be_both_authorizedby_of_two_address_e904b23b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is\n  IAccounts,\n  ICeloVersionedContract,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct SignerAuthorization {\n    bool started;\n    bool completed;\n  }\n\n  struct Account {\n    bool exists;\n    // [Deprecated] Each account may authorize signing keys to use for voting,\n    // validating or attestation. These keys may not be keys of other accounts,\n    // and may not be authorized by any other account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  struct PaymentDelegation {\n    // Address that should receive a fraction of validator payments.\n    address beneficiary;\n    // Fraction of payment to delegate to `beneficiary`.\n    FixidityLib.Fraction fraction;\n  }\n\n  mapping(address => Account) internal accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n  // Default signers by account (replaces the legacy Signers struct on Account)\n  mapping(address => mapping(bytes32 => address)) defaultSigners;\n  // All signers and their roles for a given account\n  // solhint-disable-next-line max-line-length\n  mapping(address => mapping(bytes32 => mapping(address => SignerAuthorization))) signerAuthorizations;\n\n  bytes32 public constant EIP712_AUTHORIZE_SIGNER_TYPEHASH = keccak256(\n    \"AuthorizeSigner(address account,address signer,bytes32 role)\"\n  );\n  bytes32 public eip712DomainSeparator;\n\n  // A per-account list of CIP8 storage roots, bypassing CIP3.\n  mapping(address => bytes[]) public offchainStorageRoots;\n\n  // Optional per-account validator payment delegation information.\n  mapping(address => PaymentDelegation) internal paymentDelegations;\n\n  bytes32 constant ValidatorSigner = keccak256(abi.encodePacked(\"celo.org/core/validator\"));\n  bytes32 constant AttestationSigner = keccak256(abi.encodePacked(\"celo.org/core/attestation\"));\n  bytes32 constant VoteSigner = keccak256(abi.encodePacked(\"celo.org/core/vote\"));\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event SignerAuthorized(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationStarted(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationCompleted(address indexed account, address signer, bytes32 indexed role);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event IndexedSignerSet(address indexed account, address signer, bytes32 role);\n  event IndexedSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event DefaultSignerSet(address indexed account, address signer, bytes32 role);\n  event DefaultSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event LegacySignerSet(address indexed account, address signer, bytes32 role);\n  event LegacySignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event SignerRemoved(address indexed account, address oldSigner, bytes32 indexed role);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n  event OffchainStorageRootAdded(address indexed account, bytes url);\n  event OffchainStorageRootRemoved(address indexed account, bytes url, uint256 index);\n  event PaymentDelegationSet(address indexed beneficiary, uint256 fraction);\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return Storage version of the contract.\n   * @return Major version of the contract.\n   * @return Minor version of the contract.\n   * @return Patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 4, 1);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setEip712DomainSeparator();\n  }\n\n  /**\n   * @notice Sets the EIP712 domain separator for the Celo Accounts abstraction.\n   */\n  function setEip712DomainSeparator() public {\n    uint256 chainId;\n    assembly {\n      chainId := chainid\n    }\n\n    eip712DomainSeparator = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(\"Celo Core Contracts\")),\n        keccak256(\"1.0\"),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),\n      \"Account already exists or address is an authorized signer for another account\"\n    );\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Register with createAccount to set account name\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Adds a new CIP8 storage root.\n   * @param url The URL pointing to the offchain storage root.\n   */\n  function addStorageRoot(bytes calldata url) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    offchainStorageRoots[msg.sender].push(url);\n    emit OffchainStorageRootAdded(msg.sender, url);\n  }\n\n  /**\n   * @notice Removes a CIP8 storage root.\n   * @param index The index of the storage root to be removed in the account's\n   * list of storage roots.\n   * @dev The order of storage roots may change after this operation (the last\n   * storage root will be moved to `index`), be aware of this if removing\n   * multiple storage roots at a time.\n   */\n  function removeStorageRoot(uint256 index) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(index < offchainStorageRoots[msg.sender].length, \"Invalid storage root index\");\n    uint256 lastIndex = offchainStorageRoots[msg.sender].length - 1;\n    bytes memory url = offchainStorageRoots[msg.sender][index];\n    offchainStorageRoots[msg.sender][index] = offchainStorageRoots[msg.sender][lastIndex];\n    offchainStorageRoots[msg.sender].length--;\n    emit OffchainStorageRootRemoved(msg.sender, url, index);\n  }\n\n  /**\n   * @notice Returns the full list of offchain storage roots for an account.\n   * @param account The account whose storage roots to return.\n   * @return Concatenated storage root URLs.\n   * @return Lengths of storage root URLs.\n   */\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n  /**\n   * @notice Sets validator payment delegation settings.\n   * @param beneficiary The address that should receive a portion of validator\n   * payments.\n   * @param fraction The fraction of the validator's payment that should be\n   * diverted to `beneficiary` every epoch, given as FixidityLib value. Must not\n   * be greater than 1.\n   * @dev Use `deletePaymentDelegation` to unset the payment delegation.\n   */\n  function setPaymentDelegation(address beneficiary, uint256 fraction) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(beneficiary != address(0), \"Beneficiary cannot be address 0x0\");\n    FixidityLib.Fraction memory f = FixidityLib.wrap(fraction);\n    require(f.lte(FixidityLib.fixed1()), \"Fraction must not be greater than 1\");\n    paymentDelegations[msg.sender] = PaymentDelegation(beneficiary, f);\n    emit PaymentDelegationSet(beneficiary, fraction);\n  }\n\n  /**\n   * @notice Removes a validator's payment delegation by setting benficiary and\n   * fraction to 0.\n   */\n  function deletePaymentDelegation() public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    paymentDelegations[msg.sender] = PaymentDelegation(address(0x0), FixidityLib.wrap(0));\n    emit PaymentDelegationSet(address(0x0), 0);\n  }\n\n  /**\n   * @notice Gets validator payment delegation settings.\n   * @param account Account of the validator.\n   * @return Beneficiary address of payment delegated.\n   * @return Fraction of payment delegated.\n   */\n  function getPaymentDelegation(address account) external view returns (address, uint256) {\n    PaymentDelegation storage delegation = paymentDelegations[account];\n    return (delegation.beneficiary, delegation.fraction.unwrap());\n  }\n\n  /**\n   * @notice Set the indexed signer for a specific role\n   * @param signer the address to set as default\n   * @param role the role to register a default signer for\n   */\n  function setIndexedSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(isNotAccount(signer), \"Cannot authorize account as signer\");\n    require(\n      isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Not a signer for this account\"\n    );\n    require(isSigner(msg.sender, signer, role), \"Must authorize signer before setting as default\");\n\n    Account storage account = accounts[msg.sender];\n    if (isLegacyRole(role)) {\n      if (role == VoteSigner) {\n        account.signers.vote = signer;\n      } else if (role == AttestationSigner) {\n        account.signers.attestation = signer;\n      } else if (role == ValidatorSigner) {\n        account.signers.validator = signer;\n      }\n      emit LegacySignerSet(msg.sender, signer, role);\n    } else {\n      defaultSigners[msg.sender][role] = signer;\n      emit DefaultSignerSet(msg.sender, signer, role);\n    }\n\n    emit IndexedSignerSet(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to act as a signer, for `role`, on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s EIP712 signature over `role`, `msg.sender`\n   *      and `signer`.\n   */\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  function legacyAuthorizeSignerWithSignature(\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) private {\n    authorizeAddress(signer, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Begin the process of authorizing an address to sign on behalf of the account\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   */\n  function authorizeSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register sender with Account.createAccount\");\n    require(\n      isNotAccount(signer) && isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Cannot re-authorize address signer\"\n    );\n\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: false\n    });\n    emit SignerAuthorizationStarted(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Finish the process of authorizing an address to sign on behalf of the account.\n   * @param account The address of account that authorized signing.\n   * @param role The role to finish authorizing for.\n   */\n  function completeSignerAuthorization(address account, bytes32 role) public {\n    require(\n      isAccount(account),\n      \"Unknown Account: Address that authorized signing must be a registered Account\"\n    );\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSignerForAnotherAccount(account, msg.sender),\n      \"Cannot re-authorize address signer\"\n    );\n    require(\n      signerAuthorizations[account][role][msg.sender].started == true,\n      \"Signer authorization not started\"\n    );\n\n    authorizedBy[msg.sender] = account;\n    signerAuthorizations[account][role][msg.sender].completed = true;\n    emit SignerAuthorizationCompleted(account, msg.sender, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the legacy signer for role\n   * @param _account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isLegacySigner(address _account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    Account storage account = accounts[_account];\n    if (role == ValidatorSigner && account.signers.validator == signer) {\n      return true;\n    } else if (role == AttestationSigner && account.signers.attestation == signer) {\n      return true;\n    } else if (role == VoteSigner && account.signers.vote == signer) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the default signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isDefaultSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return defaultSigners[account][role] == signer;\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as an indexed signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isIndexedSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return\n      isLegacyRole(role)\n        ? isLegacySigner(account, signer, role)\n        : isDefaultSigner(account, signer, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as a signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isSigner(address account, address signer, bytes32 role) public view returns (bool) {\n    return\n      isLegacySigner(account, signer, role) ||\n      (signerAuthorizations[account][role][signer].completed && authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Removes the signer for a default role.\n   * @param role The role that has been authorized.\n   */\n  function removeDefaultSigner(bytes32 role) public {\n    address signer = defaultSigners[msg.sender][role];\n    defaultSigners[msg.sender][role] = address(0);\n    emit DefaultSignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Remove one of the Validator, Attestation or\n   * Vote signers from an account. Should only be called from\n   * methods that check the role is a legacy signer.\n   * @param role The role that has been authorized.\n   */\n  function removeLegacySigner(bytes32 role) private {\n    Account storage account = accounts[msg.sender];\n\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n      account.signers.validator = address(0);\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n      account.signers.attestation = address(0);\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n      account.signers.vote = address(0);\n    }\n    emit LegacySignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized and indexed signer\n   * for a specific role\n   * @param role The role of the signer.\n   */\n  function removeIndexedSigner(bytes32 role) public {\n    address oldSigner = getIndexedSigner(msg.sender, role);\n    isLegacyRole(role) ? removeLegacySigner(role) : removeDefaultSigner(role);\n\n    emit IndexedSignerRemoved(msg.sender, oldSigner, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized signer for a specific role and\n   * if the signer is indexed, remove that as well.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function removeSigner(address signer, bytes32 role) public {\n    if (isIndexedSigner(msg.sender, signer, role)) {\n      removeIndexedSigner(role);\n    }\n\n    delete signerAuthorizations[msg.sender][role][signer];\n    emit SignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized vote signer for the account.\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeVoteSigner() public {\n    address signer = getLegacySigner(msg.sender, VoteSigner);\n    removeSigner(signer, VoteSigner);\n    emit VoteSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized validator signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeValidatorSigner() public {\n    address signer = getLegacySigner(msg.sender, ValidatorSigner);\n    removeSigner(signer, ValidatorSigner);\n    emit ValidatorSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized attestation signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeAttestationSigner() public {\n    address signer = getLegacySigner(msg.sender, AttestationSigner);\n    removeSigner(signer, AttestationSigner);\n    emit AttestationSignerRemoved(msg.sender, signer);\n  }\n\n  function signerToAccountWithRole(address signer, bytes32 role) internal view returns (address) {\n    address account = authorizedBy[signer];\n    if (account != address(0)) {\n      require(isSigner(account, signer, role), \"not active authorized signer for role\");\n      return account;\n    }\n\n    require(isAccount(signer), \"Must first register address with Account.createAccount\");\n    return signer;\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account that the signer is authorized to attest for.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account that signer is authorized to validate for.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account that signer is authorized to vote for.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Checks whether the role is one of Vote, Validator or Attestation\n   * @param role The role to check\n   */\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n\n  /**\n   * @notice Returns the legacy signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param _account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n  /**\n   * @notice Returns the default signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n  /**\n   * @notice Returns the indexed signer for the specified account and role.\n   * If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for one of the legacy roles\n   */\n  function hasLegacySigner(address account, bytes32 role) public view returns (bool) {\n    return getLegacySigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for a role\n   */\n  function hasDefaultSigner(address account, bytes32 role) public view returns (bool) {\n    return getDefaultSigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for the role\n   */\n  function hasIndexedSigner(address account, bytes32 role) public view returns (bool) {\n    return isLegacyRole(role) ? hasLegacySigner(account, role) : hasDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Checks whether or not the account has a signer\n   * registered for the plaintext role.\n   * @dev See `hasIndexedSigner` for more gas efficient call.\n   */\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated vote signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated vote signer.\n   */\n  function hasAuthorizedVoteSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated validator signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated validator signer.\n   */\n  function hasAuthorizedValidatorSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated attestation signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated attestation signer.\n   */\n  function hasAuthorizedAttestationSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return The length of each string in bytes.\n   * @return All strings concatenated.\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has not been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Check if `signer` has not been authorized, and if it has been previously\n   *         authorized that it was authorized by `account`.\n   * @param account The authorizing account address.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSignerForAnotherAccount(address account, address signer)\n    internal\n    view\n    returns (bool)\n  {\n    return (authorizedBy[signer] == address(0) || authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Authorizes some role of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `authorized`'s signature on `msg.sender`.\n   */\n  function authorizeAddress(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Returns the address that signed the provided role authorization.\n   * @param account The `account` property signed over in the EIP712 signature\n   * @param signer The `signer` property signed over in the EIP712 signature\n   * @param role The `role` property signed over in the EIP712 signature\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The address that signed the provided role authorization.\n   */\n  function getRoleAuthorizationSigner(\n    address account,\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 structHash = keccak256(\n      abi.encode(EIP712_AUTHORIZE_SIGNER_TYPEHASH, account, signer, role)\n    );\n    return Signatures.getSignerOfTypedDataHash(eip712DomainSeparator, structHash, v, r, s);\n  }\n\n  /**\n   * @notice Authorizes a role of `msg.sender`'s account to another address (`authorized`).\n   * @param authorized The address to authorize.\n   * @param role The role to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that this signature is EIP712 compliant over the authorizing `account`\n   * (`msg.sender`), `signer` (`authorized`) and `role`.\n   */\n  function authorizeAddressWithRole(address authorized, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    private\n  {\n    address signer = getRoleAuthorizationSigner(msg.sender, authorized, role, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Authorizes an address to `msg.sender`'s account\n   * @param authorized The address to authorize.\n   * @dev Fails if the address is already authorized for another account or is an account itself.\n   */\n  function authorize(address authorized) private {\n    require(\n      isAccount(msg.sender),\n      \"Unknown account: sender must register with createAccount first\"\n    );\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSignerForAnotherAccount(msg.sender, authorized),\n      \"Cannot re-authorize address or locked gold account for another account\"\n    );\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}\n",
        "formal_property": "rule address_cant_be_both_authorizedby_of_two_address(address x, address y, address d, bytes32 r1, bytes32 r2, method f) filtered { f -> !f.isView } { \n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "address_cant_be_both_authorizedby_of_two_address",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 72,
            "end_line": 72,
            "block_hash": "e904b23b64e81e5cd531b3f10ad4373c"
        }
    },
    {
        "id": "Accounts_address_can_authorize_two_addresses_legacy_b470dc59",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "authorizeSignerWithSignature/authorizeValidatorSigner/authorizeVoteSigner/isAccount",
        "text_chunk": "  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n",
        "formal_property": "rule address_can_authorize_two_addresses_legacy(address x, address d1, address d2)\nrule address_can_authorize_two_addresses(address x, address d1, address d2, bytes32 role1, bytes32 role2)\n{ \n\trequire x != 0 && d1 != 0 && d2 != 0 && x != d1 && x != d2 && d1 != d2 && isAccount(x); \n\tenv e;\n\trequire e.msg.sender == x;\n  \t\n\tstorage init = lastStorage;\n\t// first, authorizing d2 as a validation signer should succeed\n\tuint8 v2;\n\tbytes32 r2;\n\tbytes32 s2;\n\tauthorizeSignerWithSignature(e, d2, role2, v2, r2, s2);  \n\n\t// Authorize d1 as a Vote signer (alternative execution path - start from the state where validator authorization started)\n\tuint8 v1;\n\tbytes32 r1;\n\tbytes32 s1;\n\tauthorizeSignerWithSignature(e, d1, role1, v1, r1, s1) at init;\n\t\n\t// Even after authorizing d1, the authorization of d2 as a Validation signer should succeed\n\t\t\n\t// AuthorizedBy(d1) and AuthorizedBy(d2) should still be x\n\tassert _getAuthorizedBy(d1) == x && _getAuthorizedBy(d2) == x, \"Authorizedby should both be x\";\n}\n\tauthorizeValidatorSigner(e, d2, v2, r2, s2);  \n\tauthorizeVoteSigner(e, d1, v1, r1, s1) at init;\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "address_can_authorize_two_addresses_legacy",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "isAccount",
                "_getAuthorizedBy"
            ],
            "start_line": 96,
            "end_line": 120,
            "block_hash": "b470dc5968f0a5cce20050b63e7af933"
        }
    },
    {
        "id": "Accounts_address_can_authorize_two_addresses_9cd11f38",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "authorizeSignerWithSignature/isAccount",
        "text_chunk": "  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n",
        "formal_property": "rule address_can_authorize_two_addresses(address x, address d1, address d2, bytes32 role1, bytes32 role2)\n{ \n\trequire x != 0 && d1 != 0 && d2 != 0 && x != d1 && x != d2 && d1 != d2 && isAccount(x); \n\tenv e;\n\trequire e.msg.sender == x;\n  \t\n\tstorage init = lastStorage;\n\t// first, authorizing d2 as a validation signer should succeed\n\tuint8 v2;\n\tbytes32 r2;\n\tbytes32 s2;\n\tauthorizeSignerWithSignature(e, d2, role2, v2, r2, s2);  \n\n\t// Authorize d1 as a Vote signer (alternative execution path - start from the state where validator authorization started)\n\tuint8 v1;\n\tbytes32 r1;\n\tbytes32 s1;\n\tauthorizeSignerWithSignature(e, d1, role1, v1, r1, s1) at init;\n\t\n\t// Even after authorizing d1, the authorization of d2 as a Validation signer should succeed\n\t\t\n\t// AuthorizedBy(d1) and AuthorizedBy(d2) should still be x\n\tassert _getAuthorizedBy(d1) == x && _getAuthorizedBy(d2) == x, \"Authorizedby should both be x\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "address_can_authorize_two_addresses",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "isAccount",
                "_getAuthorizedBy"
            ],
            "start_line": 125,
            "end_line": 149,
            "block_hash": "9cd11f386b0c64b288452695e7456385"
        }
    },
    {
        "id": "Accounts_authorizedBy_can_not_be_removed_a4a2b3e9",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is\n  IAccounts,\n  ICeloVersionedContract,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct SignerAuthorization {\n    bool started;\n    bool completed;\n  }\n\n  struct Account {\n    bool exists;\n    // [Deprecated] Each account may authorize signing keys to use for voting,\n    // validating or attestation. These keys may not be keys of other accounts,\n    // and may not be authorized by any other account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  struct PaymentDelegation {\n    // Address that should receive a fraction of validator payments.\n    address beneficiary;\n    // Fraction of payment to delegate to `beneficiary`.\n    FixidityLib.Fraction fraction;\n  }\n\n  mapping(address => Account) internal accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n  // Default signers by account (replaces the legacy Signers struct on Account)\n  mapping(address => mapping(bytes32 => address)) defaultSigners;\n  // All signers and their roles for a given account\n  // solhint-disable-next-line max-line-length\n  mapping(address => mapping(bytes32 => mapping(address => SignerAuthorization))) signerAuthorizations;\n\n  bytes32 public constant EIP712_AUTHORIZE_SIGNER_TYPEHASH = keccak256(\n    \"AuthorizeSigner(address account,address signer,bytes32 role)\"\n  );\n  bytes32 public eip712DomainSeparator;\n\n  // A per-account list of CIP8 storage roots, bypassing CIP3.\n  mapping(address => bytes[]) public offchainStorageRoots;\n\n  // Optional per-account validator payment delegation information.\n  mapping(address => PaymentDelegation) internal paymentDelegations;\n\n  bytes32 constant ValidatorSigner = keccak256(abi.encodePacked(\"celo.org/core/validator\"));\n  bytes32 constant AttestationSigner = keccak256(abi.encodePacked(\"celo.org/core/attestation\"));\n  bytes32 constant VoteSigner = keccak256(abi.encodePacked(\"celo.org/core/vote\"));\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event SignerAuthorized(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationStarted(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationCompleted(address indexed account, address signer, bytes32 indexed role);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event IndexedSignerSet(address indexed account, address signer, bytes32 role);\n  event IndexedSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event DefaultSignerSet(address indexed account, address signer, bytes32 role);\n  event DefaultSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event LegacySignerSet(address indexed account, address signer, bytes32 role);\n  event LegacySignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event SignerRemoved(address indexed account, address oldSigner, bytes32 indexed role);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n  event OffchainStorageRootAdded(address indexed account, bytes url);\n  event OffchainStorageRootRemoved(address indexed account, bytes url, uint256 index);\n  event PaymentDelegationSet(address indexed beneficiary, uint256 fraction);\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return Storage version of the contract.\n   * @return Major version of the contract.\n   * @return Minor version of the contract.\n   * @return Patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 4, 1);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setEip712DomainSeparator();\n  }\n\n  /**\n   * @notice Sets the EIP712 domain separator for the Celo Accounts abstraction.\n   */\n  function setEip712DomainSeparator() public {\n    uint256 chainId;\n    assembly {\n      chainId := chainid\n    }\n\n    eip712DomainSeparator = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(\"Celo Core Contracts\")),\n        keccak256(\"1.0\"),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),\n      \"Account already exists or address is an authorized signer for another account\"\n    );\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Register with createAccount to set account name\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Adds a new CIP8 storage root.\n   * @param url The URL pointing to the offchain storage root.\n   */\n  function addStorageRoot(bytes calldata url) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    offchainStorageRoots[msg.sender].push(url);\n    emit OffchainStorageRootAdded(msg.sender, url);\n  }\n\n  /**\n   * @notice Removes a CIP8 storage root.\n   * @param index The index of the storage root to be removed in the account's\n   * list of storage roots.\n   * @dev The order of storage roots may change after this operation (the last\n   * storage root will be moved to `index`), be aware of this if removing\n   * multiple storage roots at a time.\n   */\n  function removeStorageRoot(uint256 index) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(index < offchainStorageRoots[msg.sender].length, \"Invalid storage root index\");\n    uint256 lastIndex = offchainStorageRoots[msg.sender].length - 1;\n    bytes memory url = offchainStorageRoots[msg.sender][index];\n    offchainStorageRoots[msg.sender][index] = offchainStorageRoots[msg.sender][lastIndex];\n    offchainStorageRoots[msg.sender].length--;\n    emit OffchainStorageRootRemoved(msg.sender, url, index);\n  }\n\n  /**\n   * @notice Returns the full list of offchain storage roots for an account.\n   * @param account The account whose storage roots to return.\n   * @return Concatenated storage root URLs.\n   * @return Lengths of storage root URLs.\n   */\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n  /**\n   * @notice Sets validator payment delegation settings.\n   * @param beneficiary The address that should receive a portion of validator\n   * payments.\n   * @param fraction The fraction of the validator's payment that should be\n   * diverted to `beneficiary` every epoch, given as FixidityLib value. Must not\n   * be greater than 1.\n   * @dev Use `deletePaymentDelegation` to unset the payment delegation.\n   */\n  function setPaymentDelegation(address beneficiary, uint256 fraction) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(beneficiary != address(0), \"Beneficiary cannot be address 0x0\");\n    FixidityLib.Fraction memory f = FixidityLib.wrap(fraction);\n    require(f.lte(FixidityLib.fixed1()), \"Fraction must not be greater than 1\");\n    paymentDelegations[msg.sender] = PaymentDelegation(beneficiary, f);\n    emit PaymentDelegationSet(beneficiary, fraction);\n  }\n\n  /**\n   * @notice Removes a validator's payment delegation by setting benficiary and\n   * fraction to 0.\n   */\n  function deletePaymentDelegation() public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    paymentDelegations[msg.sender] = PaymentDelegation(address(0x0), FixidityLib.wrap(0));\n    emit PaymentDelegationSet(address(0x0), 0);\n  }\n\n  /**\n   * @notice Gets validator payment delegation settings.\n   * @param account Account of the validator.\n   * @return Beneficiary address of payment delegated.\n   * @return Fraction of payment delegated.\n   */\n  function getPaymentDelegation(address account) external view returns (address, uint256) {\n    PaymentDelegation storage delegation = paymentDelegations[account];\n    return (delegation.beneficiary, delegation.fraction.unwrap());\n  }\n\n  /**\n   * @notice Set the indexed signer for a specific role\n   * @param signer the address to set as default\n   * @param role the role to register a default signer for\n   */\n  function setIndexedSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(isNotAccount(signer), \"Cannot authorize account as signer\");\n    require(\n      isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Not a signer for this account\"\n    );\n    require(isSigner(msg.sender, signer, role), \"Must authorize signer before setting as default\");\n\n    Account storage account = accounts[msg.sender];\n    if (isLegacyRole(role)) {\n      if (role == VoteSigner) {\n        account.signers.vote = signer;\n      } else if (role == AttestationSigner) {\n        account.signers.attestation = signer;\n      } else if (role == ValidatorSigner) {\n        account.signers.validator = signer;\n      }\n      emit LegacySignerSet(msg.sender, signer, role);\n    } else {\n      defaultSigners[msg.sender][role] = signer;\n      emit DefaultSignerSet(msg.sender, signer, role);\n    }\n\n    emit IndexedSignerSet(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to act as a signer, for `role`, on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s EIP712 signature over `role`, `msg.sender`\n   *      and `signer`.\n   */\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  function legacyAuthorizeSignerWithSignature(\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) private {\n    authorizeAddress(signer, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Begin the process of authorizing an address to sign on behalf of the account\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   */\n  function authorizeSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register sender with Account.createAccount\");\n    require(\n      isNotAccount(signer) && isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Cannot re-authorize address signer\"\n    );\n\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: false\n    });\n    emit SignerAuthorizationStarted(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Finish the process of authorizing an address to sign on behalf of the account.\n   * @param account The address of account that authorized signing.\n   * @param role The role to finish authorizing for.\n   */\n  function completeSignerAuthorization(address account, bytes32 role) public {\n    require(\n      isAccount(account),\n      \"Unknown Account: Address that authorized signing must be a registered Account\"\n    );\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSignerForAnotherAccount(account, msg.sender),\n      \"Cannot re-authorize address signer\"\n    );\n    require(\n      signerAuthorizations[account][role][msg.sender].started == true,\n      \"Signer authorization not started\"\n    );\n\n    authorizedBy[msg.sender] = account;\n    signerAuthorizations[account][role][msg.sender].completed = true;\n    emit SignerAuthorizationCompleted(account, msg.sender, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the legacy signer for role\n   * @param _account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isLegacySigner(address _account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    Account storage account = accounts[_account];\n    if (role == ValidatorSigner && account.signers.validator == signer) {\n      return true;\n    } else if (role == AttestationSigner && account.signers.attestation == signer) {\n      return true;\n    } else if (role == VoteSigner && account.signers.vote == signer) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the default signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isDefaultSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return defaultSigners[account][role] == signer;\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as an indexed signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isIndexedSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return\n      isLegacyRole(role)\n        ? isLegacySigner(account, signer, role)\n        : isDefaultSigner(account, signer, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as a signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isSigner(address account, address signer, bytes32 role) public view returns (bool) {\n    return\n      isLegacySigner(account, signer, role) ||\n      (signerAuthorizations[account][role][signer].completed && authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Removes the signer for a default role.\n   * @param role The role that has been authorized.\n   */\n  function removeDefaultSigner(bytes32 role) public {\n    address signer = defaultSigners[msg.sender][role];\n    defaultSigners[msg.sender][role] = address(0);\n    emit DefaultSignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Remove one of the Validator, Attestation or\n   * Vote signers from an account. Should only be called from\n   * methods that check the role is a legacy signer.\n   * @param role The role that has been authorized.\n   */\n  function removeLegacySigner(bytes32 role) private {\n    Account storage account = accounts[msg.sender];\n\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n      account.signers.validator = address(0);\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n      account.signers.attestation = address(0);\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n      account.signers.vote = address(0);\n    }\n    emit LegacySignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized and indexed signer\n   * for a specific role\n   * @param role The role of the signer.\n   */\n  function removeIndexedSigner(bytes32 role) public {\n    address oldSigner = getIndexedSigner(msg.sender, role);\n    isLegacyRole(role) ? removeLegacySigner(role) : removeDefaultSigner(role);\n\n    emit IndexedSignerRemoved(msg.sender, oldSigner, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized signer for a specific role and\n   * if the signer is indexed, remove that as well.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function removeSigner(address signer, bytes32 role) public {\n    if (isIndexedSigner(msg.sender, signer, role)) {\n      removeIndexedSigner(role);\n    }\n\n    delete signerAuthorizations[msg.sender][role][signer];\n    emit SignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized vote signer for the account.\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeVoteSigner() public {\n    address signer = getLegacySigner(msg.sender, VoteSigner);\n    removeSigner(signer, VoteSigner);\n    emit VoteSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized validator signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeValidatorSigner() public {\n    address signer = getLegacySigner(msg.sender, ValidatorSigner);\n    removeSigner(signer, ValidatorSigner);\n    emit ValidatorSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized attestation signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeAttestationSigner() public {\n    address signer = getLegacySigner(msg.sender, AttestationSigner);\n    removeSigner(signer, AttestationSigner);\n    emit AttestationSignerRemoved(msg.sender, signer);\n  }\n\n  function signerToAccountWithRole(address signer, bytes32 role) internal view returns (address) {\n    address account = authorizedBy[signer];\n    if (account != address(0)) {\n      require(isSigner(account, signer, role), \"not active authorized signer for role\");\n      return account;\n    }\n\n    require(isAccount(signer), \"Must first register address with Account.createAccount\");\n    return signer;\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account that the signer is authorized to attest for.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account that signer is authorized to validate for.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account that signer is authorized to vote for.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Checks whether the role is one of Vote, Validator or Attestation\n   * @param role The role to check\n   */\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n\n  /**\n   * @notice Returns the legacy signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param _account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n  /**\n   * @notice Returns the default signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n  /**\n   * @notice Returns the indexed signer for the specified account and role.\n   * If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for one of the legacy roles\n   */\n  function hasLegacySigner(address account, bytes32 role) public view returns (bool) {\n    return getLegacySigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for a role\n   */\n  function hasDefaultSigner(address account, bytes32 role) public view returns (bool) {\n    return getDefaultSigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for the role\n   */\n  function hasIndexedSigner(address account, bytes32 role) public view returns (bool) {\n    return isLegacyRole(role) ? hasLegacySigner(account, role) : hasDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Checks whether or not the account has a signer\n   * registered for the plaintext role.\n   * @dev See `hasIndexedSigner` for more gas efficient call.\n   */\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated vote signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated vote signer.\n   */\n  function hasAuthorizedVoteSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated validator signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated validator signer.\n   */\n  function hasAuthorizedValidatorSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated attestation signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated attestation signer.\n   */\n  function hasAuthorizedAttestationSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return The length of each string in bytes.\n   * @return All strings concatenated.\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has not been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Check if `signer` has not been authorized, and if it has been previously\n   *         authorized that it was authorized by `account`.\n   * @param account The authorizing account address.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSignerForAnotherAccount(address account, address signer)\n    internal\n    view\n    returns (bool)\n  {\n    return (authorizedBy[signer] == address(0) || authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Authorizes some role of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `authorized`'s signature on `msg.sender`.\n   */\n  function authorizeAddress(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Returns the address that signed the provided role authorization.\n   * @param account The `account` property signed over in the EIP712 signature\n   * @param signer The `signer` property signed over in the EIP712 signature\n   * @param role The `role` property signed over in the EIP712 signature\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The address that signed the provided role authorization.\n   */\n  function getRoleAuthorizationSigner(\n    address account,\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 structHash = keccak256(\n      abi.encode(EIP712_AUTHORIZE_SIGNER_TYPEHASH, account, signer, role)\n    );\n    return Signatures.getSignerOfTypedDataHash(eip712DomainSeparator, structHash, v, r, s);\n  }\n\n  /**\n   * @notice Authorizes a role of `msg.sender`'s account to another address (`authorized`).\n   * @param authorized The address to authorize.\n   * @param role The role to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that this signature is EIP712 compliant over the authorizing `account`\n   * (`msg.sender`), `signer` (`authorized`) and `role`.\n   */\n  function authorizeAddressWithRole(address authorized, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    private\n  {\n    address signer = getRoleAuthorizationSigner(msg.sender, authorized, role, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Authorizes an address to `msg.sender`'s account\n   * @param authorized The address to authorize.\n   * @dev Fails if the address is already authorized for another account or is an account itself.\n   */\n  function authorize(address authorized) private {\n    require(\n      isAccount(msg.sender),\n      \"Unknown account: sender must register with createAccount first\"\n    );\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSignerForAnotherAccount(msg.sender, authorized),\n      \"Cannot re-authorize address or locked gold account for another account\"\n    );\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}\n",
        "formal_property": "rule authorizedBy_can_not_be_removed(method f, address signer) filtered { f -> !f.isView } {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "authorizedBy_can_not_be_removed",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 154,
            "end_line": 154,
            "block_hash": "a4a2b3e9dc5054b12fbc5044c99e0b67"
        }
    },
    {
        "id": "Accounts_initializableOnlyOnce_b050ea09",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "initialize",
        "text_chunk": "  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setEip712DomainSeparator();\n  }\n",
        "formal_property": "rule initializableOnlyOnce {\n\tenv e;\n\tcalldataarg arg;\n\tinitialize(e, arg);\n\n\tenv e2;\n\tcalldataarg arg2;\n\tinitialize@withrevert(e2, arg2);\n\tassert lastReverted;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "initializableOnlyOnce",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 167,
            "end_line": 176,
            "block_hash": "b050ea09240de3e45d3d975173972ce4"
        }
    },
    {
        "id": "Accounts_createsAccount_b3fa35bc",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "createAccount/setAccount",
        "text_chunk": "  function createAccount() public returns (bool) {\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),\n      \"Account already exists or address is an authorized signer for another account\"\n    );\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n",
        "formal_property": "rule createsAccount(method f, address a) filtered { f ->\n\t!f.isView\n\t\t&& f.selector != createAccount().selector\n\t\t&& f.selector != setAccount(string,bytes,address,uint8,bytes32,bytes32).selector\n} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "createsAccount",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 181,
            "end_line": 185,
            "block_hash": "b3fa35bc08a96f3811c44d39b96293df"
        }
    },
    {
        "id": "Accounts_viewFunctionsDoNotRevert_f62fbbb3",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "batchGetMetadataURL/getMetadataURL/getOffchainStorageRoots/hasAuthorizedSigner",
        "text_chunk": "  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n",
        "formal_property": "rule viewFunctionsDoNotRevert(method f) filtered { f -> \n\tf.isView \n\t// some functions we ignore, and the reasons:\n\t&& f.selector != hasAuthorizedSigner(address,string).selector // Calldatasize may not match\n\t&& f.selector != batchGetMetadataURL(address[]).selector // Calldatasize may not match\n\n  // These require an account to exist\n\t&& f.selector != getOffchainStorageRoots(address).selector\n\t&& f.selector != offchainStorageRoots(address,uint256).selector\n} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "viewFunctionsDoNotRevert",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 203,
            "end_line": 212,
            "block_hash": "f62fbbb3ad8f561dccdee27a5c3c7ee2"
        }
    },
    {
        "id": "Accounts_cantGoFromNoAuthorizationToCompletedInOneStepUnlessRoleIsLegacy_b6737ef3",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "authorizeSignerWithSignature",
        "text_chunk": "  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n",
        "formal_property": "rule cantGoFromNoAuthorizationToCompletedInOneStepUnlessRoleIsLegacy(method f) filtered { f -> \n\t!f.isView \n\t\t// the authorizeSignerWithSignature allows the signer to provide a signature to the account, so we exclude this option\n\t\t&& f.selector != authorizeSignerWithSignature(address,bytes32,uint8,bytes32,bytes32).selector\n} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cantGoFromNoAuthorizationToCompletedInOneStepUnlessRoleIsLegacy",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 290,
            "end_line": 294,
            "block_hash": "b6737ef360750828aa5b907b032641fc"
        }
    },
    {
        "id": "Accounts_cantMakeASignerForNonLegacyRoleWithoutApprovalOfSigner_9e4d197a",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "authorizeSignerWithSignature",
        "text_chunk": "  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n",
        "formal_property": "rule cantMakeASignerForNonLegacyRoleWithoutApprovalOfSigner(method f) filtered { f -> \n\t!f.isView \n\t\t// the authorizeSignerWithSignature allows the signer to provide a signature to the account, so we exclude this option\n\t\t&& f.selector != authorizeSignerWithSignature(address,bytes32,uint8,bytes32,bytes32).selector\t\n} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cantMakeASignerForNonLegacyRoleWithoutApprovalOfSigner",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 309,
            "end_line": 313,
            "block_hash": "9e4d197a6ad0cd822ee818a781f4809b"
        }
    },
    {
        "id": "Accounts_cannotStartSignerAuthorizationsForOtherAccounts_444b910e",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is\n  IAccounts,\n  ICeloVersionedContract,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct SignerAuthorization {\n    bool started;\n    bool completed;\n  }\n\n  struct Account {\n    bool exists;\n    // [Deprecated] Each account may authorize signing keys to use for voting,\n    // validating or attestation. These keys may not be keys of other accounts,\n    // and may not be authorized by any other account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  struct PaymentDelegation {\n    // Address that should receive a fraction of validator payments.\n    address beneficiary;\n    // Fraction of payment to delegate to `beneficiary`.\n    FixidityLib.Fraction fraction;\n  }\n\n  mapping(address => Account) internal accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n  // Default signers by account (replaces the legacy Signers struct on Account)\n  mapping(address => mapping(bytes32 => address)) defaultSigners;\n  // All signers and their roles for a given account\n  // solhint-disable-next-line max-line-length\n  mapping(address => mapping(bytes32 => mapping(address => SignerAuthorization))) signerAuthorizations;\n\n  bytes32 public constant EIP712_AUTHORIZE_SIGNER_TYPEHASH = keccak256(\n    \"AuthorizeSigner(address account,address signer,bytes32 role)\"\n  );\n  bytes32 public eip712DomainSeparator;\n\n  // A per-account list of CIP8 storage roots, bypassing CIP3.\n  mapping(address => bytes[]) public offchainStorageRoots;\n\n  // Optional per-account validator payment delegation information.\n  mapping(address => PaymentDelegation) internal paymentDelegations;\n\n  bytes32 constant ValidatorSigner = keccak256(abi.encodePacked(\"celo.org/core/validator\"));\n  bytes32 constant AttestationSigner = keccak256(abi.encodePacked(\"celo.org/core/attestation\"));\n  bytes32 constant VoteSigner = keccak256(abi.encodePacked(\"celo.org/core/vote\"));\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event SignerAuthorized(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationStarted(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationCompleted(address indexed account, address signer, bytes32 indexed role);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event IndexedSignerSet(address indexed account, address signer, bytes32 role);\n  event IndexedSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event DefaultSignerSet(address indexed account, address signer, bytes32 role);\n  event DefaultSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event LegacySignerSet(address indexed account, address signer, bytes32 role);\n  event LegacySignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event SignerRemoved(address indexed account, address oldSigner, bytes32 indexed role);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n  event OffchainStorageRootAdded(address indexed account, bytes url);\n  event OffchainStorageRootRemoved(address indexed account, bytes url, uint256 index);\n  event PaymentDelegationSet(address indexed beneficiary, uint256 fraction);\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return Storage version of the contract.\n   * @return Major version of the contract.\n   * @return Minor version of the contract.\n   * @return Patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 4, 1);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setEip712DomainSeparator();\n  }\n\n  /**\n   * @notice Sets the EIP712 domain separator for the Celo Accounts abstraction.\n   */\n  function setEip712DomainSeparator() public {\n    uint256 chainId;\n    assembly {\n      chainId := chainid\n    }\n\n    eip712DomainSeparator = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(\"Celo Core Contracts\")),\n        keccak256(\"1.0\"),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),\n      \"Account already exists or address is an authorized signer for another account\"\n    );\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Register with createAccount to set account name\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Adds a new CIP8 storage root.\n   * @param url The URL pointing to the offchain storage root.\n   */\n  function addStorageRoot(bytes calldata url) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    offchainStorageRoots[msg.sender].push(url);\n    emit OffchainStorageRootAdded(msg.sender, url);\n  }\n\n  /**\n   * @notice Removes a CIP8 storage root.\n   * @param index The index of the storage root to be removed in the account's\n   * list of storage roots.\n   * @dev The order of storage roots may change after this operation (the last\n   * storage root will be moved to `index`), be aware of this if removing\n   * multiple storage roots at a time.\n   */\n  function removeStorageRoot(uint256 index) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(index < offchainStorageRoots[msg.sender].length, \"Invalid storage root index\");\n    uint256 lastIndex = offchainStorageRoots[msg.sender].length - 1;\n    bytes memory url = offchainStorageRoots[msg.sender][index];\n    offchainStorageRoots[msg.sender][index] = offchainStorageRoots[msg.sender][lastIndex];\n    offchainStorageRoots[msg.sender].length--;\n    emit OffchainStorageRootRemoved(msg.sender, url, index);\n  }\n\n  /**\n   * @notice Returns the full list of offchain storage roots for an account.\n   * @param account The account whose storage roots to return.\n   * @return Concatenated storage root URLs.\n   * @return Lengths of storage root URLs.\n   */\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n  /**\n   * @notice Sets validator payment delegation settings.\n   * @param beneficiary The address that should receive a portion of validator\n   * payments.\n   * @param fraction The fraction of the validator's payment that should be\n   * diverted to `beneficiary` every epoch, given as FixidityLib value. Must not\n   * be greater than 1.\n   * @dev Use `deletePaymentDelegation` to unset the payment delegation.\n   */\n  function setPaymentDelegation(address beneficiary, uint256 fraction) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(beneficiary != address(0), \"Beneficiary cannot be address 0x0\");\n    FixidityLib.Fraction memory f = FixidityLib.wrap(fraction);\n    require(f.lte(FixidityLib.fixed1()), \"Fraction must not be greater than 1\");\n    paymentDelegations[msg.sender] = PaymentDelegation(beneficiary, f);\n    emit PaymentDelegationSet(beneficiary, fraction);\n  }\n\n  /**\n   * @notice Removes a validator's payment delegation by setting benficiary and\n   * fraction to 0.\n   */\n  function deletePaymentDelegation() public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    paymentDelegations[msg.sender] = PaymentDelegation(address(0x0), FixidityLib.wrap(0));\n    emit PaymentDelegationSet(address(0x0), 0);\n  }\n\n  /**\n   * @notice Gets validator payment delegation settings.\n   * @param account Account of the validator.\n   * @return Beneficiary address of payment delegated.\n   * @return Fraction of payment delegated.\n   */\n  function getPaymentDelegation(address account) external view returns (address, uint256) {\n    PaymentDelegation storage delegation = paymentDelegations[account];\n    return (delegation.beneficiary, delegation.fraction.unwrap());\n  }\n\n  /**\n   * @notice Set the indexed signer for a specific role\n   * @param signer the address to set as default\n   * @param role the role to register a default signer for\n   */\n  function setIndexedSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(isNotAccount(signer), \"Cannot authorize account as signer\");\n    require(\n      isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Not a signer for this account\"\n    );\n    require(isSigner(msg.sender, signer, role), \"Must authorize signer before setting as default\");\n\n    Account storage account = accounts[msg.sender];\n    if (isLegacyRole(role)) {\n      if (role == VoteSigner) {\n        account.signers.vote = signer;\n      } else if (role == AttestationSigner) {\n        account.signers.attestation = signer;\n      } else if (role == ValidatorSigner) {\n        account.signers.validator = signer;\n      }\n      emit LegacySignerSet(msg.sender, signer, role);\n    } else {\n      defaultSigners[msg.sender][role] = signer;\n      emit DefaultSignerSet(msg.sender, signer, role);\n    }\n\n    emit IndexedSignerSet(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to act as a signer, for `role`, on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s EIP712 signature over `role`, `msg.sender`\n   *      and `signer`.\n   */\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  function legacyAuthorizeSignerWithSignature(\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) private {\n    authorizeAddress(signer, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Begin the process of authorizing an address to sign on behalf of the account\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   */\n  function authorizeSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register sender with Account.createAccount\");\n    require(\n      isNotAccount(signer) && isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Cannot re-authorize address signer\"\n    );\n\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: false\n    });\n    emit SignerAuthorizationStarted(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Finish the process of authorizing an address to sign on behalf of the account.\n   * @param account The address of account that authorized signing.\n   * @param role The role to finish authorizing for.\n   */\n  function completeSignerAuthorization(address account, bytes32 role) public {\n    require(\n      isAccount(account),\n      \"Unknown Account: Address that authorized signing must be a registered Account\"\n    );\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSignerForAnotherAccount(account, msg.sender),\n      \"Cannot re-authorize address signer\"\n    );\n    require(\n      signerAuthorizations[account][role][msg.sender].started == true,\n      \"Signer authorization not started\"\n    );\n\n    authorizedBy[msg.sender] = account;\n    signerAuthorizations[account][role][msg.sender].completed = true;\n    emit SignerAuthorizationCompleted(account, msg.sender, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the legacy signer for role\n   * @param _account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isLegacySigner(address _account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    Account storage account = accounts[_account];\n    if (role == ValidatorSigner && account.signers.validator == signer) {\n      return true;\n    } else if (role == AttestationSigner && account.signers.attestation == signer) {\n      return true;\n    } else if (role == VoteSigner && account.signers.vote == signer) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the default signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isDefaultSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return defaultSigners[account][role] == signer;\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as an indexed signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isIndexedSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return\n      isLegacyRole(role)\n        ? isLegacySigner(account, signer, role)\n        : isDefaultSigner(account, signer, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as a signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isSigner(address account, address signer, bytes32 role) public view returns (bool) {\n    return\n      isLegacySigner(account, signer, role) ||\n      (signerAuthorizations[account][role][signer].completed && authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Removes the signer for a default role.\n   * @param role The role that has been authorized.\n   */\n  function removeDefaultSigner(bytes32 role) public {\n    address signer = defaultSigners[msg.sender][role];\n    defaultSigners[msg.sender][role] = address(0);\n    emit DefaultSignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Remove one of the Validator, Attestation or\n   * Vote signers from an account. Should only be called from\n   * methods that check the role is a legacy signer.\n   * @param role The role that has been authorized.\n   */\n  function removeLegacySigner(bytes32 role) private {\n    Account storage account = accounts[msg.sender];\n\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n      account.signers.validator = address(0);\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n      account.signers.attestation = address(0);\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n      account.signers.vote = address(0);\n    }\n    emit LegacySignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized and indexed signer\n   * for a specific role\n   * @param role The role of the signer.\n   */\n  function removeIndexedSigner(bytes32 role) public {\n    address oldSigner = getIndexedSigner(msg.sender, role);\n    isLegacyRole(role) ? removeLegacySigner(role) : removeDefaultSigner(role);\n\n    emit IndexedSignerRemoved(msg.sender, oldSigner, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized signer for a specific role and\n   * if the signer is indexed, remove that as well.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function removeSigner(address signer, bytes32 role) public {\n    if (isIndexedSigner(msg.sender, signer, role)) {\n      removeIndexedSigner(role);\n    }\n\n    delete signerAuthorizations[msg.sender][role][signer];\n    emit SignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized vote signer for the account.\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeVoteSigner() public {\n    address signer = getLegacySigner(msg.sender, VoteSigner);\n    removeSigner(signer, VoteSigner);\n    emit VoteSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized validator signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeValidatorSigner() public {\n    address signer = getLegacySigner(msg.sender, ValidatorSigner);\n    removeSigner(signer, ValidatorSigner);\n    emit ValidatorSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized attestation signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeAttestationSigner() public {\n    address signer = getLegacySigner(msg.sender, AttestationSigner);\n    removeSigner(signer, AttestationSigner);\n    emit AttestationSignerRemoved(msg.sender, signer);\n  }\n\n  function signerToAccountWithRole(address signer, bytes32 role) internal view returns (address) {\n    address account = authorizedBy[signer];\n    if (account != address(0)) {\n      require(isSigner(account, signer, role), \"not active authorized signer for role\");\n      return account;\n    }\n\n    require(isAccount(signer), \"Must first register address with Account.createAccount\");\n    return signer;\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account that the signer is authorized to attest for.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account that signer is authorized to validate for.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account that signer is authorized to vote for.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Checks whether the role is one of Vote, Validator or Attestation\n   * @param role The role to check\n   */\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n\n  /**\n   * @notice Returns the legacy signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param _account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n  /**\n   * @notice Returns the default signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n  /**\n   * @notice Returns the indexed signer for the specified account and role.\n   * If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for one of the legacy roles\n   */\n  function hasLegacySigner(address account, bytes32 role) public view returns (bool) {\n    return getLegacySigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for a role\n   */\n  function hasDefaultSigner(address account, bytes32 role) public view returns (bool) {\n    return getDefaultSigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for the role\n   */\n  function hasIndexedSigner(address account, bytes32 role) public view returns (bool) {\n    return isLegacyRole(role) ? hasLegacySigner(account, role) : hasDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Checks whether or not the account has a signer\n   * registered for the plaintext role.\n   * @dev See `hasIndexedSigner` for more gas efficient call.\n   */\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated vote signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated vote signer.\n   */\n  function hasAuthorizedVoteSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated validator signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated validator signer.\n   */\n  function hasAuthorizedValidatorSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated attestation signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated attestation signer.\n   */\n  function hasAuthorizedAttestationSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return The length of each string in bytes.\n   * @return All strings concatenated.\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has not been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Check if `signer` has not been authorized, and if it has been previously\n   *         authorized that it was authorized by `account`.\n   * @param account The authorizing account address.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSignerForAnotherAccount(address account, address signer)\n    internal\n    view\n    returns (bool)\n  {\n    return (authorizedBy[signer] == address(0) || authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Authorizes some role of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `authorized`'s signature on `msg.sender`.\n   */\n  function authorizeAddress(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Returns the address that signed the provided role authorization.\n   * @param account The `account` property signed over in the EIP712 signature\n   * @param signer The `signer` property signed over in the EIP712 signature\n   * @param role The `role` property signed over in the EIP712 signature\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The address that signed the provided role authorization.\n   */\n  function getRoleAuthorizationSigner(\n    address account,\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 structHash = keccak256(\n      abi.encode(EIP712_AUTHORIZE_SIGNER_TYPEHASH, account, signer, role)\n    );\n    return Signatures.getSignerOfTypedDataHash(eip712DomainSeparator, structHash, v, r, s);\n  }\n\n  /**\n   * @notice Authorizes a role of `msg.sender`'s account to another address (`authorized`).\n   * @param authorized The address to authorize.\n   * @param role The role to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that this signature is EIP712 compliant over the authorizing `account`\n   * (`msg.sender`), `signer` (`authorized`) and `role`.\n   */\n  function authorizeAddressWithRole(address authorized, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    private\n  {\n    address signer = getRoleAuthorizationSigner(msg.sender, authorized, role, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Authorizes an address to `msg.sender`'s account\n   * @param authorized The address to authorize.\n   * @dev Fails if the address is already authorized for another account or is an account itself.\n   */\n  function authorize(address authorized) private {\n    require(\n      isAccount(msg.sender),\n      \"Unknown account: sender must register with createAccount first\"\n    );\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSignerForAnotherAccount(msg.sender, authorized),\n      \"Cannot re-authorize address or locked gold account for another account\"\n    );\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}\n",
        "formal_property": "rule cannotStartSignerAuthorizationsForOtherAccounts(method f) filtered { f -> !f.isView } {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cannotStartSignerAuthorizationsForOtherAccounts",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 335,
            "end_line": 335,
            "block_hash": "444b910ee1e9cde122b2ee32055e1b8c"
        }
    },
    {
        "id": "Accounts_cannotSetAuthorizedByWithoutSignatures_db3888f8",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "authorizeAttestationSigner/authorizeSignerWithSignature/authorizeValidatorSigner/authorizeValidatorSignerWithKeys/authorizeValidatorSignerWithPublicKey/authorizeVoteSigner",
        "text_chunk": "  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n",
        "formal_property": "rule cannotSetAuthorizedByWithoutSignatures(method f) filtered { f -> \n\t!f.isView \n\t\t&& f.selector != authorizeSignerWithSignature(address,bytes32,uint8,bytes32,bytes32).selector\n\t\t&& f.selector != authorizeAttestationSigner(address,uint8,bytes32,bytes32).selector\n\t\t&& f.selector != authorizeValidatorSigner(address,uint8,bytes32,bytes32).selector\n\t\t&& f.selector != authorizeValidatorSignerWithKeys(address,uint8,bytes32,bytes32,bytes,bytes,bytes).selector\n\t\t&& f.selector != authorizeValidatorSignerWithPublicKey(address,uint8,bytes32,bytes32,bytes).selector\n\t\t&& f.selector != authorizeVoteSigner(address,uint8,bytes32,bytes32).selector\n} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cannotSetAuthorizedByWithoutSignatures",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 351,
            "end_line": 359,
            "block_hash": "db3888f806acf15ca1018f236e9a99ee"
        }
    },
    {
        "id": "Accounts_signerAuthorizationChangePrivileges_fc2037fa",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is\n  IAccounts,\n  ICeloVersionedContract,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct SignerAuthorization {\n    bool started;\n    bool completed;\n  }\n\n  struct Account {\n    bool exists;\n    // [Deprecated] Each account may authorize signing keys to use for voting,\n    // validating or attestation. These keys may not be keys of other accounts,\n    // and may not be authorized by any other account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  struct PaymentDelegation {\n    // Address that should receive a fraction of validator payments.\n    address beneficiary;\n    // Fraction of payment to delegate to `beneficiary`.\n    FixidityLib.Fraction fraction;\n  }\n\n  mapping(address => Account) internal accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n  // Default signers by account (replaces the legacy Signers struct on Account)\n  mapping(address => mapping(bytes32 => address)) defaultSigners;\n  // All signers and their roles for a given account\n  // solhint-disable-next-line max-line-length\n  mapping(address => mapping(bytes32 => mapping(address => SignerAuthorization))) signerAuthorizations;\n\n  bytes32 public constant EIP712_AUTHORIZE_SIGNER_TYPEHASH = keccak256(\n    \"AuthorizeSigner(address account,address signer,bytes32 role)\"\n  );\n  bytes32 public eip712DomainSeparator;\n\n  // A per-account list of CIP8 storage roots, bypassing CIP3.\n  mapping(address => bytes[]) public offchainStorageRoots;\n\n  // Optional per-account validator payment delegation information.\n  mapping(address => PaymentDelegation) internal paymentDelegations;\n\n  bytes32 constant ValidatorSigner = keccak256(abi.encodePacked(\"celo.org/core/validator\"));\n  bytes32 constant AttestationSigner = keccak256(abi.encodePacked(\"celo.org/core/attestation\"));\n  bytes32 constant VoteSigner = keccak256(abi.encodePacked(\"celo.org/core/vote\"));\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event SignerAuthorized(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationStarted(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationCompleted(address indexed account, address signer, bytes32 indexed role);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event IndexedSignerSet(address indexed account, address signer, bytes32 role);\n  event IndexedSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event DefaultSignerSet(address indexed account, address signer, bytes32 role);\n  event DefaultSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event LegacySignerSet(address indexed account, address signer, bytes32 role);\n  event LegacySignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event SignerRemoved(address indexed account, address oldSigner, bytes32 indexed role);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n  event OffchainStorageRootAdded(address indexed account, bytes url);\n  event OffchainStorageRootRemoved(address indexed account, bytes url, uint256 index);\n  event PaymentDelegationSet(address indexed beneficiary, uint256 fraction);\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return Storage version of the contract.\n   * @return Major version of the contract.\n   * @return Minor version of the contract.\n   * @return Patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 4, 1);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setEip712DomainSeparator();\n  }\n\n  /**\n   * @notice Sets the EIP712 domain separator for the Celo Accounts abstraction.\n   */\n  function setEip712DomainSeparator() public {\n    uint256 chainId;\n    assembly {\n      chainId := chainid\n    }\n\n    eip712DomainSeparator = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(\"Celo Core Contracts\")),\n        keccak256(\"1.0\"),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),\n      \"Account already exists or address is an authorized signer for another account\"\n    );\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Register with createAccount to set account name\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Adds a new CIP8 storage root.\n   * @param url The URL pointing to the offchain storage root.\n   */\n  function addStorageRoot(bytes calldata url) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    offchainStorageRoots[msg.sender].push(url);\n    emit OffchainStorageRootAdded(msg.sender, url);\n  }\n\n  /**\n   * @notice Removes a CIP8 storage root.\n   * @param index The index of the storage root to be removed in the account's\n   * list of storage roots.\n   * @dev The order of storage roots may change after this operation (the last\n   * storage root will be moved to `index`), be aware of this if removing\n   * multiple storage roots at a time.\n   */\n  function removeStorageRoot(uint256 index) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(index < offchainStorageRoots[msg.sender].length, \"Invalid storage root index\");\n    uint256 lastIndex = offchainStorageRoots[msg.sender].length - 1;\n    bytes memory url = offchainStorageRoots[msg.sender][index];\n    offchainStorageRoots[msg.sender][index] = offchainStorageRoots[msg.sender][lastIndex];\n    offchainStorageRoots[msg.sender].length--;\n    emit OffchainStorageRootRemoved(msg.sender, url, index);\n  }\n\n  /**\n   * @notice Returns the full list of offchain storage roots for an account.\n   * @param account The account whose storage roots to return.\n   * @return Concatenated storage root URLs.\n   * @return Lengths of storage root URLs.\n   */\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n  /**\n   * @notice Sets validator payment delegation settings.\n   * @param beneficiary The address that should receive a portion of validator\n   * payments.\n   * @param fraction The fraction of the validator's payment that should be\n   * diverted to `beneficiary` every epoch, given as FixidityLib value. Must not\n   * be greater than 1.\n   * @dev Use `deletePaymentDelegation` to unset the payment delegation.\n   */\n  function setPaymentDelegation(address beneficiary, uint256 fraction) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(beneficiary != address(0), \"Beneficiary cannot be address 0x0\");\n    FixidityLib.Fraction memory f = FixidityLib.wrap(fraction);\n    require(f.lte(FixidityLib.fixed1()), \"Fraction must not be greater than 1\");\n    paymentDelegations[msg.sender] = PaymentDelegation(beneficiary, f);\n    emit PaymentDelegationSet(beneficiary, fraction);\n  }\n\n  /**\n   * @notice Removes a validator's payment delegation by setting benficiary and\n   * fraction to 0.\n   */\n  function deletePaymentDelegation() public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    paymentDelegations[msg.sender] = PaymentDelegation(address(0x0), FixidityLib.wrap(0));\n    emit PaymentDelegationSet(address(0x0), 0);\n  }\n\n  /**\n   * @notice Gets validator payment delegation settings.\n   * @param account Account of the validator.\n   * @return Beneficiary address of payment delegated.\n   * @return Fraction of payment delegated.\n   */\n  function getPaymentDelegation(address account) external view returns (address, uint256) {\n    PaymentDelegation storage delegation = paymentDelegations[account];\n    return (delegation.beneficiary, delegation.fraction.unwrap());\n  }\n\n  /**\n   * @notice Set the indexed signer for a specific role\n   * @param signer the address to set as default\n   * @param role the role to register a default signer for\n   */\n  function setIndexedSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(isNotAccount(signer), \"Cannot authorize account as signer\");\n    require(\n      isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Not a signer for this account\"\n    );\n    require(isSigner(msg.sender, signer, role), \"Must authorize signer before setting as default\");\n\n    Account storage account = accounts[msg.sender];\n    if (isLegacyRole(role)) {\n      if (role == VoteSigner) {\n        account.signers.vote = signer;\n      } else if (role == AttestationSigner) {\n        account.signers.attestation = signer;\n      } else if (role == ValidatorSigner) {\n        account.signers.validator = signer;\n      }\n      emit LegacySignerSet(msg.sender, signer, role);\n    } else {\n      defaultSigners[msg.sender][role] = signer;\n      emit DefaultSignerSet(msg.sender, signer, role);\n    }\n\n    emit IndexedSignerSet(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to act as a signer, for `role`, on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s EIP712 signature over `role`, `msg.sender`\n   *      and `signer`.\n   */\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  function legacyAuthorizeSignerWithSignature(\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) private {\n    authorizeAddress(signer, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Begin the process of authorizing an address to sign on behalf of the account\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   */\n  function authorizeSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register sender with Account.createAccount\");\n    require(\n      isNotAccount(signer) && isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Cannot re-authorize address signer\"\n    );\n\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: false\n    });\n    emit SignerAuthorizationStarted(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Finish the process of authorizing an address to sign on behalf of the account.\n   * @param account The address of account that authorized signing.\n   * @param role The role to finish authorizing for.\n   */\n  function completeSignerAuthorization(address account, bytes32 role) public {\n    require(\n      isAccount(account),\n      \"Unknown Account: Address that authorized signing must be a registered Account\"\n    );\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSignerForAnotherAccount(account, msg.sender),\n      \"Cannot re-authorize address signer\"\n    );\n    require(\n      signerAuthorizations[account][role][msg.sender].started == true,\n      \"Signer authorization not started\"\n    );\n\n    authorizedBy[msg.sender] = account;\n    signerAuthorizations[account][role][msg.sender].completed = true;\n    emit SignerAuthorizationCompleted(account, msg.sender, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the legacy signer for role\n   * @param _account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isLegacySigner(address _account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    Account storage account = accounts[_account];\n    if (role == ValidatorSigner && account.signers.validator == signer) {\n      return true;\n    } else if (role == AttestationSigner && account.signers.attestation == signer) {\n      return true;\n    } else if (role == VoteSigner && account.signers.vote == signer) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the default signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isDefaultSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return defaultSigners[account][role] == signer;\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as an indexed signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isIndexedSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return\n      isLegacyRole(role)\n        ? isLegacySigner(account, signer, role)\n        : isDefaultSigner(account, signer, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as a signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isSigner(address account, address signer, bytes32 role) public view returns (bool) {\n    return\n      isLegacySigner(account, signer, role) ||\n      (signerAuthorizations[account][role][signer].completed && authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Removes the signer for a default role.\n   * @param role The role that has been authorized.\n   */\n  function removeDefaultSigner(bytes32 role) public {\n    address signer = defaultSigners[msg.sender][role];\n    defaultSigners[msg.sender][role] = address(0);\n    emit DefaultSignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Remove one of the Validator, Attestation or\n   * Vote signers from an account. Should only be called from\n   * methods that check the role is a legacy signer.\n   * @param role The role that has been authorized.\n   */\n  function removeLegacySigner(bytes32 role) private {\n    Account storage account = accounts[msg.sender];\n\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n      account.signers.validator = address(0);\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n      account.signers.attestation = address(0);\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n      account.signers.vote = address(0);\n    }\n    emit LegacySignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized and indexed signer\n   * for a specific role\n   * @param role The role of the signer.\n   */\n  function removeIndexedSigner(bytes32 role) public {\n    address oldSigner = getIndexedSigner(msg.sender, role);\n    isLegacyRole(role) ? removeLegacySigner(role) : removeDefaultSigner(role);\n\n    emit IndexedSignerRemoved(msg.sender, oldSigner, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized signer for a specific role and\n   * if the signer is indexed, remove that as well.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function removeSigner(address signer, bytes32 role) public {\n    if (isIndexedSigner(msg.sender, signer, role)) {\n      removeIndexedSigner(role);\n    }\n\n    delete signerAuthorizations[msg.sender][role][signer];\n    emit SignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized vote signer for the account.\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeVoteSigner() public {\n    address signer = getLegacySigner(msg.sender, VoteSigner);\n    removeSigner(signer, VoteSigner);\n    emit VoteSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized validator signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeValidatorSigner() public {\n    address signer = getLegacySigner(msg.sender, ValidatorSigner);\n    removeSigner(signer, ValidatorSigner);\n    emit ValidatorSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized attestation signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeAttestationSigner() public {\n    address signer = getLegacySigner(msg.sender, AttestationSigner);\n    removeSigner(signer, AttestationSigner);\n    emit AttestationSignerRemoved(msg.sender, signer);\n  }\n\n  function signerToAccountWithRole(address signer, bytes32 role) internal view returns (address) {\n    address account = authorizedBy[signer];\n    if (account != address(0)) {\n      require(isSigner(account, signer, role), \"not active authorized signer for role\");\n      return account;\n    }\n\n    require(isAccount(signer), \"Must first register address with Account.createAccount\");\n    return signer;\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account that the signer is authorized to attest for.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account that signer is authorized to validate for.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account that signer is authorized to vote for.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Checks whether the role is one of Vote, Validator or Attestation\n   * @param role The role to check\n   */\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n\n  /**\n   * @notice Returns the legacy signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param _account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n  /**\n   * @notice Returns the default signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n  /**\n   * @notice Returns the indexed signer for the specified account and role.\n   * If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for one of the legacy roles\n   */\n  function hasLegacySigner(address account, bytes32 role) public view returns (bool) {\n    return getLegacySigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for a role\n   */\n  function hasDefaultSigner(address account, bytes32 role) public view returns (bool) {\n    return getDefaultSigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for the role\n   */\n  function hasIndexedSigner(address account, bytes32 role) public view returns (bool) {\n    return isLegacyRole(role) ? hasLegacySigner(account, role) : hasDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Checks whether or not the account has a signer\n   * registered for the plaintext role.\n   * @dev See `hasIndexedSigner` for more gas efficient call.\n   */\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated vote signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated vote signer.\n   */\n  function hasAuthorizedVoteSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated validator signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated validator signer.\n   */\n  function hasAuthorizedValidatorSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated attestation signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated attestation signer.\n   */\n  function hasAuthorizedAttestationSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return The length of each string in bytes.\n   * @return All strings concatenated.\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has not been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Check if `signer` has not been authorized, and if it has been previously\n   *         authorized that it was authorized by `account`.\n   * @param account The authorizing account address.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSignerForAnotherAccount(address account, address signer)\n    internal\n    view\n    returns (bool)\n  {\n    return (authorizedBy[signer] == address(0) || authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Authorizes some role of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `authorized`'s signature on `msg.sender`.\n   */\n  function authorizeAddress(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Returns the address that signed the provided role authorization.\n   * @param account The `account` property signed over in the EIP712 signature\n   * @param signer The `signer` property signed over in the EIP712 signature\n   * @param role The `role` property signed over in the EIP712 signature\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The address that signed the provided role authorization.\n   */\n  function getRoleAuthorizationSigner(\n    address account,\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 structHash = keccak256(\n      abi.encode(EIP712_AUTHORIZE_SIGNER_TYPEHASH, account, signer, role)\n    );\n    return Signatures.getSignerOfTypedDataHash(eip712DomainSeparator, structHash, v, r, s);\n  }\n\n  /**\n   * @notice Authorizes a role of `msg.sender`'s account to another address (`authorized`).\n   * @param authorized The address to authorize.\n   * @param role The role to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that this signature is EIP712 compliant over the authorizing `account`\n   * (`msg.sender`), `signer` (`authorized`) and `role`.\n   */\n  function authorizeAddressWithRole(address authorized, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    private\n  {\n    address signer = getRoleAuthorizationSigner(msg.sender, authorized, role, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Authorizes an address to `msg.sender`'s account\n   * @param authorized The address to authorize.\n   * @dev Fails if the address is already authorized for another account or is an account itself.\n   */\n  function authorize(address authorized) private {\n    require(\n      isAccount(msg.sender),\n      \"Unknown account: sender must register with createAccount first\"\n    );\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSignerForAnotherAccount(msg.sender, authorized),\n      \"Cannot re-authorize address or locked gold account for another account\"\n    );\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}\n",
        "formal_property": "rule signerAuthorizationChangePrivileges(address a, bytes32 r, address s, method f) filtered { f ->\n\t!f.isView \n} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "signerAuthorizationChangePrivileges",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 373,
            "end_line": 375,
            "block_hash": "fc2037fab3bb72e010066e89e2162763"
        }
    },
    {
        "id": "Accounts_check_no_fallback_ca2a70b5",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is\n  IAccounts,\n  ICeloVersionedContract,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct SignerAuthorization {\n    bool started;\n    bool completed;\n  }\n\n  struct Account {\n    bool exists;\n    // [Deprecated] Each account may authorize signing keys to use for voting,\n    // validating or attestation. These keys may not be keys of other accounts,\n    // and may not be authorized by any other account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  struct PaymentDelegation {\n    // Address that should receive a fraction of validator payments.\n    address beneficiary;\n    // Fraction of payment to delegate to `beneficiary`.\n    FixidityLib.Fraction fraction;\n  }\n\n  mapping(address => Account) internal accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n  // Default signers by account (replaces the legacy Signers struct on Account)\n  mapping(address => mapping(bytes32 => address)) defaultSigners;\n  // All signers and their roles for a given account\n  // solhint-disable-next-line max-line-length\n  mapping(address => mapping(bytes32 => mapping(address => SignerAuthorization))) signerAuthorizations;\n\n  bytes32 public constant EIP712_AUTHORIZE_SIGNER_TYPEHASH = keccak256(\n    \"AuthorizeSigner(address account,address signer,bytes32 role)\"\n  );\n  bytes32 public eip712DomainSeparator;\n\n  // A per-account list of CIP8 storage roots, bypassing CIP3.\n  mapping(address => bytes[]) public offchainStorageRoots;\n\n  // Optional per-account validator payment delegation information.\n  mapping(address => PaymentDelegation) internal paymentDelegations;\n\n  bytes32 constant ValidatorSigner = keccak256(abi.encodePacked(\"celo.org/core/validator\"));\n  bytes32 constant AttestationSigner = keccak256(abi.encodePacked(\"celo.org/core/attestation\"));\n  bytes32 constant VoteSigner = keccak256(abi.encodePacked(\"celo.org/core/vote\"));\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event SignerAuthorized(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationStarted(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationCompleted(address indexed account, address signer, bytes32 indexed role);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event IndexedSignerSet(address indexed account, address signer, bytes32 role);\n  event IndexedSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event DefaultSignerSet(address indexed account, address signer, bytes32 role);\n  event DefaultSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event LegacySignerSet(address indexed account, address signer, bytes32 role);\n  event LegacySignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event SignerRemoved(address indexed account, address oldSigner, bytes32 indexed role);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n  event OffchainStorageRootAdded(address indexed account, bytes url);\n  event OffchainStorageRootRemoved(address indexed account, bytes url, uint256 index);\n  event PaymentDelegationSet(address indexed beneficiary, uint256 fraction);\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return Storage version of the contract.\n   * @return Major version of the contract.\n   * @return Minor version of the contract.\n   * @return Patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 4, 1);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setEip712DomainSeparator();\n  }\n\n  /**\n   * @notice Sets the EIP712 domain separator for the Celo Accounts abstraction.\n   */\n  function setEip712DomainSeparator() public {\n    uint256 chainId;\n    assembly {\n      chainId := chainid\n    }\n\n    eip712DomainSeparator = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(\"Celo Core Contracts\")),\n        keccak256(\"1.0\"),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),\n      \"Account already exists or address is an authorized signer for another account\"\n    );\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Register with createAccount to set account name\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Adds a new CIP8 storage root.\n   * @param url The URL pointing to the offchain storage root.\n   */\n  function addStorageRoot(bytes calldata url) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    offchainStorageRoots[msg.sender].push(url);\n    emit OffchainStorageRootAdded(msg.sender, url);\n  }\n\n  /**\n   * @notice Removes a CIP8 storage root.\n   * @param index The index of the storage root to be removed in the account's\n   * list of storage roots.\n   * @dev The order of storage roots may change after this operation (the last\n   * storage root will be moved to `index`), be aware of this if removing\n   * multiple storage roots at a time.\n   */\n  function removeStorageRoot(uint256 index) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(index < offchainStorageRoots[msg.sender].length, \"Invalid storage root index\");\n    uint256 lastIndex = offchainStorageRoots[msg.sender].length - 1;\n    bytes memory url = offchainStorageRoots[msg.sender][index];\n    offchainStorageRoots[msg.sender][index] = offchainStorageRoots[msg.sender][lastIndex];\n    offchainStorageRoots[msg.sender].length--;\n    emit OffchainStorageRootRemoved(msg.sender, url, index);\n  }\n\n  /**\n   * @notice Returns the full list of offchain storage roots for an account.\n   * @param account The account whose storage roots to return.\n   * @return Concatenated storage root URLs.\n   * @return Lengths of storage root URLs.\n   */\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n  /**\n   * @notice Sets validator payment delegation settings.\n   * @param beneficiary The address that should receive a portion of validator\n   * payments.\n   * @param fraction The fraction of the validator's payment that should be\n   * diverted to `beneficiary` every epoch, given as FixidityLib value. Must not\n   * be greater than 1.\n   * @dev Use `deletePaymentDelegation` to unset the payment delegation.\n   */\n  function setPaymentDelegation(address beneficiary, uint256 fraction) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(beneficiary != address(0), \"Beneficiary cannot be address 0x0\");\n    FixidityLib.Fraction memory f = FixidityLib.wrap(fraction);\n    require(f.lte(FixidityLib.fixed1()), \"Fraction must not be greater than 1\");\n    paymentDelegations[msg.sender] = PaymentDelegation(beneficiary, f);\n    emit PaymentDelegationSet(beneficiary, fraction);\n  }\n\n  /**\n   * @notice Removes a validator's payment delegation by setting benficiary and\n   * fraction to 0.\n   */\n  function deletePaymentDelegation() public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    paymentDelegations[msg.sender] = PaymentDelegation(address(0x0), FixidityLib.wrap(0));\n    emit PaymentDelegationSet(address(0x0), 0);\n  }\n\n  /**\n   * @notice Gets validator payment delegation settings.\n   * @param account Account of the validator.\n   * @return Beneficiary address of payment delegated.\n   * @return Fraction of payment delegated.\n   */\n  function getPaymentDelegation(address account) external view returns (address, uint256) {\n    PaymentDelegation storage delegation = paymentDelegations[account];\n    return (delegation.beneficiary, delegation.fraction.unwrap());\n  }\n\n  /**\n   * @notice Set the indexed signer for a specific role\n   * @param signer the address to set as default\n   * @param role the role to register a default signer for\n   */\n  function setIndexedSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(isNotAccount(signer), \"Cannot authorize account as signer\");\n    require(\n      isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Not a signer for this account\"\n    );\n    require(isSigner(msg.sender, signer, role), \"Must authorize signer before setting as default\");\n\n    Account storage account = accounts[msg.sender];\n    if (isLegacyRole(role)) {\n      if (role == VoteSigner) {\n        account.signers.vote = signer;\n      } else if (role == AttestationSigner) {\n        account.signers.attestation = signer;\n      } else if (role == ValidatorSigner) {\n        account.signers.validator = signer;\n      }\n      emit LegacySignerSet(msg.sender, signer, role);\n    } else {\n      defaultSigners[msg.sender][role] = signer;\n      emit DefaultSignerSet(msg.sender, signer, role);\n    }\n\n    emit IndexedSignerSet(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to act as a signer, for `role`, on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s EIP712 signature over `role`, `msg.sender`\n   *      and `signer`.\n   */\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  function legacyAuthorizeSignerWithSignature(\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) private {\n    authorizeAddress(signer, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Begin the process of authorizing an address to sign on behalf of the account\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   */\n  function authorizeSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register sender with Account.createAccount\");\n    require(\n      isNotAccount(signer) && isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Cannot re-authorize address signer\"\n    );\n\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: false\n    });\n    emit SignerAuthorizationStarted(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Finish the process of authorizing an address to sign on behalf of the account.\n   * @param account The address of account that authorized signing.\n   * @param role The role to finish authorizing for.\n   */\n  function completeSignerAuthorization(address account, bytes32 role) public {\n    require(\n      isAccount(account),\n      \"Unknown Account: Address that authorized signing must be a registered Account\"\n    );\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSignerForAnotherAccount(account, msg.sender),\n      \"Cannot re-authorize address signer\"\n    );\n    require(\n      signerAuthorizations[account][role][msg.sender].started == true,\n      \"Signer authorization not started\"\n    );\n\n    authorizedBy[msg.sender] = account;\n    signerAuthorizations[account][role][msg.sender].completed = true;\n    emit SignerAuthorizationCompleted(account, msg.sender, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the legacy signer for role\n   * @param _account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isLegacySigner(address _account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    Account storage account = accounts[_account];\n    if (role == ValidatorSigner && account.signers.validator == signer) {\n      return true;\n    } else if (role == AttestationSigner && account.signers.attestation == signer) {\n      return true;\n    } else if (role == VoteSigner && account.signers.vote == signer) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the default signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isDefaultSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return defaultSigners[account][role] == signer;\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as an indexed signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isIndexedSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return\n      isLegacyRole(role)\n        ? isLegacySigner(account, signer, role)\n        : isDefaultSigner(account, signer, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as a signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isSigner(address account, address signer, bytes32 role) public view returns (bool) {\n    return\n      isLegacySigner(account, signer, role) ||\n      (signerAuthorizations[account][role][signer].completed && authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Removes the signer for a default role.\n   * @param role The role that has been authorized.\n   */\n  function removeDefaultSigner(bytes32 role) public {\n    address signer = defaultSigners[msg.sender][role];\n    defaultSigners[msg.sender][role] = address(0);\n    emit DefaultSignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Remove one of the Validator, Attestation or\n   * Vote signers from an account. Should only be called from\n   * methods that check the role is a legacy signer.\n   * @param role The role that has been authorized.\n   */\n  function removeLegacySigner(bytes32 role) private {\n    Account storage account = accounts[msg.sender];\n\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n      account.signers.validator = address(0);\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n      account.signers.attestation = address(0);\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n      account.signers.vote = address(0);\n    }\n    emit LegacySignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized and indexed signer\n   * for a specific role\n   * @param role The role of the signer.\n   */\n  function removeIndexedSigner(bytes32 role) public {\n    address oldSigner = getIndexedSigner(msg.sender, role);\n    isLegacyRole(role) ? removeLegacySigner(role) : removeDefaultSigner(role);\n\n    emit IndexedSignerRemoved(msg.sender, oldSigner, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized signer for a specific role and\n   * if the signer is indexed, remove that as well.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function removeSigner(address signer, bytes32 role) public {\n    if (isIndexedSigner(msg.sender, signer, role)) {\n      removeIndexedSigner(role);\n    }\n\n    delete signerAuthorizations[msg.sender][role][signer];\n    emit SignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized vote signer for the account.\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeVoteSigner() public {\n    address signer = getLegacySigner(msg.sender, VoteSigner);\n    removeSigner(signer, VoteSigner);\n    emit VoteSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized validator signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeValidatorSigner() public {\n    address signer = getLegacySigner(msg.sender, ValidatorSigner);\n    removeSigner(signer, ValidatorSigner);\n    emit ValidatorSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized attestation signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeAttestationSigner() public {\n    address signer = getLegacySigner(msg.sender, AttestationSigner);\n    removeSigner(signer, AttestationSigner);\n    emit AttestationSignerRemoved(msg.sender, signer);\n  }\n\n  function signerToAccountWithRole(address signer, bytes32 role) internal view returns (address) {\n    address account = authorizedBy[signer];\n    if (account != address(0)) {\n      require(isSigner(account, signer, role), \"not active authorized signer for role\");\n      return account;\n    }\n\n    require(isAccount(signer), \"Must first register address with Account.createAccount\");\n    return signer;\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account that the signer is authorized to attest for.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account that signer is authorized to validate for.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account that signer is authorized to vote for.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Checks whether the role is one of Vote, Validator or Attestation\n   * @param role The role to check\n   */\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n\n  /**\n   * @notice Returns the legacy signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param _account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n  /**\n   * @notice Returns the default signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n  /**\n   * @notice Returns the indexed signer for the specified account and role.\n   * If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for one of the legacy roles\n   */\n  function hasLegacySigner(address account, bytes32 role) public view returns (bool) {\n    return getLegacySigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for a role\n   */\n  function hasDefaultSigner(address account, bytes32 role) public view returns (bool) {\n    return getDefaultSigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for the role\n   */\n  function hasIndexedSigner(address account, bytes32 role) public view returns (bool) {\n    return isLegacyRole(role) ? hasLegacySigner(account, role) : hasDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Checks whether or not the account has a signer\n   * registered for the plaintext role.\n   * @dev See `hasIndexedSigner` for more gas efficient call.\n   */\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated vote signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated vote signer.\n   */\n  function hasAuthorizedVoteSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated validator signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated validator signer.\n   */\n  function hasAuthorizedValidatorSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated attestation signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated attestation signer.\n   */\n  function hasAuthorizedAttestationSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return The length of each string in bytes.\n   * @return All strings concatenated.\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has not been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Check if `signer` has not been authorized, and if it has been previously\n   *         authorized that it was authorized by `account`.\n   * @param account The authorizing account address.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSignerForAnotherAccount(address account, address signer)\n    internal\n    view\n    returns (bool)\n  {\n    return (authorizedBy[signer] == address(0) || authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Authorizes some role of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `authorized`'s signature on `msg.sender`.\n   */\n  function authorizeAddress(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Returns the address that signed the provided role authorization.\n   * @param account The `account` property signed over in the EIP712 signature\n   * @param signer The `signer` property signed over in the EIP712 signature\n   * @param role The `role` property signed over in the EIP712 signature\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The address that signed the provided role authorization.\n   */\n  function getRoleAuthorizationSigner(\n    address account,\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 structHash = keccak256(\n      abi.encode(EIP712_AUTHORIZE_SIGNER_TYPEHASH, account, signer, role)\n    );\n    return Signatures.getSignerOfTypedDataHash(eip712DomainSeparator, structHash, v, r, s);\n  }\n\n  /**\n   * @notice Authorizes a role of `msg.sender`'s account to another address (`authorized`).\n   * @param authorized The address to authorize.\n   * @param role The role to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that this signature is EIP712 compliant over the authorizing `account`\n   * (`msg.sender`), `signer` (`authorized`) and `role`.\n   */\n  function authorizeAddressWithRole(address authorized, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    private\n  {\n    address signer = getRoleAuthorizationSigner(msg.sender, authorized, role, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Authorizes an address to `msg.sender`'s account\n   * @param authorized The address to authorize.\n   * @dev Fails if the address is already authorized for another account or is an account itself.\n   */\n  function authorize(address authorized) private {\n    require(\n      isAccount(msg.sender),\n      \"Unknown account: sender must register with createAccount first\"\n    );\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSignerForAnotherAccount(msg.sender, authorized),\n      \"Cannot re-authorize address or locked gold account for another account\"\n    );\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}\n",
        "formal_property": "rule check_no_fallback {\n\tenv e;\n\tcalldataarg arg;\n\tinvoke_fallback(e, arg);\n\n\tassert lastReverted;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "check_no_fallback",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 393,
            "end_line": 399,
            "block_hash": "ca2a70b5d86a46c4a5352abb31f48c68"
        }
    },
    {
        "id": "Accounts_gettersInAgreement_0a8cee60",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "getAttestationSigner/getDefaultSigner/getIndexedSigner/getLegacySigner/getValidatorSigner/getVoteSigner/isLegacyRole",
        "text_chunk": "  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n",
        "formal_property": "rule gettersInAgreement() {\n\taddress account;\n\trequire account != 0;\n\tbytes32 role;\n\taddress indexedSigner = getIndexedSigner(account, role);\n\taddress defaultSigner = getDefaultSigner(account, role);\n\taddress legacySigner = getLegacySigner(account, role);\n\taddress voteSigner = getVoteSigner(account);\n\taddress validatorSigner = getValidatorSigner(account);\n\taddress attestationSigner = getAttestationSigner(account);\n\n\tif (role == _getVoteRole()) {\n\t\tassert indexedSigner == legacySigner && indexedSigner == voteSigner, \"indexed signer agrees with legacy signer for vote role\";\n\t} else if (role == _getValidatorRole()) {\n\t\tassert indexedSigner == legacySigner && indexedSigner == validatorSigner, \"indexed signer agrees with legacy signer for validator role\";\n\t} else if (role == _getAttestationRole()) {\n\t\tassert indexedSigner == legacySigner && indexedSigner == attestationSigner, \"indexed signer agrees with legacy signer for attestation role\";\n\t} else {\n\t\tassert indexedSigner == defaultSigner, \"for any non legacy role indexed signer is default signer\";\n\t}\n\tassert indexedSigner != 0 && defaultSigner != 0 && legacySigner != 0 \n\t\t&& voteSigner != 0 && validatorSigner != 0 && attestationSigner != 0, \"signer is never address 0\";\n\t// original assertion is wrong\n\t//assert indexedSigner != account => defaultSigner != account, \"If indexed signer is a distinct address then default signer for this role is also a distinct address\";\n\tassert !isLegacyRole(role) && indexedSigner != account => defaultSigner != account, \"If indexed signer is a distinct address then default signer for this role is also a distinct address\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "gettersInAgreement",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "getAttestationSigner",
                "getVoteSigner",
                "getValidatorSigner",
                "getDefaultSigner",
                "getLegacySigner",
                "isLegacyRole",
                "_getValidatorRole",
                "_getAttestationRole",
                "_getVoteRole",
                "getIndexedSigner"
            ],
            "start_line": 404,
            "end_line": 431,
            "block_hash": "0a8cee60da56f4e00a1132ab0ddc7d93"
        }
    },
    {
        "id": "Auction_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "Auction.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\ncontract AuctionFixed \n{\n    event BidEvent(address from);\n    function bid() public\n    {\n        emitBidEvent(msg.sender);\n    }\n\n    function emitBidEvent(address from) internal\n    {\n        emit BidEvent(from);\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "bid",
                "emitBidEvent"
            ],
            "state_variables": [],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "Auction_checks_b003f372",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Auction.sol",
        "target_function": "bid",
        "text_chunk": "    function bid() public\n    {\n        emitBidEvent(msg.sender);\n    }\n",
        "formal_property": " * This rule checks that an event is emitted\n */\nrule eventIsEmitted() {\n    env e;\n    isEventEmitted = false;\n    bid(e);\n    assert isEventEmitted;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "checks",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 20,
            "end_line": 27,
            "block_hash": "b003f372eb02993f40dc1a5c5777c102"
        }
    },
    {
        "id": "Auction_checks_dd7bf432",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Auction.sol",
        "target_function": "bid",
        "text_chunk": "    function bid() public\n    {\n        emitBidEvent(msg.sender);\n    }\n",
        "formal_property": " * This rule checks that the emitted event address is the one\n * that initiated the bid operation. \n */\nrule eventEmitsMsgSender() {\n    env e;\n    bid(e);\n    assert emittedEventAddress == e.msg.sender;\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "checks",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 30,
            "end_line": 37,
            "block_hash": "dd7bf432f3c54fe7019810f908a7af02"
        }
    },
    {
        "id": "ERC20broken_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC20broken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ContractsAndProperties/IERC20.sol\";\nimport \"../ContractsAndProperties/IERC20Metadata.sol\";\n\ncontract ERC20 is IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    address public _owner;\n\n    constructor() {\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender);\n        _;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return \"\";\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return \"\";\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        ); \n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        ); \n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n    function mint(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function burn(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function deposit() external payable {\n        _balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount <= _balances[msg.sender]);\n        _balances[msg.sender] -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success);\n    }\n\n    function addAmount(uint256 amount) external {\n            _balances[msg.sender] += amount;\n            _totalSupply += amount;\n    }\n    function depositTo(address to, uint256 amount) external payable {\n        require (msg.value > amount);\n        unchecked {\n            _balances[to] += amount;\n            _balances[msg.sender] += msg.value - amount;\n            _totalSupply += msg.value;\n        }\n    }\n\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "name",
                "symbol",
                "decimals",
                "totalSupply",
                "balanceOf",
                "transfer",
                "allowance",
                "approve",
                "transferFrom",
                "increaseAllowance",
                "decreaseAllowance",
                "_transfer",
                "mint",
                "burn",
                "_approve",
                "_beforeTokenTransfer",
                "_afterTokenTransfer",
                "deposit",
                "withdraw",
                "addAmount",
                "depositTo"
            ],
            "state_variables": [
                "_balances",
                "_owner",
                "_totalSupply",
                "_allowances"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC20broken_balancesBoundedByTotalSupply_b87024cf",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20broken.sol",
        "target_function": "balanceOf/totalSupply/transfer/transferFrom",
        "text_chunk": "    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n",
        "formal_property": "invariant balancesBoundedByTotalSupply(address alice, address bob)\n    balanceOf(alice) + balanceOf(bob) <= totalSupply()\n{\n    preserved transfer(address recip, uint256 amount) with (env e) {\n        require recip        == alice || recip        == bob;\n        require e.msg.sender == alice || e.msg.sender == bob;\n    }\n\n    preserved transferFrom(address from, address to, uint256 amount) {\n        require from == alice || from == bob;\n        require to   == alice || to   == bob;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "balancesBoundedByTotalSupply",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 125,
            "end_line": 137,
            "block_hash": "b87024cfda2bccb6eee41cf149b69a70"
        }
    },
    {
        "id": "ERC20broken_totalSupplyIsSumOfBalances_cf75bb04",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20broken.sol",
        "target_function": "addAmount/balanceOf/totalSupply/transfer/transferFrom",
        "text_chunk": "    function addAmount(uint256 amount) external {\n            _balances[msg.sender] += amount;\n            _totalSupply += amount;\n    }\n\n\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n",
        "formal_property": "invariant totalSupplyIsSumOfBalances()\n    totalSupply() == sum_of_balances;\n\n// Safe casting examples\n// addAmount() uses `unchecked` therefore is not checking for overflow. \n/// @dev This rule is unsound!\ninvariant balancesBoundedByTotalSupply(address alice, address bob)\n    balanceOf(alice) + balanceOf(bob) <= totalSupply()\n{\n    preserved transfer(address recip, uint256 amount) with (env e) {\n        require recip        == alice || recip        == bob;\n        require e.msg.sender == alice || e.msg.sender == bob;\n    }\n    preserved transferFrom(address from, address to, uint256 amount) {\n        require from == alice || from == bob;\n        require to   == alice || to   == bob;\n}\n// With the  `require_uint256(amount1 + amount2))` the rule passes although an overflow exists.\nrule requireHidesOverflow() {\n    env e;\n    uint256 amount1;\n    uint256 amount2;\n    storage initial = lastStorage;\n    addAmount(e, amount1);\n    addAmount(e, amount2);\n    storage afterTwoSteps = lastStorage;\n    addAmount(e, require_uint256(amount1 + amount2)) at initial;\n    storage afterOneStep = lastStorage;\n    assert afterOneStep == afterTwoSteps;\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "totalSupplyIsSumOfBalances",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 140,
            "end_line": 159,
            "block_hash": "cf75bb04c4ff4f4df90a29180f8d1908"
        }
    },
    {
        "id": "ERC20broken_transferSpec_1675b597",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20broken.sol",
        "target_function": "balanceOf/transfer",
        "text_chunk": "    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n",
        "formal_property": "rule transferSpec {\n    address sender; address recip; uint amount;\n\n    env e;\n    require e.msg.sender == sender;\n    mathint balance_sender_before = balanceOf(sender);\n    mathint balance_recip_before = balanceOf(recip);\n    transfer(e, recip, amount);\n    mathint balance_sender_after = balanceOf(sender);\n    mathint balance_recip_after = balanceOf(recip);\n    require sender != recip;\n    assert balance_sender_after == balance_sender_before - amount,\n        \"transfer must decrease sender's balance by amount\";\n    assert balance_recip_after == balance_recip_before + amount,\n        \"transfer must increase recipient's balance by amount\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferSpec",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 17,
            "end_line": 38,
            "block_hash": "1675b597f10804447256ae87aa77578e"
        }
    },
    {
        "id": "ERC20broken_transferReverts_53849109",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20broken.sol",
        "target_function": "balanceOf/totalSupply/transfer/transferFrom",
        "text_chunk": "    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n",
        "formal_property": "rule transferReverts {\n    env e; address recip; uint amount;\n\n    require balanceOf(e.msg.sender) < amount;\n    transfer@withrevert(e, recip, amount);\n    assert lastReverted,\n        \"transfer(recip,amount) must revert if sender's balance is less than `amount`\";\n/// @dev This rule is unsound!\ninvariant balancesBoundedByTotalSupply(address alice, address bob)\n    balanceOf(alice) + balanceOf(bob) <= totalSupply()\n{\n    preserved transfer(address recip, uint256 amount) with (env e) {\n        require recip        == alice || recip        == bob;\n        require e.msg.sender == alice || e.msg.sender == bob;\n    }\n    preserved transferFrom(address from, address to, uint256 amount) {\n        require from == alice || from == bob;\n        require to   == alice || to   == bob;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferReverts",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 42,
            "end_line": 51,
            "block_hash": "53849109cd7565f878a1f546b45902c0"
        }
    },
    {
        "id": "ERC20broken_transferDoesntRevert_2084b208",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20broken.sol",
        "target_function": "balanceOf/transfer",
        "text_chunk": "    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n",
        "formal_property": "rule transferDoesntRevert {\n    env e; address recipient; uint amount;\n\n    require balanceOf(e.msg.sender) > amount;\n    require e.msg.value == 0;\n    require balanceOf(recipient) + amount < max_uint;\n    require e.msg.sender != 0;\n    require recipient != 0;\n    transfer@withrevert(e, recipient, amount);\n    assert !lastReverted;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferDoesntRevert",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 62,
            "end_line": 73,
            "block_hash": "2084b2085ab6d961ad387e0e86e07b3c"
        }
    },
    {
        "id": "ERC20broken_onlyHolderCanChangeAllowance_c4121ca6",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20broken.sol",
        "target_function": "allowance/approve/increaseAllowance",
        "text_chunk": "    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        ); \n        return true;\n    }\n",
        "formal_property": "rule onlyHolderCanChangeAllowance {\n    address holder; address spender;\n\n    mathint allowance_before = allowance(holder, spender);\n    method f; env e; calldataarg args; // was: env e; uint256 amount;\n    f(e, args);                        // was: approve(e, spender, amount);\n    mathint allowance_after = allowance(holder, spender);\n    assert allowance_after > allowance_before => e.msg.sender == holder,\n        \"approve must only change the sender's allowance\";\n    assert allowance_after > allowance_before =>\n        (f.selector == sig:approve(address,uint).selector || f.selector == sig:increaseAllowance(address,uint).selector),\n        \"only approve and increaseAllowance can increase allowances\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "onlyHolderCanChangeAllowance",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 78,
            "end_line": 94,
            "block_hash": "c4121ca630222187ae060d0ecfc84aa1"
        }
    },
    {
        "id": "ERC20broken_onlyApproveIncreasesAllowance_b26c0c9c",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20broken.sol",
        "target_function": "allowance/approve/balanceOf/totalSupply/transfer/transferFrom",
        "text_chunk": "    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n",
        "formal_property": "rule onlyApproveIncreasesAllowance {\n    address holder; address spender;\n\n    mathint allowance_before = allowance(holder, spender);\n    method f; env e; calldataarg args; \n    f(e, args);                        \n    mathint allowance_after = allowance(holder, spender);\n    satisfy allowance_after > allowance_before =>\n/// @dev This rule is unsound!\ninvariant balancesBoundedByTotalSupply(address alice, address bob)\n    balanceOf(alice) + balanceOf(bob) <= totalSupply()\n{\n    preserved transfer(address recip, uint256 amount) with (env e) {\n        require recip        == alice || recip        == bob;\n        require e.msg.sender == alice || e.msg.sender == bob;\n    }\n    preserved transferFrom(address from, address to, uint256 amount) {\n        require from == alice || from == bob;\n        require to   == alice || to   == bob;\n}\n        (f.selector == sig:approve(address,uint).selector),\n        \"only approve and increaseAllowance can increase allowances\";\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "onlyApproveIncreasesAllowance",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 96,
            "end_line": 109,
            "block_hash": "b26c0c9c8eb760b290e242e4464542a6"
        }
    },
    {
        "id": "ERC20broken_is_fe602806",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20broken.sol",
        "target_function": "balanceOf/totalSupply/transfer/transferFrom",
        "text_chunk": "    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n",
        "formal_property": "/// @dev This rule is unsound!\ninvariant balancesBoundedByTotalSupply(address alice, address bob)\n    balanceOf(alice) + balanceOf(bob) <= totalSupply()\n{\n    preserved transfer(address recip, uint256 amount) with (env e) {\n        require recip        == alice || recip        == bob;\n        require e.msg.sender == alice || e.msg.sender == bob;\n    }\n\n    preserved transferFrom(address from, address to, uint256 amount) {\n        require from == alice || from == bob;\n        require to   == alice || to   == bob;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "is",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 124,
            "end_line": 137,
            "block_hash": "fe602806827905ccc2a8c2cc8d18c66f"
        }
    },
    {
        "id": "ERC20broken_passes_5edef094",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20broken.sol",
        "target_function": "addAmount/balanceOf/totalSupply/transfer/transferFrom",
        "text_chunk": "    function addAmount(uint256 amount) external {\n            _balances[msg.sender] += amount;\n            _totalSupply += amount;\n    }\n\n\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n",
        "formal_property": "// With the  `require_uint256(amount1 + amount2))` the rule passes although an overflow exists.\n/// @dev This rule is unsound!\ninvariant balancesBoundedByTotalSupply(address alice, address bob)\n    balanceOf(alice) + balanceOf(bob) <= totalSupply()\n{\n    preserved transfer(address recip, uint256 amount) with (env e) {\n        require recip        == alice || recip        == bob;\n        require e.msg.sender == alice || e.msg.sender == bob;\n    }\n\n    preserved transferFrom(address from, address to, uint256 amount) {\n        require from == alice || from == bob;\n        require to   == alice || to   == bob;\n}\nrule requireHidesOverflow() {\n    env e;\n    uint256 amount1;\n    uint256 amount2;\n    storage initial = lastStorage;\n    addAmount(e, amount1);\n    addAmount(e, amount2);\n    storage afterTwoSteps = lastStorage;\n    addAmount(e, require_uint256(amount1 + amount2)) at initial;\n    storage afterOneStep = lastStorage;\n    assert afterOneStep == afterTwoSteps;\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "passes",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 145,
            "end_line": 159,
            "block_hash": "5edef094051015821e198c0c9e954e83"
        }
    },
    {
        "id": "LockedGold_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "LockedGold.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/utils/Address.sol\";\nimport \"openzeppelin-solidity/contracts/utils/EnumerableSet.sol\";\n\nimport \"./interfaces/ILockedGold.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract LockedGold is\n  ILockedGold,\n  ICeloVersionedContract,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry\n{\n  using SafeMath for uint256;\n  using Address for address payable; // prettier-ignore\n  using FixidityLib for FixidityLib.Fraction;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  struct PendingWithdrawal {\n    // The value of the pending withdrawal.\n    uint256 value;\n    // The timestamp at which the pending withdrawal becomes available.\n    uint256 timestamp;\n  }\n\n  // NOTE: This contract does not store an account's locked gold that is being used in electing\n  // validators.\n  struct Balances {\n    // The amount of locked gold that this account has that is not currently participating in\n    // validator elections.\n    uint256 nonvoting;\n    // Gold that has been unlocked and will become available for withdrawal.\n    PendingWithdrawal[] pendingWithdrawals;\n  }\n\n  struct DelegatedInfo {\n    FixidityLib.Fraction percentage;\n    uint256 currentAmount;\n  }\n\n  struct Delegated {\n    EnumerableSet.AddressSet delegatees;\n    // delegatees with how much percent delegatees are getting\n    // Celo at the time of delegation/latest update\n    mapping(address => DelegatedInfo) delegateesWithPercentagesAndAmount;\n    FixidityLib.Fraction totalDelegatedCeloFraction;\n  }\n\n  mapping(address => Balances) internal balances;\n\n  // Iterable map to store whitelisted identifiers.\n  // Necessary to allow iterating over whitelisted IDs to check ID's address at runtime.\n  mapping(bytes32 => bool) internal slashingMap;\n  bytes32[] public slashingWhitelist;\n\n  modifier onlySlasher {\n    require(\n      registry.isOneOf(slashingWhitelist, msg.sender),\n      \"Caller is not a whitelisted slasher.\"\n    );\n    _;\n  }\n\n  function isSlasher(address slasher) external view returns (bool) {\n    return (registry.isOneOf(slashingWhitelist, slasher));\n  }\n\n  uint256 public totalNonvoting;\n  uint256 public unlockingPeriod;\n\n  // Info about delegator\n  mapping(address => Delegated) delegatorInfo;\n  // Celo that was delegated to this particular address\n  mapping(address => uint256) public totalDelegatedCelo;\n\n  // maximum amount of allowed delegatees\n  uint256 maxDelegateesCount;\n\n  event UnlockingPeriodSet(uint256 period);\n  event GoldLocked(address indexed account, uint256 value);\n  event GoldUnlocked(address indexed account, uint256 value, uint256 available);\n  event GoldRelocked(address indexed account, uint256 value);\n  event GoldWithdrawn(address indexed account, uint256 value);\n  event SlasherWhitelistAdded(string indexed slasherIdentifier);\n  event SlasherWhitelistRemoved(string indexed slasherIdentifier);\n  event AccountSlashed(\n    address indexed slashed,\n    uint256 penalty,\n    address indexed reporter,\n    uint256 reward\n  );\n  event CeloDelegated(\n    address indexed delegator,\n    address indexed delegatee,\n    uint256 percent,\n    uint256 amount\n  );\n  event DelegatedCeloRevoked(\n    address indexed delegator,\n    address indexed delegatee,\n    uint256 percent,\n    uint256 amount\n  );\n  event MaxDelegateesCountSet(uint256 value);\n\n  /**\n  * @notice Returns the storage, major, minor, and patch version of the contract.\n  * @return Storage version of the contract.\n  * @return Major version of the contract.\n  * @return Minor version of the contract.\n  * @return Patch version of the contract.\n  */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 4, 0);\n  }\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   * @param _unlockingPeriod The unlocking period in seconds.\n   */\n  function initialize(address registryAddress, uint256 _unlockingPeriod) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setUnlockingPeriod(_unlockingPeriod);\n    maxDelegateesCount = 10;\n  }\n\n  /**\n   * @notice Sets the duration in seconds users must wait before withdrawing gold after unlocking.\n   * @param value The unlocking period in seconds.\n   */\n  function setUnlockingPeriod(uint256 value) public onlyOwner {\n    require(value != unlockingPeriod, \"Unlocking period not changed\");\n    unlockingPeriod = value;\n    emit UnlockingPeriodSet(value);\n  }\n\n  /**\n   * @notice Sets max delegatees count.\n   * @param value The max delegatees count.\n   */\n  function setMaxDelegateesCount(uint256 value) public onlyOwner {\n    maxDelegateesCount = value;\n    emit MaxDelegateesCountSet(value);\n  }\n\n  /**\n   * @notice Locks gold to be used for voting.\n   */\n  function lock() external payable nonReentrant {\n    require(\n      getAccounts().isAccount(msg.sender),\n      \"Must first register address with Account.createAccount\"\n    );\n    _incrementNonvotingAccountBalance(msg.sender, msg.value);\n    _updateDelegatedAmount(msg.sender);\n    emit GoldLocked(msg.sender, msg.value);\n  }\n\n  /**\n   * @notice Increments the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be incremented.\n   * @param value The amount by which to increment.\n   * @dev Can only be called by the registered Election smart contract.\n   */\n  function incrementNonvotingAccountBalance(address account, uint256 value)\n    external\n    onlyRegisteredContract(ELECTION_REGISTRY_ID)\n  {\n    _incrementNonvotingAccountBalance(account, value);\n  }\n\n  /**\n   * @notice Decrements the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be decremented.\n   * @param value The amount by which to decrement.\n   * @dev Can only be called by the registered \"Election\" smart contract.\n   */\n  function decrementNonvotingAccountBalance(address account, uint256 value)\n    external\n    onlyRegisteredContract(ELECTION_REGISTRY_ID)\n  {\n    _decrementNonvotingAccountBalance(account, value);\n  }\n\n  /**\n   * @notice Increments the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be incremented.\n   * @param value The amount by which to increment.\n   */\n  function _incrementNonvotingAccountBalance(address account, uint256 value) private {\n    balances[account].nonvoting = balances[account].nonvoting.add(value);\n    totalNonvoting = totalNonvoting.add(value);\n  }\n\n  /**\n   * @notice Decrements the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be decremented.\n   * @param value The amount by which to decrement.\n   */\n  function _decrementNonvotingAccountBalance(address account, uint256 value) private {\n    balances[account].nonvoting = balances[account].nonvoting.sub(value);\n    totalNonvoting = totalNonvoting.sub(value);\n  }\n\n  /**\n   * @notice Unlocks gold that becomes withdrawable after the unlocking period.\n   * @param value The amount of gold to unlock.\n   */\n  function unlock(uint256 value) external nonReentrant {\n    require(\n      getAccounts().isAccount(msg.sender),\n      \"Sender must be registered with Account.createAccount to lock or unlock\"\n    );\n    Balances storage account = balances[msg.sender];\n\n    uint256 totalLockedGold = getAccountTotalLockedGold(msg.sender);\n    // Prevent unlocking gold when voting on governance proposals so that the gold cannot be\n    // used to vote more than once.\n    uint256 remainingLockedGold = totalLockedGold.sub(value);\n\n    uint256 totalReferendumVotes = getGovernance().getAmountOfGoldUsedForVoting(msg.sender);\n    require(\n      remainingLockedGold >= totalReferendumVotes,\n      \"Not enough unlockable celo. Celo is locked in voting.\"\n    );\n\n    FixidityLib.Fraction memory delegatedPercentage = delegatorInfo[msg.sender]\n      .totalDelegatedCeloFraction;\n\n    if (FixidityLib.gt(delegatedPercentage, FixidityLib.newFixed(0))) {\n      revokeFromDelegatedWhenUnlocking(msg.sender, value);\n    }\n\n    uint256 balanceRequirement = getValidators().getAccountLockedGoldRequirement(msg.sender);\n    require(\n      balanceRequirement == 0 || balanceRequirement <= remainingLockedGold,\n      \"Either account doesn't have enough locked Celo or locked Celo is being used for voting.\"\n    );\n    _decrementNonvotingAccountBalance(msg.sender, value);\n    uint256 available = now.add(unlockingPeriod);\n    // CERTORA: the slot containing the length could be MAX_UINT\n    account.pendingWithdrawals.push(PendingWithdrawal(value, available));\n    emit GoldUnlocked(msg.sender, value, available);\n  }\n\n  /**\n   * @notice Relocks gold that has been unlocked but not withdrawn.\n   * @param index The index of the pending withdrawal to relock from.\n   * @param value The value to relock from the specified pending withdrawal.\n   */\n  function relock(uint256 index, uint256 value) external nonReentrant {\n    require(\n      getAccounts().isAccount(msg.sender),\n      \"Sender must be registered with Account.createAccount to lock or relock\"\n    );\n    Balances storage account = balances[msg.sender];\n    require(index < account.pendingWithdrawals.length, \"Bad pending withdrawal index\");\n    PendingWithdrawal storage pendingWithdrawal = account.pendingWithdrawals[index];\n    require(value <= pendingWithdrawal.value, \"Requested value larger than pending value\");\n    if (value == pendingWithdrawal.value) {\n      deletePendingWithdrawal(account.pendingWithdrawals, index);\n    } else {\n      pendingWithdrawal.value = pendingWithdrawal.value.sub(value);\n    }\n    _incrementNonvotingAccountBalance(msg.sender, value);\n    _updateDelegatedAmount(msg.sender);\n    emit GoldRelocked(msg.sender, value);\n  }\n\n  /**\n   * @notice Withdraws gold that has been unlocked after the unlocking period has passed.\n   * @param index The index of the pending withdrawal to withdraw.\n   */\n  function withdraw(uint256 index) external nonReentrant {\n    require(\n      getAccounts().isAccount(msg.sender),\n      \"Sender must be registered with Account.createAccount to withdraw\"\n    );\n    Balances storage account = balances[msg.sender];\n    require(index < account.pendingWithdrawals.length, \"Bad pending withdrawal index\");\n    PendingWithdrawal storage pendingWithdrawal = account.pendingWithdrawals[index];\n    require(now >= pendingWithdrawal.timestamp, \"Pending withdrawal not available\");\n    uint256 value = pendingWithdrawal.value;\n    deletePendingWithdrawal(account.pendingWithdrawals, index);\n    require(value <= address(this).balance, \"Inconsistent balance\");\n    msg.sender.sendValue(value);\n    emit GoldWithdrawn(msg.sender, value);\n  }\n\n  /**\n   * @notice Returns the total amount of locked gold in the system. Note that this does not include\n   *   gold that has been unlocked but not yet withdrawn.\n   * @return The total amount of locked gold in the system.\n   */\n  function getTotalLockedGold() external view returns (uint256) {\n    return totalNonvoting.add(getElection().getTotalVotes());\n  }\n\n  /**\n   * @notice Returns the total amount of locked gold not being used to vote in elections.\n   * @return The total amount of locked gold not being used to vote in elections.\n   */\n  function getNonvotingLockedGold() external view returns (uint256) {\n    return totalNonvoting;\n  }\n\n  /**\n   * Delegates CELO to delegatee.\n   * @param delegatee The delegatee account.\n   * @param delegateFraction Fraction of total CELO that will be delegated from delegatee. Fixidity fraction\n   */\n  function delegateGovernanceVotes(address delegatee, uint256 delegateFraction) external {\n    FixidityLib.Fraction memory percentageToDelegate = FixidityLib.wrap(delegateFraction);\n    require(\n      FixidityLib.lte(percentageToDelegate, FixidityLib.fixed1()),\n      \"Delegate fraction must be less than or equal to 1\"\n    );\n    address delegatorAccount = getAccounts().voteSignerToAccount(msg.sender);\n    address delegateeAccount = getAccounts().voteSignerToAccount(delegatee);\n\n    IValidators validators = getValidators();\n    require(!validators.isValidator(delegatorAccount), \"Validators cannot delegate votes.\");\n    require(\n      !validators.isValidatorGroup(delegatorAccount),\n      \"Validator groups cannot delegate votes.\"\n    );\n\n    Delegated storage delegated = delegatorInfo[delegatorAccount];\n    delegated.delegatees.add(delegateeAccount);\n    require(delegated.delegatees.length() <= maxDelegateesCount, \"Too many delegatees\");\n\n    DelegatedInfo storage currentDelegateeInfo = delegated\n      .delegateesWithPercentagesAndAmount[delegateeAccount];\n\n    require(\n      FixidityLib.gte(percentageToDelegate, currentDelegateeInfo.percentage),\n      \"Cannot decrease delegated amount - use revokeDelegatedGovernanceVotes.\"\n    );\n\n    FixidityLib.Fraction memory requestedToDelegate = delegated\n      .totalDelegatedCeloFraction\n      .subtract(currentDelegateeInfo.percentage)\n      .add(percentageToDelegate);\n\n    require(\n      FixidityLib.lte(requestedToDelegate, FixidityLib.fixed1()),\n      \"Cannot delegate more than 100%\"\n    );\n\n    uint256 totalLockedGold = getAccountTotalLockedGold(delegatorAccount);\n    if (totalLockedGold == 0) {\n      delegated.totalDelegatedCeloFraction = delegated\n        .totalDelegatedCeloFraction\n        .subtract(currentDelegateeInfo.percentage)\n        .add(percentageToDelegate);\n      currentDelegateeInfo.percentage = percentageToDelegate;\n\n      emit CeloDelegated(\n        delegatorAccount,\n        delegateeAccount,\n        FixidityLib.unwrap(percentageToDelegate),\n        currentDelegateeInfo.currentAmount\n      );\n      return;\n    }\n\n    uint256 totalReferendumVotes = getGovernance().getAmountOfGoldUsedForVoting(delegatorAccount);\n\n    if (totalReferendumVotes != 0) {\n      FixidityLib.Fraction memory referendumVotesInPercents = FixidityLib.newFixedFraction(\n        totalReferendumVotes,\n        totalLockedGold\n      );\n      require(\n        FixidityLib.lte(referendumVotesInPercents.add(requestedToDelegate), FixidityLib.fixed1()),\n        \"Cannot delegate votes that are voting in referendum\"\n      );\n    }\n\n    // amount that will really be delegated - whatever is already\n    // delegated to this particular delagatee is already subracted from this\n    uint256 amountToDelegate = FixidityLib\n      .newFixed(totalLockedGold)\n      .multiply(percentageToDelegate)\n      .subtract(FixidityLib.newFixed(currentDelegateeInfo.currentAmount))\n      .fromFixed();\n\n    delegated.totalDelegatedCeloFraction = delegated\n      .totalDelegatedCeloFraction\n      .subtract(currentDelegateeInfo.percentage)\n      .add(percentageToDelegate);\n    currentDelegateeInfo.percentage = percentageToDelegate;\n\n    currentDelegateeInfo.currentAmount = currentDelegateeInfo.currentAmount.add(amountToDelegate);\n    totalDelegatedCelo[delegateeAccount] = totalDelegatedCelo[delegateeAccount].add(\n      amountToDelegate\n    );\n\n    emit CeloDelegated(\n      delegatorAccount,\n      delegateeAccount,\n      FixidityLib.unwrap(percentageToDelegate),\n      currentDelegateeInfo.currentAmount\n    );\n  }\n\n  /**\n   * Revokes delegated CELO.\n   * @param delegatee The delegatee acount.\n   * @param revokeFraction Fraction of total CELO that will be revoked from delegatee. Fixidity fraction\n   */\n  function revokeDelegatedGovernanceVotes(address delegatee, uint256 revokeFraction) external {\n    FixidityLib.Fraction memory percentageToRevoke = FixidityLib.wrap(revokeFraction);\n\n    require(\n      FixidityLib.lte(percentageToRevoke, FixidityLib.fixed1()),\n      \"Revoke fraction must be less than or equal to 1\"\n    );\n\n    address delegatorAccount = getAccounts().voteSignerToAccount(msg.sender);\n    Delegated storage delegated = delegatorInfo[delegatorAccount];\n    require(\n      FixidityLib.gte(delegated.totalDelegatedCeloFraction, percentageToRevoke),\n      \"Not enough total delegated percents\"\n    );\n\n    address delegateeAccount = getAccounts().voteSignerToAccount(delegatee);\n    _updateDelegatedAmount(delegatorAccount, delegateeAccount);\n\n    DelegatedInfo storage currentDelegateeInfo = delegated\n      .delegateesWithPercentagesAndAmount[delegateeAccount];\n\n    require(\n      FixidityLib.gte(currentDelegateeInfo.percentage, percentageToRevoke),\n      \"Not enough delegated percents\"\n    );\n\n    currentDelegateeInfo.percentage = currentDelegateeInfo.percentage.subtract(percentageToRevoke);\n\n    uint256 totalLockedGold = getAccountTotalLockedGold(delegatorAccount);\n\n    uint256 amountToRevoke = FixidityLib.unwrap(currentDelegateeInfo.percentage) == 0\n      ? currentDelegateeInfo.currentAmount\n      : Math.min(\n        FixidityLib.newFixed(totalLockedGold).multiply(percentageToRevoke).fromFixed(),\n        currentDelegateeInfo.currentAmount\n      );\n\n    _decreaseDelegateeVotingPower(delegateeAccount, amountToRevoke, currentDelegateeInfo);\n\n    delegated.totalDelegatedCeloFraction = delegated.totalDelegatedCeloFraction.subtract(\n      percentageToRevoke\n    );\n\n    if (FixidityLib.unwrap(currentDelegateeInfo.percentage) == 0) {\n      delegated.delegatees.remove(delegateeAccount);\n    }\n\n    emit DelegatedCeloRevoked(\n      delegatorAccount,\n      delegateeAccount,\n      FixidityLib.unwrap(percentageToRevoke),\n      amountToRevoke\n    );\n  }\n\n  /**\n   * Revokes amount during unlocking. It will revoke votes from voted proposals if necessary.\n   * @param delegator The delegator account.\n   * @param amountToRevoke The amount to revoke.\n   */\n  function revokeFromDelegatedWhenUnlocking(address delegator, uint256 amountToRevoke) private {\n    address[] memory delegatees = getDelegateesOfDelegator(delegator);\n\n    Delegated storage delegated = delegatorInfo[delegator];\n\n    for (uint256 i = 0; i < delegatees.length; i = i.add(1)) {\n      DelegatedInfo storage currentDelegateeInfo = delegated\n        .delegateesWithPercentagesAndAmount[delegatees[i]];\n      (uint256 expected, uint256 real) = _getDelegatorDelegateeExpectedAndRealAmount(\n        delegator,\n        delegatees[i]\n      );\n      uint256 delegateeAmountToRevoke = FixidityLib\n        .newFixed(amountToRevoke)\n        .multiply(currentDelegateeInfo.percentage)\n        .fromFixed();\n      delegateeAmountToRevoke = delegateeAmountToRevoke.sub(expected.sub(real));\n      _decreaseDelegateeVotingPower(delegatees[i], delegateeAmountToRevoke, currentDelegateeInfo);\n      emit DelegatedCeloRevoked(delegator, delegatees[i], 0, delegateeAmountToRevoke);\n    }\n  }\n\n  /**\n   * Decreases delegatee voting power when removing or unlocking delegated votes.\n   * @param delegatee The delegatee.\n   * @param amountToRevoke Amount to revoke.\n   * @param delegateeInfo Delegatee info.\n   */\n  function _decreaseDelegateeVotingPower(\n    address delegatee,\n    uint256 amountToRevoke,\n    DelegatedInfo storage delegateeInfo\n  ) private {\n    uint256 delegateeTotalVotingPower = getAccountTotalGovernanceVotingPower(delegatee);\n    uint256 totalReferendumVotes = getGovernance().getAmountOfGoldUsedForVoting(delegatee);\n    uint256 unusedReferendumVotes = delegateeTotalVotingPower.sub(totalReferendumVotes);\n    if (unusedReferendumVotes < amountToRevoke) {\n      getGovernance().removeVotesWhenRevokingDelegatedVotes(\n        delegatee,\n        delegateeTotalVotingPower.sub(amountToRevoke)\n      );\n    }\n    delegateeInfo.currentAmount = delegateeInfo.currentAmount.sub(amountToRevoke);\n    totalDelegatedCelo[delegatee] = totalDelegatedCelo[delegatee].sub(amountToRevoke);\n  }\n\n  /**\n   * Updates real delegated amount to all delegator's delegatees.\n   * There might be discrepancy because of validator rewards or extra locked gold.\n   * @param delegator The delegator address.\n   */\n  function updateDelegatedAmount(address delegator) public {\n    address delegatorAccount = getAccounts().voteSignerToAccount(delegator);\n    _updateDelegatedAmount(delegatorAccount);\n  }\n\n  function _updateDelegatedAmount(address delegator) private {\n    address delegatorAccount = getAccounts().voteSignerToAccount(delegator);\n    EnumerableSet.AddressSet storage delegatees = delegatorInfo[delegatorAccount].delegatees;\n    for (uint256 i = 0; i < delegatees.length(); i = i.add(1)) {\n      _updateDelegatedAmount(delegatorAccount, delegatees.get(i));\n    }\n  }\n\n  /**\n   * Updates real delegated amount to delegatee.\n   * There might be discrepancy because of validator rewards or extra locked gold.\n   * Voting power will always be smaller or equal to what it is supposed to be.\n   * @param delegator The delegator address.\n   * @param delegatee The delegatee address.\n   */\n  function updateDelegatedAmount(address delegator, address delegatee) public returns (uint256) {\n    address delegatorAccount = getAccounts().voteSignerToAccount(delegator);\n    address delegateeAccount = getAccounts().voteSignerToAccount(delegatee);\n\n    return _updateDelegatedAmount(delegatorAccount, delegateeAccount);\n  }\n\n  /**\n   * Updates real delegated amount to delegatee.\n   * There might be discrepancy because of validator rewards or extra locked gold.\n   * Voting power will always be smaller or equal to what it is supposed to be.\n   * @param delegator The delegator address.\n   * @param delegatee The delegatee address.\n   */\n  function _updateDelegatedAmount(address delegator, address delegatee) internal returns (uint256) {\n    Delegated storage delegated = delegatorInfo[delegator];\n    require(\n      FixidityLib.unwrap(delegated.totalDelegatedCeloFraction) != 0,\n      \"delegator is not delegating\"\n    );\n    DelegatedInfo storage currentDelegateeInfo = delegated\n      .delegateesWithPercentagesAndAmount[delegatee];\n    require(\n      FixidityLib.unwrap(currentDelegateeInfo.percentage) != 0,\n      \"delegator is not delegating for delegatee\"\n    );\n\n    (uint256 expected, uint256 real) = getDelegatorDelegateeExpectedAndRealAmount(\n      delegator,\n      delegatee\n    );\n\n    currentDelegateeInfo.currentAmount = expected;\n    totalDelegatedCelo[delegatee] = totalDelegatedCelo[delegatee].sub(real).add(expected);\n\n    return expected;\n  }\n\n  /**\n   * Returns how many percents of CELO is account delegating.\n   * @param account The account address.\n   */\n  function getAccountTotalDelegatedFraction(address account) public view returns (uint256) {\n    Delegated storage delegated = delegatorInfo[account];\n    return FixidityLib.unwrap(delegated.totalDelegatedCeloFraction);\n  }\n\n  /**\n   * @notice Returns the total amount of locked gold for an account.\n   * @param account The account.\n   * @return The total amount of locked gold for an account.\n   */\n  function getAccountTotalLockedGold(address account) public view returns (uint256) {\n    uint256 total = balances[account].nonvoting;\n    return total.add(getElection().getTotalVotesByAccount(account));\n  }\n\n  /**\n   * @notice Returns the total amount of locked gold + delegated gold for an account.\n   * @param account The account.\n   * @return The total amount of locked gold + delegated gold for an account.\n   */\n  function getAccountTotalGovernanceVotingPower(address account) public view returns (uint256) {\n    FixidityLib.Fraction memory availableUndelegatedPercents = FixidityLib.fixed1().subtract(\n      FixidityLib.wrap(getAccountTotalDelegatedFraction(account))\n    );\n    uint256 totalLockedGold = getAccountTotalLockedGold(account);\n\n    uint256 availableForVoting = FixidityLib\n      .newFixed(totalLockedGold)\n      .multiply(availableUndelegatedPercents)\n      .fromFixed();\n\n    return availableForVoting.add(totalDelegatedCelo[account]);\n  }\n\n  /**\n * Return percentage and amount that delegator assigned to delegateee.\n * Please note that amount doesn't have to be up to date. \n * In such case please use `updateDelegatedBalance`.\n * @param delegator The delegator address.\n * @param delegatee The delegatee address.\n * @return fraction The fraction that is delegator asigning to delegatee.\n * @return currentAmount The current actual Celo amount that is assigned to delegatee.\n */\n  function getDelegatorDelegateeInfo(address delegator, address delegatee)\n    external\n    view\n    returns (uint256 fraction, uint256 currentAmount)\n  {\n    DelegatedInfo storage currentDelegateeInfo = delegatorInfo[delegator]\n      .delegateesWithPercentagesAndAmount[delegatee];\n\n    fraction = FixidityLib.unwrap(currentDelegateeInfo.percentage);\n    currentAmount = currentDelegateeInfo.currentAmount;\n  }\n\n  /**\n   * Returns expected vs real delegated amount. \n   * If there is a discrepancy it can be fixed by calling `updateDelegatedAmount` function.\n   * @param delegator The delegator address.\n   * @param delegatee The delegatee address.\n   * @return expected The expected amount.\n   * @return real The real amount. \n   */\n  function getDelegatorDelegateeExpectedAndRealAmount(address delegator, address delegatee)\n    public\n    view\n    returns (uint256 expected, uint256 real)\n  {\n    address delegatorAccount = getAccounts().voteSignerToAccount(delegator);\n    address delegateeAccount = getAccounts().voteSignerToAccount(delegatee);\n\n    (expected, real) = _getDelegatorDelegateeExpectedAndRealAmount(\n      delegatorAccount,\n      delegateeAccount\n    );\n  }\n\n  /**\n   * Returns expected vs real delegated amount. \n   * If there is a discrepancy it can be fixed by calling `updateDelegatedAmount` function.\n   * @param delegator The delegator address.\n   * @param delegatee The delegatee address.\n   * @return expected The expected amount.\n   * @return real The real amount. \n   */\n  function _getDelegatorDelegateeExpectedAndRealAmount(address delegator, address delegatee)\n    private\n    view\n    returns (uint256 expected, uint256 real)\n  {\n    DelegatedInfo storage currentDelegateeInfo = delegatorInfo[delegator]\n      .delegateesWithPercentagesAndAmount[delegatee];\n\n    uint256 amountToDelegate = FixidityLib\n      .newFixed(getAccountTotalLockedGold(delegator))\n      .multiply(currentDelegateeInfo.percentage)\n      .fromFixed();\n\n    expected = amountToDelegate;\n    real = currentDelegateeInfo.currentAmount;\n  }\n\n  /**\n   * Retuns all delegatees of delegator\n   * @param delegator The delegator address.\n   */\n  function getDelegateesOfDelegator(address delegator) public view returns (address[] memory) {\n    address[] memory values = delegatorInfo[delegator].delegatees.enumerate();\n    return values;\n  }\n\n  /**\n   * @notice Returns the total amount of non-voting locked gold for an account.\n   * @param account The account.\n   * @return The total amount of non-voting locked gold for an account.\n   */\n  function getAccountNonvotingLockedGold(address account) external view returns (uint256) {\n    return balances[account].nonvoting;\n  }\n\n  /**\n   * @notice Returns the pending withdrawals from unlocked gold for an account.\n   * @param account The address of the account.\n   * @return The value for each pending withdrawal.\n   * @return The timestamp for each pending withdrawal.\n   */\n  function getPendingWithdrawals(address account)\n    external\n    view\n    returns (uint256[] memory, uint256[] memory)\n  {\n    require(\n      getAccounts().isAccount(account),\n      \"Unknown account: only registered accounts have pending withdrawals\"\n    );\n    uint256 length = balances[account].pendingWithdrawals.length;\n    uint256[] memory values = new uint256[](length);\n    uint256[] memory timestamps = new uint256[](length);\n    for (uint256 i = 0; i < length; i = i.add(1)) {\n      PendingWithdrawal memory pendingWithdrawal = (balances[account].pendingWithdrawals[i]);\n      values[i] = pendingWithdrawal.value;\n      timestamps[i] = pendingWithdrawal.timestamp;\n    }\n    return (values, timestamps);\n  }\n\n  /**\n   * @notice Returns the pending withdrawal at a given index for a given account.\n   * @param account The address of the account.\n   * @param index The index of the pending withdrawal.\n   * @return The value of the pending withdrawal.\n   * @return The timestamp of the pending withdrawal.\n   */\n  function getPendingWithdrawal(address account, uint256 index)\n    external\n    view\n    returns (uint256, uint256)\n  {\n    require(\n      getAccounts().isAccount(account),\n      \"Unknown account: only registered accounts have pending withdrawals\"\n    );\n    require(index < balances[account].pendingWithdrawals.length, \"Bad pending withdrawal index\");\n    PendingWithdrawal memory pendingWithdrawal = (balances[account].pendingWithdrawals[index]);\n\n    return (pendingWithdrawal.value, pendingWithdrawal.timestamp);\n  }\n\n  /**\n    * @notice Returns the number of pending withdrawals for the specified account.\n    * @param account The address of the account.\n    * @return The count of pending withdrawals.\n    */\n  function getTotalPendingWithdrawalsCount(address account) external view returns (uint256) {\n    return balances[account].pendingWithdrawals.length;\n  }\n\n  /**\n   * @notice Returns the total amount to withdraw from unlocked gold for an account.\n   * @param account The address of the account.\n   * @return Total amount to withdraw.\n   */\n  function getTotalPendingWithdrawals(address account) external view returns (uint256) {\n    uint256 pendingWithdrawalSum = 0;\n    PendingWithdrawal[] memory withdrawals = balances[account].pendingWithdrawals;\n    for (uint256 i = 0; i < withdrawals.length; i = i.add(1)) {\n      pendingWithdrawalSum = pendingWithdrawalSum.add(withdrawals[i].value);\n    }\n    return pendingWithdrawalSum;\n  }\n\n  function getSlashingWhitelist() external view returns (bytes32[] memory) {\n    return slashingWhitelist;\n  }\n\n  /**\n   * @notice Deletes a pending withdrawal.\n   * @param list The list of pending withdrawals from which to delete.\n   * @param index The index of the pending withdrawal to delete.\n   */\n  function deletePendingWithdrawal(PendingWithdrawal[] storage list, uint256 index) private {\n    uint256 lastIndex = list.length.sub(1);\n    list[index] = list[lastIndex];\n    list.length = lastIndex;\n  }\n\n  /**\n   * @notice Adds `slasher` to whitelist of approved slashing addresses.\n   * @param slasherIdentifier Identifier to whitelist.\n   */\n  function addSlasher(string calldata slasherIdentifier) external onlyOwner {\n    bytes32 keyBytes = keccak256(abi.encodePacked(slasherIdentifier));\n    require(registry.getAddressFor(keyBytes) != address(0), \"Identifier is not registered\");\n    require(!slashingMap[keyBytes], \"Cannot add slasher ID twice.\");\n    slashingWhitelist.push(keyBytes);\n    slashingMap[keyBytes] = true;\n    emit SlasherWhitelistAdded(slasherIdentifier);\n  }\n\n  /**\n   * @notice Removes `slasher` from whitelist of approved slashing addresses.\n   * @param slasherIdentifier Identifier to remove from whitelist.\n   * @param index Index of the provided identifier in slashingWhiteList array.\n   */\n  function removeSlasher(string calldata slasherIdentifier, uint256 index) external onlyOwner {\n    bytes32 keyBytes = keccak256(abi.encodePacked(slasherIdentifier));\n    require(slashingMap[keyBytes], \"Cannot remove slasher ID not yet added.\");\n    require(index < slashingWhitelist.length, \"Provided index exceeds whitelist bounds.\");\n    require(slashingWhitelist[index] == keyBytes, \"Index doesn't match identifier\");\n    slashingWhitelist[index] = slashingWhitelist[slashingWhitelist.length - 1];\n    slashingWhitelist.pop();\n    slashingMap[keyBytes] = false;\n    emit SlasherWhitelistRemoved(slasherIdentifier);\n  }\n\n  /**\n   * @notice Slashes `account` by reducing its nonvoting locked gold by `penalty`.\n   *         If there is not enough nonvoting locked gold to slash, calls into\n   *         `Election.slashVotes` to slash the remaining gold. If `account` does not have\n   *         `penalty` worth of locked gold, slashes `account`'s total locked gold.\n   *         Also sends `reward` gold to the reporter, and penalty-reward to the Community Fund.\n   * @param account Address of account being slashed.\n   * @param penalty Amount to slash account.\n   * @param reporter Address of account reporting the slasher.\n   * @param reward Reward to give reporter.\n   * @param lessers The groups receiving fewer votes than i'th group, or 0 if the i'th group has\n   *                the fewest votes of any validator group.\n   * @param greaters The groups receiving more votes than the i'th group, or 0 if the i'th group\n   *                 has the most votes of any validator group.\n   * @param indices The indices of the i'th group in `account`'s voting list.\n   * @dev Fails if `reward` is greater than `account`'s total locked gold.\n   */\n  function slash(\n    address account,\n    uint256 penalty,\n    address reporter,\n    uint256 reward,\n    address[] calldata lessers,\n    address[] calldata greaters,\n    uint256[] calldata indices\n  ) external onlySlasher {\n    uint256 maxSlash = Math.min(penalty, getAccountTotalLockedGold(account));\n    require(maxSlash >= reward, \"reward cannot exceed penalty.\");\n    // `reporter` receives the reward in locked CELO, so it must be given to an account\n    // There is no reward for slashing via the GovernanceSlasher, and `reporter`\n    // is set to 0x0.\n    if (reporter != address(0)) {\n      reporter = getAccounts().signerToAccount(reporter);\n    }\n    // Local scoping is required to avoid Solc \"stack too deep\" error from too many locals.\n    {\n      uint256 nonvotingBalance = balances[account].nonvoting;\n      uint256 difference = 0;\n      // If not enough nonvoting, revoke the difference\n      if (nonvotingBalance < maxSlash) {\n        difference = maxSlash.sub(nonvotingBalance);\n        require(\n          getElection().forceDecrementVotes(account, difference, lessers, greaters, indices) ==\n            difference,\n          \"Cannot revoke enough voting gold.\"\n        );\n      }\n      // forceDecrementVotes does not increment nonvoting account balance, so we can't double count\n      _decrementNonvotingAccountBalance(account, maxSlash.sub(difference));\n      _incrementNonvotingAccountBalance(reporter, reward);\n    }\n    address communityFund = registry.getAddressForOrDie(GOVERNANCE_REGISTRY_ID);\n    address payable communityFundPayable = address(uint160(communityFund));\n    require(maxSlash.sub(reward) <= address(this).balance, \"Inconsistent balance\");\n    communityFundPayable.sendValue(maxSlash.sub(reward));\n    emit AccountSlashed(account, maxSlash, reporter, reward);\n  }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "isSlasher",
                "getVersionNumber",
                "initialize",
                "setUnlockingPeriod",
                "setMaxDelegateesCount",
                "lock",
                "incrementNonvotingAccountBalance",
                "decrementNonvotingAccountBalance",
                "_incrementNonvotingAccountBalance",
                "_decrementNonvotingAccountBalance",
                "unlock",
                "relock",
                "withdraw",
                "getTotalLockedGold",
                "getNonvotingLockedGold",
                "delegateGovernanceVotes",
                "revokeDelegatedGovernanceVotes",
                "revokeFromDelegatedWhenUnlocking",
                "_decreaseDelegateeVotingPower",
                "updateDelegatedAmount",
                "_updateDelegatedAmount",
                "getAccountTotalDelegatedFraction",
                "getAccountTotalLockedGold",
                "getAccountTotalGovernanceVotingPower",
                "getDelegatorDelegateeInfo",
                "getDelegatorDelegateeExpectedAndRealAmount",
                "_getDelegatorDelegateeExpectedAndRealAmount",
                "getDelegateesOfDelegator",
                "getAccountNonvotingLockedGold",
                "getPendingWithdrawals",
                "getPendingWithdrawal",
                "getTotalPendingWithdrawalsCount",
                "getTotalPendingWithdrawals",
                "getSlashingWhitelist",
                "deletePendingWithdrawal",
                "addSlasher",
                "removeSlasher",
                "slash"
            ],
            "state_variables": [
                "delegateesWithPercentagesAndAmount",
                "nonvoting",
                "slashingWhitelist",
                "totalDelegatedCelo",
                "totalNonvoting",
                "slashingMap",
                "currentAmount",
                "maxDelegateesCount",
                "payable",
                "delegatorInfo",
                "balances",
                "timestamp",
                "value",
                "unlockingPeriod"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "LockedGold_totalNonVotingGEAccountNonVoting_9a241ef1",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LockedGold.sol",
        "target_function": "decrementNonvotingAccountBalance/getAccountNonvotingLockedGold/getNonvotingLockedGold/incrementNonvotingAccountBalance/lock/slash/unlock",
        "text_chunk": "  function decrementNonvotingAccountBalance(address account, uint256 value)\n    external\n    onlyRegisteredContract(ELECTION_REGISTRY_ID)\n  {\n    _decrementNonvotingAccountBalance(account, value);\n  }\n\n\n  function getAccountNonvotingLockedGold(address account) external view returns (uint256) {\n    return balances[account].nonvoting;\n  }\n\n\n  function getNonvotingLockedGold() external view returns (uint256) {\n    return totalNonvoting;\n  }\n\n\n  function incrementNonvotingAccountBalance(address account, uint256 value)\n    external\n    onlyRegisteredContract(ELECTION_REGISTRY_ID)\n  {\n    _incrementNonvotingAccountBalance(account, value);\n  }\n\n\n  function lock() external payable nonReentrant {\n    require(\n      getAccounts().isAccount(msg.sender),\n      \"Must first register address with Account.createAccount\"\n    );\n    _incrementNonvotingAccountBalance(msg.sender, msg.value);\n    _updateDelegatedAmount(msg.sender);\n    emit GoldLocked(msg.sender, msg.value);\n  }\n\n\n  function slash(\n    address account,\n    uint256 penalty,\n    address reporter,\n    uint256 reward,\n    address[] calldata lessers,\n    address[] calldata greaters,\n    uint256[] calldata indices\n  ) external onlySlasher {\n    uint256 maxSlash = Math.min(penalty, getAccountTotalLockedGold(account));\n    require(maxSlash >= reward, \"reward cannot exceed penalty.\");\n    // `reporter` receives the reward in locked CELO, so it must be given to an account\n    // There is no reward for slashing via the GovernanceSlasher, and `reporter`\n    // is set to 0x0.\n    if (reporter != address(0)) {\n      reporter = getAccounts().signerToAccount(reporter);\n    }\n    // Local scoping is required to avoid Solc \"stack too deep\" error from too many locals.\n    {\n      uint256 nonvotingBalance = balances[account].nonvoting;\n      uint256 difference = 0;\n      // If not enough nonvoting, revoke the difference\n      if (nonvotingBalance < maxSlash) {\n        difference = maxSlash.sub(nonvotingBalance);\n        require(\n          getElection().forceDecrementVotes(account, difference, lessers, greaters, indices) ==\n            difference,\n          \"Cannot revoke enough voting gold.\"\n        );\n      }\n      // forceDecrementVotes does not increment nonvoting account balance, so we can't double count\n      _decrementNonvotingAccountBalance(account, maxSlash.sub(difference));\n      _incrementNonvotingAccountBalance(reporter, reward);\n    }\n    address communityFund = registry.getAddressForOrDie(GOVERNANCE_REGISTRY_ID);\n    address payable communityFundPayable = address(uint160(communityFund));\n    require(maxSlash.sub(reward) <= address(this).balance, \"Inconsistent balance\");\n    communityFundPayable.sendValue(maxSlash.sub(reward));\n    emit AccountSlashed(account, maxSlash, reporter, reward);\n  }\n\n\n  function unlock(uint256 value) external nonReentrant {\n    require(\n      getAccounts().isAccount(msg.sender),\n      \"Sender must be registered with Account.createAccount to lock or unlock\"\n    );\n    Balances storage account = balances[msg.sender];\n\n    uint256 totalLockedGold = getAccountTotalLockedGold(msg.sender);\n    // Prevent unlocking gold when voting on governance proposals so that the gold cannot be\n    // used to vote more than once.\n    uint256 remainingLockedGold = totalLockedGold.sub(value);\n\n    uint256 totalReferendumVotes = getGovernance().getAmountOfGoldUsedForVoting(msg.sender);\n    require(\n      remainingLockedGold >= totalReferendumVotes,\n      \"Not enough unlockable celo. Celo is locked in voting.\"\n    );\n\n    FixidityLib.Fraction memory delegatedPercentage = delegatorInfo[msg.sender]\n      .totalDelegatedCeloFraction;\n\n    if (FixidityLib.gt(delegatedPercentage, FixidityLib.newFixed(0))) {\n      revokeFromDelegatedWhenUnlocking(msg.sender, value);\n    }\n\n    uint256 balanceRequirement = getValidators().getAccountLockedGoldRequirement(msg.sender);\n    require(\n      balanceRequirement == 0 || balanceRequirement <= remainingLockedGold,\n      \"Either account doesn't have enough locked Celo or locked Celo is being used for voting.\"\n    );\n    _decrementNonvotingAccountBalance(msg.sender, value);\n    uint256 available = now.add(unlockingPeriod);\n    // CERTORA: the slot containing the length could be MAX_UINT\n    account.pendingWithdrawals.push(PendingWithdrawal(value, available));\n    emit GoldUnlocked(msg.sender, value, available);\n  }\n",
        "formal_property": "rule totalNonVotingGEAccountNonVoting(address a, method f) {\n\trequire(sinvoke getNonvotingLockedGold()  >= sinvoke getAccountNonvotingLockedGold(a));\n\trequire(\n    f.selector != decrementNonvotingAccountBalance(address,uint256).selector &&\n    f.selector != incrementNonvotingAccountBalance(address,uint256).selector\n  );\n\tenv eF; \n    (f.selector != unlock(uint256).selector || eF.msg.sender == a) &&\n    f.selector != slash(address,uint256,address,uint256,address[],address[],uint256[]).selector\n\tcalldataarg arg;\n\tsinvoke f(eF,arg);\n\tassert(sinvoke getNonvotingLockedGold() >= sinvoke getAccountNonvotingLockedGold(a));\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "totalNonVotingGEAccountNonVoting",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "getNonvotingLockedGold",
                "getAccountNonvotingLockedGold",
                "incrementNonvotingAccountBalance",
                "decrementNonvotingAccountBalance",
                "unlock"
            ],
            "start_line": 27,
            "end_line": 41,
            "block_hash": "9a241ef1d93b65fa53961700b811aa8c"
        }
    },
    {
        "id": "LockedGold_totalPreserved_4034bb21",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LockedGold.sol",
        "target_function": "decrementNonvotingAccountBalance/getAccountNonvotingLockedGold/getTotalPendingWithdrawals/incrementNonvotingAccountBalance/slash",
        "text_chunk": "  function decrementNonvotingAccountBalance(address account, uint256 value)\n    external\n    onlyRegisteredContract(ELECTION_REGISTRY_ID)\n  {\n    _decrementNonvotingAccountBalance(account, value);\n  }\n\n\n  function getAccountNonvotingLockedGold(address account) external view returns (uint256) {\n    return balances[account].nonvoting;\n  }\n\n\n  function getTotalPendingWithdrawals(address account) external view returns (uint256) {\n    uint256 pendingWithdrawalSum = 0;\n    PendingWithdrawal[] memory withdrawals = balances[account].pendingWithdrawals;\n    for (uint256 i = 0; i < withdrawals.length; i = i.add(1)) {\n      pendingWithdrawalSum = pendingWithdrawalSum.add(withdrawals[i].value);\n    }\n    return pendingWithdrawalSum;\n  }\n\n\n  function incrementNonvotingAccountBalance(address account, uint256 value)\n    external\n    onlyRegisteredContract(ELECTION_REGISTRY_ID)\n  {\n    _incrementNonvotingAccountBalance(account, value);\n  }\n\n\n  function slash(\n    address account,\n    uint256 penalty,\n    address reporter,\n    uint256 reward,\n    address[] calldata lessers,\n    address[] calldata greaters,\n    uint256[] calldata indices\n  ) external onlySlasher {\n    uint256 maxSlash = Math.min(penalty, getAccountTotalLockedGold(account));\n    require(maxSlash >= reward, \"reward cannot exceed penalty.\");\n    // `reporter` receives the reward in locked CELO, so it must be given to an account\n    // There is no reward for slashing via the GovernanceSlasher, and `reporter`\n    // is set to 0x0.\n    if (reporter != address(0)) {\n      reporter = getAccounts().signerToAccount(reporter);\n    }\n    // Local scoping is required to avoid Solc \"stack too deep\" error from too many locals.\n    {\n      uint256 nonvotingBalance = balances[account].nonvoting;\n      uint256 difference = 0;\n      // If not enough nonvoting, revoke the difference\n      if (nonvotingBalance < maxSlash) {\n        difference = maxSlash.sub(nonvotingBalance);\n        require(\n          getElection().forceDecrementVotes(account, difference, lessers, greaters, indices) ==\n            difference,\n          \"Cannot revoke enough voting gold.\"\n        );\n      }\n      // forceDecrementVotes does not increment nonvoting account balance, so we can't double count\n      _decrementNonvotingAccountBalance(account, maxSlash.sub(difference));\n      _incrementNonvotingAccountBalance(reporter, reward);\n    }\n    address communityFund = registry.getAddressForOrDie(GOVERNANCE_REGISTRY_ID);\n    address payable communityFundPayable = address(uint160(communityFund));\n    require(maxSlash.sub(reward) <= address(this).balance, \"Inconsistent balance\");\n    communityFundPayable.sendValue(maxSlash.sub(reward));\n    emit AccountSlashed(account, maxSlash, reporter, reward);\n  }\n",
        "formal_property": "rule totalPreserved(address account, method f) {\n\t// We assume the sender is not the currentContract\n\trequire(account != currentContract);\n\tuint256 _ercBalance = sinvoke ercBalanceOf(account); \n\tuint256 _accountNonVoting = sinvoke getAccountNonvotingLockedGold(account);\n\tuint256 _accountTotalPendingWithdrawals =  sinvoke getTotalPendingWithdrawals(account);\n\t// We limit the amount of pending records due to loop handling \n\trequire sinvoke getPendingWithdrawalsLength(account) <= 1;\n\tenv eF;\n\trequire(eF.msg.sender == account);\n\t// These three function are exceptions to the rule (they are designed to affect total)\n\trequire(\n    f.selector != decrementNonvotingAccountBalance(address,uint256).selector &&\n    f.selector != incrementNonvotingAccountBalance(address,uint256).selector &&\n    f.selector != slash(address,uint256,address,uint256,address[],address[],uint256[]).selector\n  );\n\tcalldataarg arg;\n\tsinvoke f(eF,arg);\n\tuint length = sinvoke getPendingWithdrawalsLength(account);\n\trequire(length <= 1);\n\tuint256 ercBalance_ = sinvoke ercBalanceOf(account);\n\tuint256 accountNonVoting_ = sinvoke getAccountNonvotingLockedGold(account);\n\tuint256 accountTotalPendingWithdrawals_ =  sinvoke getTotalPendingWithdrawals(account);\n  assert(\n    _ercBalance + _accountNonVoting + _accountTotalPendingWithdrawals ==\n    ercBalance_ + accountNonVoting_ + accountTotalPendingWithdrawals_,\n    \"Total of tokens not preserved\"\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "totalPreserved",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "getAccountNonvotingLockedGold",
                "ercBalanceOf",
                "getTotalPendingWithdrawals",
                "getPendingWithdrawalsLength",
                "incrementNonvotingAccountBalance",
                "decrementNonvotingAccountBalance"
            ],
            "start_line": 46,
            "end_line": 75,
            "block_hash": "4034bb2100eb9bf27d0cd96e52135aaf"
        }
    },
    {
        "id": "LockedGold_noChangeByOther_5e88b77c",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LockedGold.sol",
        "target_function": "decrementNonvotingAccountBalance/getAccountNonvotingLockedGold/getTotalPendingWithdrawals/incrementNonvotingAccountBalance/slash/withdraw",
        "text_chunk": "  function decrementNonvotingAccountBalance(address account, uint256 value)\n    external\n    onlyRegisteredContract(ELECTION_REGISTRY_ID)\n  {\n    _decrementNonvotingAccountBalance(account, value);\n  }\n\n\n  function getAccountNonvotingLockedGold(address account) external view returns (uint256) {\n    return balances[account].nonvoting;\n  }\n\n\n  function getTotalPendingWithdrawals(address account) external view returns (uint256) {\n    uint256 pendingWithdrawalSum = 0;\n    PendingWithdrawal[] memory withdrawals = balances[account].pendingWithdrawals;\n    for (uint256 i = 0; i < withdrawals.length; i = i.add(1)) {\n      pendingWithdrawalSum = pendingWithdrawalSum.add(withdrawals[i].value);\n    }\n    return pendingWithdrawalSum;\n  }\n\n\n  function incrementNonvotingAccountBalance(address account, uint256 value)\n    external\n    onlyRegisteredContract(ELECTION_REGISTRY_ID)\n  {\n    _incrementNonvotingAccountBalance(account, value);\n  }\n\n\n  function slash(\n    address account,\n    uint256 penalty,\n    address reporter,\n    uint256 reward,\n    address[] calldata lessers,\n    address[] calldata greaters,\n    uint256[] calldata indices\n  ) external onlySlasher {\n    uint256 maxSlash = Math.min(penalty, getAccountTotalLockedGold(account));\n    require(maxSlash >= reward, \"reward cannot exceed penalty.\");\n    // `reporter` receives the reward in locked CELO, so it must be given to an account\n    // There is no reward for slashing via the GovernanceSlasher, and `reporter`\n    // is set to 0x0.\n    if (reporter != address(0)) {\n      reporter = getAccounts().signerToAccount(reporter);\n    }\n    // Local scoping is required to avoid Solc \"stack too deep\" error from too many locals.\n    {\n      uint256 nonvotingBalance = balances[account].nonvoting;\n      uint256 difference = 0;\n      // If not enough nonvoting, revoke the difference\n      if (nonvotingBalance < maxSlash) {\n        difference = maxSlash.sub(nonvotingBalance);\n        require(\n          getElection().forceDecrementVotes(account, difference, lessers, greaters, indices) ==\n            difference,\n          \"Cannot revoke enough voting gold.\"\n        );\n      }\n      // forceDecrementVotes does not increment nonvoting account balance, so we can't double count\n      _decrementNonvotingAccountBalance(account, maxSlash.sub(difference));\n      _incrementNonvotingAccountBalance(reporter, reward);\n    }\n    address communityFund = registry.getAddressForOrDie(GOVERNANCE_REGISTRY_ID);\n    address payable communityFundPayable = address(uint160(communityFund));\n    require(maxSlash.sub(reward) <= address(this).balance, \"Inconsistent balance\");\n    communityFundPayable.sendValue(maxSlash.sub(reward));\n    emit AccountSlashed(account, maxSlash, reporter, reward);\n  }\n\n\n  function withdraw(uint256 index) external nonReentrant {\n    require(\n      getAccounts().isAccount(msg.sender),\n      \"Sender must be registered with Account.createAccount to withdraw\"\n    );\n    Balances storage account = balances[msg.sender];\n    require(index < account.pendingWithdrawals.length, \"Bad pending withdrawal index\");\n    PendingWithdrawal storage pendingWithdrawal = account.pendingWithdrawals[index];\n    require(now >= pendingWithdrawal.timestamp, \"Pending withdrawal not available\");\n    uint256 value = pendingWithdrawal.value;\n    deletePendingWithdrawal(account.pendingWithdrawals, index);\n    require(value <= address(this).balance, \"Inconsistent balance\");\n    msg.sender.sendValue(value);\n    emit GoldWithdrawn(msg.sender, value);\n  }\n",
        "formal_property": "rule noChangeByOther(address a, address b, method f) {\n\trequire(a != b);\n\t// We assume the sender is not the currentContract\n\trequire(\n    a != currentContract &&\n    (a == sinvoke getGoldTokenExt() => f.selector != withdraw(uint256).selector));\n\tuint256 _ercBalance = sinvoke ercBalanceOf(a);\n\tuint256 _accountNonVoting = sinvoke getAccountNonvotingLockedGold(a);\n\tuint256 _accountTotalPendingWithdrawals =  sinvoke getTotalPendingWithdrawals(a);\n\t// We limit the amount of pending records due to loop handling \n\tuint length = sinvoke getPendingWithdrawalsLength(a);\n\trequire(length <= 1);\n\tenv eF;\n\trequire(eF.msg.sender == b);\n\tcalldataarg arg;\n    f.selector != decrementNonvotingAccountBalance(address,uint256).selector &&\n    f.selector != incrementNonvotingAccountBalance(address,uint256).selector &&\n    f.selector != slash(address,uint256,address,uint256,address[],address[],uint256[]).selector\n  );\n\tsinvoke f(eF,arg);\n\tuint256 ercBalance_ = sinvoke ercBalanceOf(a); \n\tuint256 accountNonVoting_ = sinvoke getAccountNonvotingLockedGold(a);\n\tuint256 accountTotalPendingWithdrawals_ =  sinvoke getTotalPendingWithdrawals(a);\n\tassert(f.selector != withdraw(uint256).selector => _ercBalance == ercBalance_, \"Unexpected change to erc tokens\");\n\tassert(_accountTotalPendingWithdrawals == accountTotalPendingWithdrawals_, \"Unexpected change to total pending\");\n\tassert(_accountNonVoting == accountNonVoting_, \"Unexpected change to account nonvoting\");\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "noChangeByOther",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "getAccountNonvotingLockedGold",
                "ercBalanceOf",
                "getTotalPendingWithdrawals",
                "getPendingWithdrawalsLength",
                "incrementNonvotingAccountBalance",
                "decrementNonvotingAccountBalance",
                "getGoldTokenExt"
            ],
            "start_line": 80,
            "end_line": 107,
            "block_hash": "5e88b77ce11bf44dd69edfc03ca66f57"
        }
    },
    {
        "id": "LockedGold_verifies_6c8067de",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LockedGold.sol",
        "target_function": "withdraw",
        "text_chunk": "  function withdraw(uint256 index) external nonReentrant {\n    require(\n      getAccounts().isAccount(msg.sender),\n      \"Sender must be registered with Account.createAccount to withdraw\"\n    );\n    Balances storage account = balances[msg.sender];\n    require(index < account.pendingWithdrawals.length, \"Bad pending withdrawal index\");\n    PendingWithdrawal storage pendingWithdrawal = account.pendingWithdrawals[index];\n    require(now >= pendingWithdrawal.timestamp, \"Pending withdrawal not available\");\n    uint256 value = pendingWithdrawal.value;\n    deletePendingWithdrawal(account.pendingWithdrawals, index);\n    require(value <= address(this).balance, \"Inconsistent balance\");\n    msg.sender.sendValue(value);\n    emit GoldWithdrawn(msg.sender, value);\n  }\n",
        "formal_property": " * This rule verifies the Certora Prover is correctly modeling the behavior of GoldToken._transfer.\n */\nrule withdraw(uint256 index) {\n\tenv e;\n\tuint256 _balance = sinvoke ercBalanceOf(e.msg.sender);\n\tuint256 val = sinvoke getPendingWithdrawalsIndex(e.msg.sender, index);\n\tsinvoke withdraw(e, index);\n\trequire (e.msg.sender != currentContract);\n\tuint256 balance_ = sinvoke ercBalanceOf(e.msg.sender);\n\tassert(\n    _balance + val == balance_,\n    \"Withdraw balance not updated\"\n  );\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "verifies",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "ercBalanceOf",
                "getPendingWithdrawalsIndex"
            ],
            "start_line": 110,
            "end_line": 123,
            "block_hash": "6c8067de90cb88b7195a8f08e68ed869"
        }
    },
    {
        "id": "LockedGold_noWithdrawBeforeUnlocking_d3cd211f",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LockedGold.sol",
        "target_function": "getAccountNonvotingLockedGold/getTotalPendingWithdrawals/lock/unlock",
        "text_chunk": "  function getAccountNonvotingLockedGold(address account) external view returns (uint256) {\n    return balances[account].nonvoting;\n  }\n\n\n  function getTotalPendingWithdrawals(address account) external view returns (uint256) {\n    uint256 pendingWithdrawalSum = 0;\n    PendingWithdrawal[] memory withdrawals = balances[account].pendingWithdrawals;\n    for (uint256 i = 0; i < withdrawals.length; i = i.add(1)) {\n      pendingWithdrawalSum = pendingWithdrawalSum.add(withdrawals[i].value);\n    }\n    return pendingWithdrawalSum;\n  }\n\n\n  function lock() external payable nonReentrant {\n    require(\n      getAccounts().isAccount(msg.sender),\n      \"Must first register address with Account.createAccount\"\n    );\n    _incrementNonvotingAccountBalance(msg.sender, msg.value);\n    _updateDelegatedAmount(msg.sender);\n    emit GoldLocked(msg.sender, msg.value);\n  }\n\n\n  function unlock(uint256 value) external nonReentrant {\n    require(\n      getAccounts().isAccount(msg.sender),\n      \"Sender must be registered with Account.createAccount to lock or unlock\"\n    );\n    Balances storage account = balances[msg.sender];\n\n    uint256 totalLockedGold = getAccountTotalLockedGold(msg.sender);\n    // Prevent unlocking gold when voting on governance proposals so that the gold cannot be\n    // used to vote more than once.\n    uint256 remainingLockedGold = totalLockedGold.sub(value);\n\n    uint256 totalReferendumVotes = getGovernance().getAmountOfGoldUsedForVoting(msg.sender);\n    require(\n      remainingLockedGold >= totalReferendumVotes,\n      \"Not enough unlockable celo. Celo is locked in voting.\"\n    );\n\n    FixidityLib.Fraction memory delegatedPercentage = delegatorInfo[msg.sender]\n      .totalDelegatedCeloFraction;\n\n    if (FixidityLib.gt(delegatedPercentage, FixidityLib.newFixed(0))) {\n      revokeFromDelegatedWhenUnlocking(msg.sender, value);\n    }\n\n    uint256 balanceRequirement = getValidators().getAccountLockedGoldRequirement(msg.sender);\n    require(\n      balanceRequirement == 0 || balanceRequirement <= remainingLockedGold,\n      \"Either account doesn't have enough locked Celo or locked Celo is being used for voting.\"\n    );\n    _decrementNonvotingAccountBalance(msg.sender, value);\n    uint256 available = now.add(unlockingPeriod);\n    // CERTORA: the slot containing the length could be MAX_UINT\n    account.pendingWithdrawals.push(PendingWithdrawal(value, available));\n    emit GoldUnlocked(msg.sender, value, available);\n  }\n",
        "formal_property": "rule noWithdrawBeforeUnlocking(address account, uint256 value, method f) {\n\t// We must make sure the length of pending withdrawals is not MAX_UINT, since then the `push` will make the length 0.\n\t// (this should have been checked by the solidity compiler)\n\trequire(sinvoke pendingWithdrawalsNotFull(account), \"Pending withdrawals are full\");\n\t\n\t// Unlock a value and add it to pending withdrawals\n\tenv _e;\n\trequire(_e.msg.sender == account);\n\tsinvoke unlock(_e,value);\n\n\t// Try to run any function - adversary's goal is to succeed in unlocking before time\n\tenv eF;\n\trequire(eF.block.timestamp > _e.block.timestamp);\n\tcalldataarg arg;\n\tsinvoke f(eF,arg);\n\t// We check if adversary succeeded\n\tuint256 totalPendingWithdrawals_ = sinvoke getTotalPendingWithdrawals(account);\n\tassert(\n    eF.block.timestamp < _e.block.timestamp + sinvoke getunlockingPeriod() =>\n    sinvoke getAccountNonvotingLockedGold(account) + totalPendingWithdrawals_ >= value,\n    \"If we are before the unlock period passed, we cannot transfer the value outside the locked balance or pending balance\"\n  );\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "noWithdrawBeforeUnlocking",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "getAccountNonvotingLockedGold",
                "getTotalPendingWithdrawals",
                "getunlockingPeriod",
                "unlock",
                "pendingWithdrawalsNotFull"
            ],
            "start_line": 128,
            "end_line": 150,
            "block_hash": "d3cd211f660661751be259df4c993a64"
        }
    },
    {
        "id": "LockedGold_only_initializer_changes_initialized_field_4845a6a5",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LockedGold.sol",
        "target_function": "initialize",
        "text_chunk": "  function initialize(address registryAddress, uint256 _unlockingPeriod) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setUnlockingPeriod(_unlockingPeriod);\n    maxDelegateesCount = 10;\n  }\n",
        "formal_property": "rule only_initializer_changes_initialized_field(method f) {\n\tenv _e;\n\tenv eF;\n\tenv e_;\n\n\tbool _isInitialized = sinvoke initialized(_e);\n\trequire(f.selector != initialize(address,uint256).selector);\n\tcalldataarg arg;\n\tinvoke f(eF,arg);\n\tbool isInitialized_ = sinvoke initialized(e_);\n\tassert(\n    _isInitialized == isInitialized_,\n    \"Method $f is not expected to change initialization field from ${_isInitialized} to ${isInitialized_}\"\n  );\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "only_initializer_changes_initialized_field",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 155,
            "end_line": 169,
            "block_hash": "4845a6a51f82896b7b5d2178ee55253c"
        }
    },
    {
        "id": "LockedGold_check_initializer_b13f6a6b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LockedGold.sol",
        "target_function": "initialize",
        "text_chunk": "  function initialize(address registryAddress, uint256 _unlockingPeriod) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setUnlockingPeriod(_unlockingPeriod);\n    maxDelegateesCount = 10;\n  }\n",
        "formal_property": "rule check_initializer {\n\tenv _e;\n\tenv eF;\n\tenv e_;\n\t\n\tbool _isInitialized = sinvoke initialized(_e);\n\tcalldataarg arg;\n\tinvoke initialize(eF,arg);\n\tbool successInit = !lastReverted;\n\tbool isInitialized_ = sinvoke initialized(e_);\n\tassert(\n    _isInitialized => !successInit,\n    \"Initialize() must revert if already initialized\"\n  );\n    successInit => isInitialized_,\n    \"When initialize() succeeds, must set initialization field to true\"\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "check_initializer",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 176,
            "end_line": 194,
            "block_hash": "b13f6a6b98ccd62675328b9108beb504"
        }
    },
    {
        "id": "PoolActions_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "PoolActions.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: Unlicense\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '../interfaces/IUniswapV3Pool.sol';\nimport './PoolVariables.sol';\nimport \"./SafeCast.sol\";\n/// @title This library is created to conduct a variety of burn liquidity methods\nlibrary PoolActions {\n    using PoolVariables for IUniswapV3Pool;\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n\n    /**\n     * @notice Withdraws liquidity in share proportion to the Optimizer's totalSupply.\n     * @param pool Uniswap V3 pool\n     * @param tickLower The lower tick of the range\n     * @param tickUpper The upper tick of the range\n     * @param totalSupply The amount of total shares in existence\n     * @param share to burn\n     * @param to Recipient of amounts\n     * @return amount0 Amount of token0 withdrawed\n     * @return amount1 Amount of token1 withdrawed\n     */\n function burnLiquidityShare(\n        IUniswapV3Pool pool,\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 totalSupply,\n        uint256 share,\n        address to\n    ) internal returns (uint256 amount0, uint256 amount1) {\n        require(totalSupply > 0, \"TS\");\n        uint128 liquidityInPool = pool.positionLiquidity(tickLower, tickUpper);\n        uint256 liquidity = uint256(liquidityInPool).mul(share) / totalSupply;\n        \n        require ((liquidity < 2**128) && (totalSupply < 2**128));\n        require (share == liquidity * totalSupply/uint256(liquidityInPool));\n\n        if (liquidity > 0) {\n            (amount0, amount1) = pool.burn(tickLower, tickUpper, liquidity.toUint128());\n\n            if (amount0 > 0 || amount1 > 0) {\n            // collect liquidity share\n                (amount0, amount1) = pool.collect(\n                    to,\n                    tickLower,\n                    tickUpper,\n                    amount0.toUint128(),\n                    amount1.toUint128()\n                );\n            }\n        }\n    }\n    /**\n     * @notice Withdraws all liquidity in a range from Uniswap pool\n     * @param pool Uniswap V3 pool\n     * @param tickLower The lower tick of the range\n     * @param tickUpper The upper tick of the range\n     */\n    function burnAllLiquidity(\n        IUniswapV3Pool pool,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal {\n        \n        // Burn all liquidity in this range\n        uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);\n        if (liquidity > 0) {\n            pool.burn(tickLower, tickUpper, liquidity);\n        }\n        \n         // Collect all owed tokens\n        pool.collect(\n            address(this),\n            tickLower,\n            tickUpper,\n            type(uint128).max,\n            type(uint128).max\n        );\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "burnLiquidityShare",
                "burnAllLiquidity"
            ],
            "state_variables": [],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "PoolActions_checkBurnLiquidityShare_07448c17",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PoolActions.sol",
        "target_function": "burnLiquidityShare",
        "text_chunk": " function burnLiquidityShare(\n        IUniswapV3Pool pool,\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 totalSupply,\n        uint256 share,\n        address to\n    ) internal returns (uint256 amount0, uint256 amount1) {\n        require(totalSupply > 0, \"TS\");\n        uint128 liquidityInPool = pool.positionLiquidity(tickLower, tickUpper);\n        uint256 liquidity = uint256(liquidityInPool).mul(share) / totalSupply;\n        \n        require ((liquidity < 2**128) && (totalSupply < 2**128));\n        require (share == liquidity * totalSupply/uint256(liquidityInPool));\n\n        if (liquidity > 0) {\n            (amount0, amount1) = pool.burn(tickLower, tickUpper, liquidity.toUint128());\n\n            if (amount0 > 0 || amount1 > 0) {\n            // collect liquidity share\n                (amount0, amount1) = pool.collect(\n                    to,\n                    tickLower,\n                    tickUpper,\n                    amount0.toUint128(),\n                    amount1.toUint128()\n                );\n            }\n        }\n    }\n",
        "formal_property": "rule checkBurnLiquidityShare(\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 share,\n        address to){\n    env e;\n    require (share > 0 && share <= totalSupply());\n    uint256 totalSupplyBefore = totalSupply();\n    uint256 amount0;\n    uint256 amount1;\n    amount0, amount1 = callBurnLiquidityShare(e, tickLower, tickUpper, share, \n                       e.msg.sender);\n    assert(totalSupply() == totalSupplyBefore);\n    assert(!lastReverted);\n    \n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "checkBurnLiquidityShare",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 10,
            "end_line": 25,
            "block_hash": "07448c174a9723044001e997a460c0c2"
        }
    },
    {
        "id": "PoolActions_checkBurnExactLiquidity_4836bfd0",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PoolActions.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: Unlicense\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '../interfaces/IUniswapV3Pool.sol';\nimport './PoolVariables.sol';\nimport \"./SafeCast.sol\";\n/// @title This library is created to conduct a variety of burn liquidity methods\nlibrary PoolActions {\n    using PoolVariables for IUniswapV3Pool;\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n\n    /**\n     * @notice Withdraws liquidity in share proportion to the Optimizer's totalSupply.\n     * @param pool Uniswap V3 pool\n     * @param tickLower The lower tick of the range\n     * @param tickUpper The upper tick of the range\n     * @param totalSupply The amount of total shares in existence\n     * @param share to burn\n     * @param to Recipient of amounts\n     * @return amount0 Amount of token0 withdrawed\n     * @return amount1 Amount of token1 withdrawed\n     */\n function burnLiquidityShare(\n        IUniswapV3Pool pool,\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 totalSupply,\n        uint256 share,\n        address to\n    ) internal returns (uint256 amount0, uint256 amount1) {\n        require(totalSupply > 0, \"TS\");\n        uint128 liquidityInPool = pool.positionLiquidity(tickLower, tickUpper);\n        uint256 liquidity = uint256(liquidityInPool).mul(share) / totalSupply;\n        \n        require ((liquidity < 2**128) && (totalSupply < 2**128));\n        require (share == liquidity * totalSupply/uint256(liquidityInPool));\n\n        if (liquidity > 0) {\n            (amount0, amount1) = pool.burn(tickLower, tickUpper, liquidity.toUint128());\n\n            if (amount0 > 0 || amount1 > 0) {\n            // collect liquidity share\n                (amount0, amount1) = pool.collect(\n                    to,\n                    tickLower,\n                    tickUpper,\n                    amount0.toUint128(),\n                    amount1.toUint128()\n                );\n            }\n        }\n    }\n    /**\n     * @notice Withdraws all liquidity in a range from Uniswap pool\n     * @param pool Uniswap V3 pool\n     * @param tickLower The lower tick of the range\n     * @param tickUpper The upper tick of the range\n     */\n    function burnAllLiquidity(\n        IUniswapV3Pool pool,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal {\n        \n        // Burn all liquidity in this range\n        uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);\n        if (liquidity > 0) {\n            pool.burn(tickLower, tickUpper, liquidity);\n        }\n        \n         // Collect all owed tokens\n        pool.collect(\n            address(this),\n            tickLower,\n            tickUpper,\n            type(uint128).max,\n            type(uint128).max\n        );\n    }\n}",
        "formal_property": "rule checkBurnExactLiquidity(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity\n    ){\n        env e;\n        require to == e.msg.sender;\n        uint256 amount0;\n        uint256 amount1;\n        amount0, amount1 = callBurnExactLiquidity(e,\n            tickLower,\n            tickUpper,\n            liquidity,\n            e.msg.sender);\n        assert liquidity == 0 => amount0 == 0 && amount1 == 0;\n        assert liquidity > 0 => amount0 > 0 || amount1 > 0;// && (amount0 <= liquidity || amount1 <= liquidity);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "checkBurnExactLiquidity",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 29,
            "end_line": 45,
            "block_hash": "4836bfd05d2a5fa085e38040a8970acf"
        }
    },
    {
        "id": "PoolActions_checkBurnAllLiquidity_60786245",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PoolActions.sol",
        "target_function": "burnAllLiquidity",
        "text_chunk": "    function burnAllLiquidity(\n        IUniswapV3Pool pool,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal {\n        \n        // Burn all liquidity in this range\n        uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);\n        if (liquidity > 0) {\n            pool.burn(tickLower, tickUpper, liquidity);\n        }\n        \n         // Collect all owed tokens\n        pool.collect(\n            address(this),\n            tickLower,\n            tickUpper,\n            type(uint128).max,\n            type(uint128).max\n        );\n    }\n",
        "formal_property": "rule checkBurnAllLiquidity(int24 tickLower,\n                        int24 tickUpper){\n    callBurnAllLiquidity(tickLower, tickUpper);\n    // uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);\n    // assert(liquidity ==0);\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "checkBurnAllLiquidity",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 47,
            "end_line": 52,
            "block_hash": "6078624542aaa86d6958093b6c232b55"
        }
    },
    {
        "id": "GhoToken_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "mint",
                "burn",
                "addFacilitator",
                "removeFacilitator",
                "setFacilitatorBucketCapacity",
                "getFacilitator",
                "getFacilitatorBucket",
                "getFacilitatorsList"
            ],
            "state_variables": [
                "_facilitatorsList",
                "_facilitators"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "GhoToken_length_leq_max_uint160_d4265876",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t{\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "length_leq_max_uint160",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "totalSupply",
                "balanceOf"
            ],
            "start_line": 64,
            "end_line": 77,
            "block_hash": "d4265876e9935163545eec17dd6f410b"
        }
    },
    {
        "id": "GhoToken_total_supply_eq_sumAllLevel_0b9483f7",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "burn",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "invariant total_supply_eq_sumAllLevel()\n\t\tsumAllLevel() == totalSupply() \n\t{\n\t  preserved burn(uint256 amount) with (env e){\n\t\t\trequireInvariant inv_balanceOf_leq_totalSupply(e.msg.sender);\n\t\t}\n\t}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "total_supply_eq_sumAllLevel",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "burn",
                "totalSupply",
                "balanceOf"
            ],
            "start_line": 83,
            "end_line": 89,
            "block_hash": "0b9483f75c803592d6efc2c806284deb"
        }
    },
    {
        "id": "GhoToken_sumAllBalance_eq_totalSupply_5a21a7b8",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t{\n\t\tpreserved {\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sumAllBalance_eq_totalSupply",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "totalSupply"
            ],
            "start_line": 98,
            "end_line": 104,
            "block_hash": "5a21a7b8f56ec93f6b402148e8ee5733"
        }
    },
    {
        "id": "GhoToken_can_1c23451c",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "burn",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": " * @dev This invariant can be deduced from sumAllBalance_eq_totalSupply and total_supply_eq_sumAllLevel\ninvariant total_supply_eq_sumAllLevel()\n\t\tsumAllLevel() == totalSupply() \n\t{\n\t  preserved burn(uint256 amount) with (env e){\n\t\t\trequireInvariant inv_balanceOf_leq_totalSupply(e.msg.sender);\n\t\t}\n\t}\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n * @dev requireInvariant of EITHER sumAllBalance_eq_totalSupply() OR total_supply_eq_sumAllLevel() suffuces for the proof\n **/\ninvariant sumAllLevel_eq_sumAllBalance()\n\tsumAllLevel() == sumAllBalance()\n\t  \t{\n\t\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "can",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "totalSupply"
            ],
            "start_line": 109,
            "end_line": 118,
            "block_hash": "1c23451c40429a90d43151560b8ed6bd"
        }
    },
    {
        "id": "GhoToken_inv_valid_capacity_ed2fbfad",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant inv_valid_capacity(address facilitator)\n\t((getFacilitatorBucketCapacity(facilitator)>0) => is_in_facilitator_mapping(facilitator) )\n\n// INV #7\n/**\n* @title A facilitator with a positive bucket level exists in the _facilitators mapping\n*/\ninvariant inv_valid_level(address facilitator)\n\t((getFacilitatorBucketLevel(facilitator)>0) => is_in_facilitator_mapping(facilitator) )\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant inv_valid_capacity(facilitator);\n\t\t}\n\t}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "inv_valid_capacity",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "getFacilitatorBucketLevel",
                "getFacilitatorBucketCapacity",
                "is_in_facilitator_mapping"
            ],
            "start_line": 126,
            "end_line": 139,
            "block_hash": "ed2fbfad709b636f7ac9a70d5611ebbe"
        }
    },
    {
        "id": "GhoToken_address_in_set_values_iff_in_set_indexes_0799d206",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant address_in_set_values_iff_in_set_indexes(address facilitator)\n\tis_in_facilitator_set_array(facilitator) <=> is_in_facilitator_set_map(facilitator)\n\t{preserved{\n\t\trequireInvariant addressSetInvariant();\ninvariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\t\trequireInvariant length_leq_max_uint160();\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "address_in_set_values_iff_in_set_indexes",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "is_in_facilitator_set_map",
                "is_in_facilitator_set_array"
            ],
            "start_line": 147,
            "end_line": 153,
            "block_hash": "0799d206eb978bbd7fe77339b7351c06"
        }
    },
    {
        "id": "GhoToken_addr_in_set_iff_in_map_00cbe730",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant addr_in_set_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)\n\t{preserved{\n \t\trequireInvariant addressSetInvariant();\ninvariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "addr_in_set_iff_in_map",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "is_in_facilitator_mapping",
                "is_in_facilitator_set_map"
            ],
            "start_line": 161,
            "end_line": 167,
            "block_hash": "00cbe730a1fff3c9e79befdb439e7b69"
        }
    },
    {
        "id": "GhoToken_addr_in_set_list_iff_in_map_425bdea5",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant addr_in_set_list_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_array(facilitator)\n\t{preserved{\n\t\trequireInvariant addressSetInvariant();\ninvariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\t\trequireInvariant length_leq_max_uint160();\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "addr_in_set_list_iff_in_map",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "is_in_facilitator_mapping",
                "is_in_facilitator_set_array"
            ],
            "start_line": 175,
            "end_line": 181,
            "block_hash": "425bdea51fedb31e5f91dcfd9f8eefd0"
        }
    },
    {
        "id": "GhoToken_ARRAY_IS_INVERSE_OF_MAP_Invariant_8e78d164",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant ARRAY_IS_INVERSE_OF_MAP_Invariant()\n    ARRAY_IS_INVERSE_OF_MAP()\n\t{\n\t\tpreserved{\n\t\t\trequire ADDRESS_SET_INVARIANT();\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "ARRAY_IS_INVERSE_OF_MAP_Invariant",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 501,
            "end_line": 508,
            "block_hash": "8e78d164bd83009c93f384e3de377547"
        }
    },
    {
        "id": "GhoToken_addressSetInvariant_20a22f8a",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "addressSetInvariant",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 511,
            "end_line": 517,
            "block_hash": "20a22f8a805c5d3ad2b62ba6c0cdef08"
        }
    },
    {
        "id": "GhoToken_level_leq_capacity_60e5ce70",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "rule level_leq_capacity(address facilitator, method f) filtered {f -> !f.isView}{\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "level_leq_capacity",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 192,
            "end_line": 192,
            "block_hash": "60e5ce70f554e0c886eb5f153db66001"
        }
    },
    {
        "id": "GhoToken_mint_after_burn_b9da6fc1",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "burn/mint",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule mint_after_burn(method f) filtered {f -> !f.isView}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "mint_after_burn",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint",
                "burn"
            ],
            "start_line": 208,
            "end_line": 208,
            "block_hash": "b9da6fc11ea00767683782435e750f3d"
        }
    },
    {
        "id": "GhoToken_burn_after_mint_3d9d2532",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "burn/mint",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule burn_after_mint(method f) filtered {f -> !f.isView}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burn_after_mint",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint",
                "burn"
            ],
            "start_line": 239,
            "end_line": 239,
            "block_hash": "3d9d253248012cb2cb5e1c9e635a319d"
        }
    },
    {
        "id": "GhoToken_level_unchanged_after_mint_followed_by_burn_baffa955",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "burn/mint",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule level_unchanged_after_mint_followed_by_burn()\n{\n\tenv e;\n\tcalldataarg arg;\n\tuint256 amount;\n\taddress account;\n\n\tuint256 levelBefore = getFacilitatorBucketLevel(e.msg.sender);\n\tmint(e, account, amount);\n\tburn(e, amount);\n\tuint256 leveAfter = getFacilitatorBucketLevel(e.msg.sender);\n\tassert levelBefore == leveAfter;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "level_unchanged_after_mint_followed_by_burn",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint",
                "burn",
                "getFacilitatorBucketLevel"
            ],
            "start_line": 259,
            "end_line": 272,
            "block_hash": "baffa95500f7eace70b243b152133106"
        }
    },
    {
        "id": "GhoToken_level_after_mint_234348cd",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "mint",
        "text_chunk": "  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule level_after_mint()\n{\n\tenv e;\n\tcalldataarg arg;\n\tuint256 amount;\n\taddress account;\n\n\tuint256 levelBefore = getFacilitatorBucketLevel(e.msg.sender);\n\tmint(e, account, amount);\n\tuint256 leveAfter = getFacilitatorBucketLevel(e.msg.sender);\n\tassert levelBefore + amount == leveAfter;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "level_after_mint",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint",
                "getFacilitatorBucketLevel"
            ],
            "start_line": 274,
            "end_line": 286,
            "block_hash": "234348cd997cf2b6967024b26ea3ab08"
        }
    },
    {
        "id": "GhoToken_level_after_burn_bce62ac6",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "burn",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule level_after_burn()\n{\n\tenv e;\n\tcalldataarg arg;\n\tuint256 amount;\n\n\tuint256 levelBefore = getFacilitatorBucketLevel(e.msg.sender);\n\tburn(e, amount);\n\tuint256 leveAfter = getFacilitatorBucketLevel(e.msg.sender);\n\tassert levelBefore == leveAfter + amount;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "level_after_burn",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "burn",
                "getFacilitatorBucketLevel"
            ],
            "start_line": 288,
            "end_line": 299,
            "block_hash": "bce62ac6f7fb177be1a94eb9db0ecaef"
        }
    },
    {
        "id": "GhoToken_facilitator_in_list_after_setFacilitatorBucketCapacity_2d1ea76c",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "setFacilitatorBucketCapacity",
        "text_chunk": "  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n",
        "formal_property": "rule facilitator_in_list_after_setFacilitatorBucketCapacity(){\n\n\tenv e;\n\taddress facilitator;\n\tuint128 newCapacity;\n\trequireInvariant addr_in_set_iff_in_map(facilitator);\ninvariant addr_in_set_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)\n\t{preserved{\n \t\trequireInvariant addressSetInvariant();\ninvariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\trequireInvariant addr_in_set_list_iff_in_map(facilitator);\ninvariant addr_in_set_list_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_array(facilitator)\n\t\trequireInvariant addressSetInvariant();\n\t\trequireInvariant length_leq_max_uint160();\n\tsetFacilitatorBucketCapacity(e, facilitator, newCapacity);\n\t\n\tassert is_in_facilitator_set_map(facilitator);\n\tassert is_in_facilitator_set_array(facilitator);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "facilitator_in_list_after_setFacilitatorBucketCapacity",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "setFacilitatorBucketCapacity",
                "is_in_facilitator_set_map",
                "is_in_facilitator_set_array"
            ],
            "start_line": 305,
            "end_line": 318,
            "block_hash": "2d1ea76c9b8e22a8e390ae19193292fd"
        }
    },
    {
        "id": "GhoToken_getFacilitatorBucketCapacity_after_setFacilitatorBucketCapacity_4f6a552d",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "setFacilitatorBucketCapacity",
        "text_chunk": "  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n",
        "formal_property": "rule getFacilitatorBucketCapacity_after_setFacilitatorBucketCapacity(){\n\n\tenv e;\n\taddress facilitator;\n\tuint128 newCapacity;\n\tsetFacilitatorBucketCapacity(e, facilitator, newCapacity);\n\tassert getFacilitatorBucketCapacity(facilitator) == newCapacity;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "getFacilitatorBucketCapacity_after_setFacilitatorBucketCapacity",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "setFacilitatorBucketCapacity",
                "getFacilitatorBucketCapacity"
            ],
            "start_line": 323,
            "end_line": 331,
            "block_hash": "4f6a552d1503167fb8f86605430a1f5f"
        }
    },
    {
        "id": "GhoToken_facilitator_in_list_after_addFacilitator_9026b774",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "addFacilitator",
        "text_chunk": "  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n",
        "formal_property": "rule facilitator_in_list_after_addFacilitator(){\n\n\tenv e;\n\taddress facilitator;\n\tstring label;\n\tuint128 capacity;\n\trequireInvariant addr_in_set_iff_in_map(facilitator);\ninvariant addr_in_set_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)\n\t{preserved{\n \t\trequireInvariant addressSetInvariant();\ninvariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\t\n\taddFacilitator(e,facilitator, label, capacity);\n\tassert is_in_facilitator_set_map(facilitator);\n\tassert is_in_facilitator_set_array(facilitator);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "facilitator_in_list_after_addFacilitator",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "is_in_facilitator_set_map",
                "is_in_facilitator_set_array"
            ],
            "start_line": 336,
            "end_line": 349,
            "block_hash": "9026b7749b67874c376debb54dd5abc5"
        }
    },
    {
        "id": "GhoToken_facilitator_in_list_after_mint_and_burn_c1fabe9f",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "burn/mint",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule facilitator_in_list_after_mint_and_burn(method f){\n\n\tenv e;\n\tcalldataarg args;\n\trequireInvariant inv_valid_capacity(e.msg.sender);\ninvariant inv_valid_capacity(address facilitator)\n\t((getFacilitatorBucketCapacity(facilitator)>0) => is_in_facilitator_mapping(facilitator) )\n// INV #7\n/**\n* @title A facilitator with a positive bucket level exists in the _facilitators mapping\n*/\ninvariant inv_valid_level(address facilitator)\n\t((getFacilitatorBucketLevel(facilitator)>0) => is_in_facilitator_mapping(facilitator) )\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant inv_valid_capacity(facilitator);\n\t\t}\n\t}\n\trequireInvariant inv_valid_level(e.msg.sender);\n\trequireInvariant addr_in_set_iff_in_map(e.msg.sender);\ninvariant addr_in_set_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)\n\t{preserved{\n \t\trequireInvariant addressSetInvariant();\ninvariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n// INV #2\n* @title User's balance not greater than totalSupply()\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\trequireInvariant addr_in_set_list_iff_in_map(e.msg.sender);\ninvariant addr_in_set_list_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_array(facilitator)\n\t\trequireInvariant addressSetInvariant();\n\t\trequireInvariant length_leq_max_uint160();\n\tf(e,args);\n\tassert (((f.selector == mint(address,uint256).selector) || (f.selector == burn(uint256).selector)) => is_in_facilitator_mapping(e.msg.sender));\n\tassert (((f.selector == mint(address,uint256).selector) || (f.selector == burn(uint256).selector)) => is_in_facilitator_set_map(e.msg.sender));\n\tassert (((f.selector == mint(address,uint256).selector) || (f.selector == burn(uint256).selector)) => is_in_facilitator_set_array(e.msg.sender));\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "facilitator_in_list_after_mint_and_burn",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint",
                "burn",
                "is_in_facilitator_mapping",
                "is_in_facilitator_set_map",
                "is_in_facilitator_set_array"
            ],
            "start_line": 354,
            "end_line": 367,
            "block_hash": "c1fabe9fa9651ea77225ce2c3dd36300"
        }
    },
    {
        "id": "GhoToken_address_not_in_list_after_removeFacilitator_22068bfb",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "removeFacilitator",
        "text_chunk": "  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n",
        "formal_property": "rule address_not_in_list_after_removeFacilitator(address facilitator){\n\tenv e;\n\trequireInvariant addressSetInvariant();\ninvariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\trequireInvariant length_leq_max_uint160();\n\trequireInvariant addr_in_set_iff_in_map(facilitator);\ninvariant addr_in_set_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)\n\t{preserved{\n \t\trequireInvariant addressSetInvariant();\n\tremoveFacilitator(e, facilitator);\n\tassert !is_in_facilitator_set_array(facilitator);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "address_not_in_list_after_removeFacilitator",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "removeFacilitator",
                "is_in_facilitator_set_array"
            ],
            "start_line": 372,
            "end_line": 379,
            "block_hash": "22068bfbcf2ffe3cb9b8458131b1ba35"
        }
    },
    {
        "id": "GhoToken_mintIsAdditive_5f734ad8",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "mint",
        "text_chunk": "  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "// rule mintIsAdditive() {\n// \taddress user1;\n// \taddress user2;\n// \trequire (user1 != user2);\n// \tuint256 initBalance1 = balanceOf(user1);\n// \tuint256 initBalance2 = balanceOf(user2);\n// \trequire (sumAllBalance() >= initBalance1 + initBalance2);\n// \trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t{\n\t\tpreserved {\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\n// \tuint256 amount1;\n// \tuint256 amount2;\n// \tuint256 sum = amount1 + amount2;\n// \tenv e;\n// \tmint(e, user1, amount1);\n// \tmint(e, user1, amount2);\n// \tmint(e, user2, sum);\n// \tuint256 finBalance1 = balanceOf(user1);\n// \tuint256 finBalance2 = balanceOf(user2);\n// \tmathint diff1 = finBalance1 - initBalance1;\n// \tmathint diff2 = finBalance2 - initBalance2;\n// \tassert diff1 == diff2;\n// }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "mintIsAdditive",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint",
                "totalSupply",
                "balanceOf"
            ],
            "start_line": 385,
            "end_line": 408,
            "block_hash": "5f734ad830f914fc888da788a02fedfb"
        }
    },
    {
        "id": "GhoToken_balance_after_mint_e7ace2dc",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "mint",
        "text_chunk": "  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule balance_after_mint() {\n\t\n\tenv e;\n\taddress user;\n\tuint256 initBalance = balanceOf(user);\n\tuint256 initSupply = totalSupply();\n\tuint256 amount;\n\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t{\n\t\tpreserved {\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\tmint(e, user, amount);\n\tuint256 finBalance = balanceOf(user);\n\tuint256 finSupply = totalSupply();\n\tassert initBalance + amount == finBalance;\n\tassert initSupply + amount == finSupply;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "balance_after_mint",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint",
                "totalSupply",
                "balanceOf"
            ],
            "start_line": 410,
            "end_line": 423,
            "block_hash": "e7ace2dcf1aaae6f35c33c9af7c078d2"
        }
    },
    {
        "id": "GhoToken_balance_after_burn_6c93eb0c",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "burn",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule balance_after_burn() {\n\t\n\tenv e;\n\trequireInvariant inv_balanceOf_leq_totalSupply(e.msg.sender);\n\tuint256 initBalance = balanceOf(e.msg.sender);\n\tuint256 initSupply = totalSupply();\n\tuint256 amount;\n\tburn(e, amount);\n\tuint256 finBalance = balanceOf(e.msg.sender);\n\tuint256 finSupply = totalSupply();\n\tassert initBalance == finBalance + amount;\n\tassert initSupply == finSupply + amount ;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "balance_after_burn",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "burn",
                "totalSupply",
                "balanceOf"
            ],
            "start_line": 425,
            "end_line": 437,
            "block_hash": "6c93eb0cacc3b3810f863f86e1c62f69"
        }
    },
    {
        "id": "GhoToken_burnIsAdditive_1dd12709",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "burn",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "// rule burnIsAdditive() {\n// \tenv e;\n// \tuint256 senderBalance = balanceOf(e.msg.sender);\n// \trequire(senderBalance <= sumAllBalance());\n// \trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t{\n\t\tpreserved {\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\n// \tuint256 amount1;\n// \tuint256 amount2;\n// \tuint256 sum = amount1 + amount2;\n// \tuint256 initSupply = totalSupply();\n// \tburn(e, amount1);\n// \tburn(e, amount2);\n// \tuint256 midSupply = totalSupply();\n// \tburn(e, sum);\n// \tuint256 finSupply = totalSupply();\n// \tmathint diff1 = finSupply - midSupply;\n// \tmathint diff2 = midSupply - initSupply;\n// \tassert diff1 == diff2;\n// }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burnIsAdditive",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "burn",
                "totalSupply",
                "balanceOf"
            ],
            "start_line": 442,
            "end_line": 462,
            "block_hash": "1dd12709d155c89479892893748c9149"
        }
    },
    {
        "id": "GhoToken_mintLimitedByFacilitatorRemainingCapacity_7849df10",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "mint",
        "text_chunk": "  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule mintLimitedByFacilitatorRemainingCapacity() {\n\tenv e;\n\trequire(getFacilitatorBucketCapacity(e.msg.sender) > getFacilitatorBucketLevel(e.msg.sender));\n\n\tuint256 amount;\n\trequire(amount > (getFacilitatorBucketCapacity(e.msg.sender) - getFacilitatorBucketLevel(e.msg.sender)));\n\taddress user;\n\tmint@withrevert(e, user, amount);\n\tassert lastReverted;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "mintLimitedByFacilitatorRemainingCapacity",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint",
                "getFacilitatorBucketLevel",
                "getFacilitatorBucketCapacity"
            ],
            "start_line": 467,
            "end_line": 476,
            "block_hash": "7849df10e87eb4b106d0a5351f44c928"
        }
    },
    {
        "id": "GhoToken_burnLimitedByFacilitatorLevel_b1fbcffa",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "burn",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule burnLimitedByFacilitatorLevel() {\n\tenv e;\n\trequire(getFacilitatorBucketCapacity(e.msg.sender) > getFacilitatorBucketLevel(e.msg.sender));\n\n\tuint256 amount;\n\trequire(amount > getFacilitatorBucketLevel(e.msg.sender));\n\tburn@withrevert(e, amount);\n\tassert lastReverted;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burnLimitedByFacilitatorLevel",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "burn",
                "getFacilitatorBucketLevel",
                "getFacilitatorBucketCapacity"
            ],
            "start_line": 481,
            "end_line": 489,
            "block_hash": "b1fbcffaae9d8bc8244cdc0ab5c14e40"
        }
    },
    {
        "id": "GhoToken_address_not_in_list_after_removeFacilitator_CASE_SPLIT_zero_address_f5025826",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "removeFacilitator",
        "text_chunk": "  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n",
        "formal_property": "rule address_not_in_list_after_removeFacilitator_CASE_SPLIT_zero_address(address facilitator){\nrule address_not_in_list_after_removeFacilitator(address facilitator){\n\tenv e;\n\trequireInvariant addressSetInvariant();\ninvariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\trequireInvariant length_leq_max_uint160();\n\trequireInvariant addr_in_set_iff_in_map(facilitator);\ninvariant addr_in_set_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)\n\t{preserved{\n \t\trequireInvariant addressSetInvariant();\n\tremoveFacilitator(e, facilitator);\n\tassert !is_in_facilitator_set_array(facilitator);\n}\n\trequire facilitator == 0;\n\t\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "address_not_in_list_after_removeFacilitator_CASE_SPLIT_zero_address",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "removeFacilitator",
                "is_in_facilitator_set_array"
            ],
            "start_line": 523,
            "end_line": 531,
            "block_hash": "f5025826f964091825cc4c234c4c9ae5"
        }
    },
    {
        "id": "GhoAToken_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "GhoAToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IERC20} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol';\nimport {GPv2SafeERC20} from '@aave/core-v3/contracts/dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {VersionedInitializable} from '@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {Errors} from '@aave/core-v3/contracts/protocol/libraries/helpers/Errors.sol';\nimport {WadRayMath} from '@aave/core-v3/contracts/protocol/libraries/math/WadRayMath.sol';\nimport {IPool} from '@aave/core-v3/contracts/interfaces/IPool.sol';\nimport {IAToken} from '@aave/core-v3/contracts/interfaces/IAToken.sol';\nimport {IAaveIncentivesController} from '@aave/core-v3/contracts/interfaces/IAaveIncentivesController.sol';\nimport {IInitializableAToken} from '@aave/core-v3/contracts/interfaces/IInitializableAToken.sol';\nimport {ScaledBalanceTokenBase} from '@aave/core-v3/contracts/protocol/tokenization/base/ScaledBalanceTokenBase.sol';\nimport {IncentivizedERC20} from '@aave/core-v3/contracts/protocol/tokenization/base/IncentivizedERC20.sol';\nimport {EIP712Base} from '@aave/core-v3/contracts/protocol/tokenization/base/EIP712Base.sol';\n\n// Gho Imports\nimport {IGhoToken} from '../../../gho/interfaces/IGhoToken.sol';\nimport {IGhoFacilitator} from '../../../gho/interfaces/IGhoFacilitator.sol';\nimport {IGhoAToken} from './interfaces/IGhoAToken.sol';\nimport {GhoVariableDebtToken} from './GhoVariableDebtToken.sol';\n\n/**\n * @title GhoAToken\n * @author Aave\n * @notice Implementation of the interest bearing token for the Aave protocol\n */\ncontract GhoAToken is VersionedInitializable, ScaledBalanceTokenBase, EIP712Base, IGhoAToken {\n  using WadRayMath for uint256;\n  using GPv2SafeERC20 for IERC20;\n\n  bytes32 public constant PERMIT_TYPEHASH =\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\n\n  uint256 public constant ATOKEN_REVISION = 0x1;\n\n  address internal _treasury;\n  address internal _underlyingAsset;\n\n  // Gho Storage\n  GhoVariableDebtToken internal _ghoVariableDebtToken;\n  address internal _ghoTreasury;\n\n  /// @inheritdoc VersionedInitializable\n  function getRevision() internal pure virtual override returns (uint256) {\n    return ATOKEN_REVISION;\n  }\n\n  /**\n   * @dev Constructor.\n   * @param pool The address of the Pool contract\n   */\n  constructor(\n    IPool pool\n  ) ScaledBalanceTokenBase(pool, 'GHO_ATOKEN_IMPL', 'GHO_ATOKEN_IMPL', 0) EIP712Base() {\n    // Intentionally left blank\n  }\n\n  /// @inheritdoc IInitializableAToken\n  function initialize(\n    IPool initializingPool,\n    address treasury,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 aTokenDecimals,\n    string calldata aTokenName,\n    string calldata aTokenSymbol,\n    bytes calldata params\n  ) external override initializer {\n    require(initializingPool == POOL, Errors.POOL_ADDRESSES_DO_NOT_MATCH);\n    _setName(aTokenName);\n    _setSymbol(aTokenSymbol);\n    _setDecimals(aTokenDecimals);\n\n    _treasury = treasury;\n    _underlyingAsset = underlyingAsset;\n    _incentivesController = incentivesController;\n\n    _domainSeparator = _calculateDomainSeparator();\n\n    emit Initialized(\n      underlyingAsset,\n      address(POOL),\n      treasury,\n      address(incentivesController),\n      aTokenDecimals,\n      aTokenName,\n      aTokenSymbol,\n      params\n    );\n  }\n\n  /// @inheritdoc IAToken\n  function mint(\n    address caller,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external virtual override onlyPool returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IAToken\n  function burn(\n    address from,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external virtual override onlyPool {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IAToken\n  function mintToTreasury(uint256 amount, uint256 index) external virtual override onlyPool {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IAToken\n  function transferOnLiquidation(\n    address from,\n    address to,\n    uint256 value\n  ) external virtual override onlyPool {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IERC20\n  function balanceOf(\n    address user\n  ) public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IERC20\n  function totalSupply() public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IAToken\n  function RESERVE_TREASURY_ADDRESS() external view override returns (address) {\n    return _treasury;\n  }\n\n  /// @inheritdoc IAToken\n  function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @notice Transfers the underlying asset to `target`.\n   * @dev It performs a mint of GHO on behalf of the `target`\n   * @dev Used by the Pool to transfer assets in borrow(), withdraw() and flashLoan()\n   * @param target The recipient of the underlying\n   * @param amount The amount getting transferred\n   */\n  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {\n    IGhoToken(_underlyingAsset).mint(target, amount);\n  }\n\n  /// @inheritdoc IAToken\n  function handleRepayment(\n    address user,\n    address onBehalfOf,\n    uint256 amount\n  ) external virtual override onlyPool {\n    uint256 balanceFromInterest = _ghoVariableDebtToken.getBalanceFromInterest(onBehalfOf);\n    if (amount <= balanceFromInterest) {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, amount);\n    } else {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, balanceFromInterest);\n      IGhoToken(_underlyingAsset).burn(amount - balanceFromInterest);\n    }\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function distributeFeesToTreasury() external virtual override {\n    uint256 balance = IERC20(_underlyingAsset).balanceOf(address(this));\n    IERC20(_underlyingAsset).transfer(_ghoTreasury, balance);\n    emit FeesDistributedToTreasury(_ghoTreasury, _underlyingAsset, balance);\n  }\n\n  /// @inheritdoc IAToken\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /**\n   * @notice Overrides the parent _transfer to force validated transfer() and transferFrom()\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   */\n  function _transfer(address from, address to, uint128 amount) internal override {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /**\n   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.DOMAIN_SEPARATOR()` for more detailed documentation\n   */\n  function DOMAIN_SEPARATOR() public view override(IAToken, EIP712Base) returns (bytes32) {\n    return super.DOMAIN_SEPARATOR();\n  }\n\n  /**\n   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.nonces()` for more detailed documentation\n   */\n  function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256) {\n    return super.nonces(owner);\n  }\n\n  /// @inheritdoc EIP712Base\n  function _EIP712BaseId() internal view override returns (string memory) {\n    return name();\n  }\n\n  /// @inheritdoc IAToken\n  function rescueTokens(address token, address to, uint256 amount) external override onlyPoolAdmin {\n    require(token != _underlyingAsset, Errors.UNDERLYING_CANNOT_BE_RESCUED);\n    IERC20(token).safeTransfer(to, amount);\n  }\n\n  /// @inheritdoc IGhoAToken\n  function setVariableDebtToken(address ghoVariableDebtToken) external override onlyPoolAdmin {\n    require(address(_ghoVariableDebtToken) == address(0), 'VARIABLE_DEBT_TOKEN_ALREADY_SET');\n    require(ghoVariableDebtToken != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    _ghoVariableDebtToken = GhoVariableDebtToken(ghoVariableDebtToken);\n    emit VariableDebtTokenSet(ghoVariableDebtToken);\n  }\n\n  /// @inheritdoc IGhoAToken\n  function getVariableDebtToken() external view override returns (address) {\n    return address(_ghoVariableDebtToken);\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function updateGhoTreasury(address newGhoTreasury) external override onlyPoolAdmin {\n    require(newGhoTreasury != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    address oldGhoTreasury = _ghoTreasury;\n    _ghoTreasury = newGhoTreasury;\n    emit GhoTreasuryUpdated(oldGhoTreasury, newGhoTreasury);\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function getGhoTreasury() external view override returns (address) {\n    return _ghoTreasury;\n  }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "getRevision",
                "initialize",
                "mint",
                "burn",
                "mintToTreasury",
                "transferOnLiquidation",
                "balanceOf",
                "totalSupply",
                "RESERVE_TREASURY_ADDRESS",
                "UNDERLYING_ASSET_ADDRESS",
                "transferUnderlyingTo",
                "handleRepayment",
                "distributeFeesToTreasury",
                "permit",
                "_transfer",
                "to",
                "_EIP712BaseId",
                "rescueTokens",
                "setVariableDebtToken",
                "getVariableDebtToken",
                "updateGhoTreasury",
                "getGhoTreasury"
            ],
            "state_variables": [
                "_ghoVariableDebtToken",
                "_treasury",
                "_underlyingAsset",
                "_ghoTreasury"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "GhoAToken_userBalanceAlwaysZero_151889bb",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoAToken.sol",
        "target_function": "balanceOf/handleRepayment/to/transferUnderlyingTo",
        "text_chunk": "  function balanceOf(\n    address user\n  ) public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n    return 0;\n  }\n\n\n  function handleRepayment(\n    address user,\n    address onBehalfOf,\n    uint256 amount\n  ) external virtual override onlyPool {\n    uint256 balanceFromInterest = _ghoVariableDebtToken.getBalanceFromInterest(onBehalfOf);\n    if (amount <= balanceFromInterest) {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, amount);\n    } else {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, balanceFromInterest);\n      IGhoToken(_underlyingAsset).burn(amount - balanceFromInterest);\n    }\n  }\n\n\n   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.nonces()` for more detailed documentation\n   */\n  function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256) {\n    return super.nonces(owner);\n  }\n\n\n  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {\n    IGhoToken(_underlyingAsset).mint(target, amount);\n  }\n",
        "formal_property": "invariant userBalanceAlwaysZero(address user)\n\tscaledBalanceOf(user) == 0\n\n// /**\n// * @title first handleRepayment(amount) after transferUnderlyingTo(amount) succeeds.\n// * @dev assumption of sufficient balanceOf(msg.sender) is justified because BorrowLogic.executeRepay()\n// * @dev executes: IERC20(params.asset).safeTransferFrom(msg.sender, reserveCache.aTokenAddress, paybackAmount);\n// * @dev before invocation of handleRepayment()\n// * OBSOLETE - GhoToken has other rules to validate the behavior of the facilitator level maintenance\n// */\n// rule handleRepayment_after_transferUnderlyingTo()\n// {\n// \tenv e;\n// \tcalldataarg arg;\n// \tuint256 amount;\n// \taddress target;\n// \taddress user;\n//     address onBehalfOf;\n// \ttransferUnderlyingTo(e, target, amount);\n// \trequire _ghoTokenHarness.balanceOf(e.msg.sender) >= amount; //underlying asset\n// \trequire e.msg.sender == currentContract;\n// \thandleRepayment@withrevert(e, user, onBehalfOf, amount);\n// \tassert !lastReverted, \"handleRepayment failed\";\n// }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "userBalanceAlwaysZero",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "transferUnderlyingTo",
                "handleRepayment",
                "_ghoTokenHarness.balanceOf",
                "scaledBalanceOf"
            ],
            "start_line": 97,
            "end_line": 126,
            "block_hash": "151889bb58a3b7cd37599e3f13e9d9fb"
        }
    },
    {
        "id": "GhoAToken_noMint_24a12bad",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoAToken.sol",
        "target_function": "mint",
        "text_chunk": "  function mint(\n    address caller,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external virtual override onlyPool returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n",
        "formal_property": "rule noMint() {\n\tenv e;\n\tcalldataarg args;\n\tmint(e, args);\n\tassert(false);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "noMint",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 45,
            "end_line": 50,
            "block_hash": "24a12badfb5761b515215eaeb059ec4c"
        }
    },
    {
        "id": "GhoAToken_noBurn_08a408e7",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoAToken.sol",
        "target_function": "burn",
        "text_chunk": "  function burn(\n    address from,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external virtual override onlyPool {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n",
        "formal_property": "rule noBurn() {\n\tenv e;\n\tcalldataarg args;\n\tburn(e, args);\n\tassert(false);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "noBurn",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 55,
            "end_line": 60,
            "block_hash": "08a408e7ab84233f43f4288e5ae04ce5"
        }
    },
    {
        "id": "GhoAToken_noTransfer_fa785b0e",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoAToken.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IERC20} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol';\nimport {GPv2SafeERC20} from '@aave/core-v3/contracts/dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {VersionedInitializable} from '@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {Errors} from '@aave/core-v3/contracts/protocol/libraries/helpers/Errors.sol';\nimport {WadRayMath} from '@aave/core-v3/contracts/protocol/libraries/math/WadRayMath.sol';\nimport {IPool} from '@aave/core-v3/contracts/interfaces/IPool.sol';\nimport {IAToken} from '@aave/core-v3/contracts/interfaces/IAToken.sol';\nimport {IAaveIncentivesController} from '@aave/core-v3/contracts/interfaces/IAaveIncentivesController.sol';\nimport {IInitializableAToken} from '@aave/core-v3/contracts/interfaces/IInitializableAToken.sol';\nimport {ScaledBalanceTokenBase} from '@aave/core-v3/contracts/protocol/tokenization/base/ScaledBalanceTokenBase.sol';\nimport {IncentivizedERC20} from '@aave/core-v3/contracts/protocol/tokenization/base/IncentivizedERC20.sol';\nimport {EIP712Base} from '@aave/core-v3/contracts/protocol/tokenization/base/EIP712Base.sol';\n\n// Gho Imports\nimport {IGhoToken} from '../../../gho/interfaces/IGhoToken.sol';\nimport {IGhoFacilitator} from '../../../gho/interfaces/IGhoFacilitator.sol';\nimport {IGhoAToken} from './interfaces/IGhoAToken.sol';\nimport {GhoVariableDebtToken} from './GhoVariableDebtToken.sol';\n\n/**\n * @title GhoAToken\n * @author Aave\n * @notice Implementation of the interest bearing token for the Aave protocol\n */\ncontract GhoAToken is VersionedInitializable, ScaledBalanceTokenBase, EIP712Base, IGhoAToken {\n  using WadRayMath for uint256;\n  using GPv2SafeERC20 for IERC20;\n\n  bytes32 public constant PERMIT_TYPEHASH =\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\n\n  uint256 public constant ATOKEN_REVISION = 0x1;\n\n  address internal _treasury;\n  address internal _underlyingAsset;\n\n  // Gho Storage\n  GhoVariableDebtToken internal _ghoVariableDebtToken;\n  address internal _ghoTreasury;\n\n  /// @inheritdoc VersionedInitializable\n  function getRevision() internal pure virtual override returns (uint256) {\n    return ATOKEN_REVISION;\n  }\n\n  /**\n   * @dev Constructor.\n   * @param pool The address of the Pool contract\n   */\n  constructor(\n    IPool pool\n  ) ScaledBalanceTokenBase(pool, 'GHO_ATOKEN_IMPL', 'GHO_ATOKEN_IMPL', 0) EIP712Base() {\n    // Intentionally left blank\n  }\n\n  /// @inheritdoc IInitializableAToken\n  function initialize(\n    IPool initializingPool,\n    address treasury,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 aTokenDecimals,\n    string calldata aTokenName,\n    string calldata aTokenSymbol,\n    bytes calldata params\n  ) external override initializer {\n    require(initializingPool == POOL, Errors.POOL_ADDRESSES_DO_NOT_MATCH);\n    _setName(aTokenName);\n    _setSymbol(aTokenSymbol);\n    _setDecimals(aTokenDecimals);\n\n    _treasury = treasury;\n    _underlyingAsset = underlyingAsset;\n    _incentivesController = incentivesController;\n\n    _domainSeparator = _calculateDomainSeparator();\n\n    emit Initialized(\n      underlyingAsset,\n      address(POOL),\n      treasury,\n      address(incentivesController),\n      aTokenDecimals,\n      aTokenName,\n      aTokenSymbol,\n      params\n    );\n  }\n\n  /// @inheritdoc IAToken\n  function mint(\n    address caller,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external virtual override onlyPool returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IAToken\n  function burn(\n    address from,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external virtual override onlyPool {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IAToken\n  function mintToTreasury(uint256 amount, uint256 index) external virtual override onlyPool {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IAToken\n  function transferOnLiquidation(\n    address from,\n    address to,\n    uint256 value\n  ) external virtual override onlyPool {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IERC20\n  function balanceOf(\n    address user\n  ) public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IERC20\n  function totalSupply() public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IAToken\n  function RESERVE_TREASURY_ADDRESS() external view override returns (address) {\n    return _treasury;\n  }\n\n  /// @inheritdoc IAToken\n  function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @notice Transfers the underlying asset to `target`.\n   * @dev It performs a mint of GHO on behalf of the `target`\n   * @dev Used by the Pool to transfer assets in borrow(), withdraw() and flashLoan()\n   * @param target The recipient of the underlying\n   * @param amount The amount getting transferred\n   */\n  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {\n    IGhoToken(_underlyingAsset).mint(target, amount);\n  }\n\n  /// @inheritdoc IAToken\n  function handleRepayment(\n    address user,\n    address onBehalfOf,\n    uint256 amount\n  ) external virtual override onlyPool {\n    uint256 balanceFromInterest = _ghoVariableDebtToken.getBalanceFromInterest(onBehalfOf);\n    if (amount <= balanceFromInterest) {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, amount);\n    } else {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, balanceFromInterest);\n      IGhoToken(_underlyingAsset).burn(amount - balanceFromInterest);\n    }\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function distributeFeesToTreasury() external virtual override {\n    uint256 balance = IERC20(_underlyingAsset).balanceOf(address(this));\n    IERC20(_underlyingAsset).transfer(_ghoTreasury, balance);\n    emit FeesDistributedToTreasury(_ghoTreasury, _underlyingAsset, balance);\n  }\n\n  /// @inheritdoc IAToken\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /**\n   * @notice Overrides the parent _transfer to force validated transfer() and transferFrom()\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   */\n  function _transfer(address from, address to, uint128 amount) internal override {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /**\n   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.DOMAIN_SEPARATOR()` for more detailed documentation\n   */\n  function DOMAIN_SEPARATOR() public view override(IAToken, EIP712Base) returns (bytes32) {\n    return super.DOMAIN_SEPARATOR();\n  }\n\n  /**\n   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.nonces()` for more detailed documentation\n   */\n  function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256) {\n    return super.nonces(owner);\n  }\n\n  /// @inheritdoc EIP712Base\n  function _EIP712BaseId() internal view override returns (string memory) {\n    return name();\n  }\n\n  /// @inheritdoc IAToken\n  function rescueTokens(address token, address to, uint256 amount) external override onlyPoolAdmin {\n    require(token != _underlyingAsset, Errors.UNDERLYING_CANNOT_BE_RESCUED);\n    IERC20(token).safeTransfer(to, amount);\n  }\n\n  /// @inheritdoc IGhoAToken\n  function setVariableDebtToken(address ghoVariableDebtToken) external override onlyPoolAdmin {\n    require(address(_ghoVariableDebtToken) == address(0), 'VARIABLE_DEBT_TOKEN_ALREADY_SET');\n    require(ghoVariableDebtToken != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    _ghoVariableDebtToken = GhoVariableDebtToken(ghoVariableDebtToken);\n    emit VariableDebtTokenSet(ghoVariableDebtToken);\n  }\n\n  /// @inheritdoc IGhoAToken\n  function getVariableDebtToken() external view override returns (address) {\n    return address(_ghoVariableDebtToken);\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function updateGhoTreasury(address newGhoTreasury) external override onlyPoolAdmin {\n    require(newGhoTreasury != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    address oldGhoTreasury = _ghoTreasury;\n    _ghoTreasury = newGhoTreasury;\n    emit GhoTreasuryUpdated(oldGhoTreasury, newGhoTreasury);\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function getGhoTreasury() external view override returns (address) {\n    return _ghoTreasury;\n  }\n}\n",
        "formal_property": "rule noTransfer() {\n\tenv e;\n\tcalldataarg args;\n\ttransfer(e, args);\n\tassert(false);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "noTransfer",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 65,
            "end_line": 70,
            "block_hash": "fa785b0e30ce23c60d5ff87ce195cd90"
        }
    },
    {
        "id": "GhoAToken_transferUnderlyingToCantExceedCapacity_fc35b61b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoAToken.sol",
        "target_function": "to/transferUnderlyingTo",
        "text_chunk": "   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.nonces()` for more detailed documentation\n   */\n  function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256) {\n    return super.nonces(owner);\n  }\n\n\n  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {\n    IGhoToken(_underlyingAsset).mint(target, amount);\n  }\n",
        "formal_property": "rule transferUnderlyingToCantExceedCapacity() {\n\taddress target;\n\tuint256 amount;\n\tenv e;\n\tuint256 facilitatorLevel = _ghoTokenHarness.getFacilitatorBucketLevel(currentContract);\n\tuint256 facilitatorCapacity = _ghoTokenHarness.getFacilitatorBucketCapacity(currentContract);\n\ttransferUnderlyingTo@withrevert(e, target, amount);\n\tassert(amount > (facilitatorCapacity - facilitatorLevel) => lastReverted);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferUnderlyingToCantExceedCapacity",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "transferUnderlyingTo",
                "_ghoTokenHarness.getFacilitatorBucketCapacity",
                "_ghoTokenHarness.getFacilitatorBucketLevel"
            ],
            "start_line": 76,
            "end_line": 84,
            "block_hash": "fc35b61b7882e310d407d473a482b6ca"
        }
    },
    {
        "id": "GhoAToken_totalSupplyAlwaysZero_736c995a",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoAToken.sol",
        "target_function": "totalSupply",
        "text_chunk": "  function totalSupply() public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n    return 0;\n  }\n",
        "formal_property": "rule totalSupplyAlwaysZero() {\n\tassert(totalSupply() == 0);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "totalSupplyAlwaysZero",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "totalSupply"
            ],
            "start_line": 90,
            "end_line": 92,
            "block_hash": "736c995ad3c88b2dd01f1c929aa751ef"
        }
    },
    {
        "id": "GhoAToken_handleRepayment_after_transferUnderlyingTo_a7e57735",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoAToken.sol",
        "target_function": "balanceOf/handleRepayment/to/transferUnderlyingTo",
        "text_chunk": "  function balanceOf(\n    address user\n  ) public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n    return 0;\n  }\n\n\n  function handleRepayment(\n    address user,\n    address onBehalfOf,\n    uint256 amount\n  ) external virtual override onlyPool {\n    uint256 balanceFromInterest = _ghoVariableDebtToken.getBalanceFromInterest(onBehalfOf);\n    if (amount <= balanceFromInterest) {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, amount);\n    } else {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, balanceFromInterest);\n      IGhoToken(_underlyingAsset).burn(amount - balanceFromInterest);\n    }\n  }\n\n\n   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.nonces()` for more detailed documentation\n   */\n  function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256) {\n    return super.nonces(owner);\n  }\n\n\n  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {\n    IGhoToken(_underlyingAsset).mint(target, amount);\n  }\n",
        "formal_property": "// rule handleRepayment_after_transferUnderlyingTo()\n// {\n// \tenv e;\n// \tcalldataarg arg;\n// \tuint256 amount;\n// \taddress target;\n// \taddress user;\n//     address onBehalfOf;\n\n// \ttransferUnderlyingTo(e, target, amount);\n// \trequire _ghoTokenHarness.balanceOf(e.msg.sender) >= amount; //underlying asset\n// \trequire e.msg.sender == currentContract;\n// \thandleRepayment@withrevert(e, user, onBehalfOf, amount);\n// \tassert !lastReverted, \"handleRepayment failed\";\n// }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "handleRepayment_after_transferUnderlyingTo",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "transferUnderlyingTo",
                "handleRepayment",
                "_ghoTokenHarness.balanceOf"
            ],
            "start_line": 109,
            "end_line": 126,
            "block_hash": "a7e5773556a4a749076c82be20b65613"
        }
    },
    {
        "id": "GhoAToken_level_does_not_decrease_after_transferUnderlyingTo_followed_by_handleRepayment_0fd157cc",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoAToken.sol",
        "target_function": "handleRepayment/to/transferUnderlyingTo",
        "text_chunk": "  function handleRepayment(\n    address user,\n    address onBehalfOf,\n    uint256 amount\n  ) external virtual override onlyPool {\n    uint256 balanceFromInterest = _ghoVariableDebtToken.getBalanceFromInterest(onBehalfOf);\n    if (amount <= balanceFromInterest) {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, amount);\n    } else {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, balanceFromInterest);\n      IGhoToken(_underlyingAsset).burn(amount - balanceFromInterest);\n    }\n  }\n\n\n   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.nonces()` for more detailed documentation\n   */\n  function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256) {\n    return super.nonces(owner);\n  }\n\n\n  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {\n    IGhoToken(_underlyingAsset).mint(target, amount);\n  }\n",
        "formal_property": "rule level_does_not_decrease_after_transferUnderlyingTo_followed_by_handleRepayment()\n{\n\tenv e;\n\tcalldataarg arg;\n\tuint256 amount;\n\taddress target;\n\taddress user;\n    address onBehalfOf;\n\n\tuint256 levelBefore = _ghoTokenHarness.getFacilitatorBucketLevel(currentContract);\n\ttransferUnderlyingTo(e, target, amount);\n\thandleRepayment(e, user, onBehalfOf, amount);\n\tuint256 levelAfter = _ghoTokenHarness.getFacilitatorBucketLevel(currentContract);\n\tassert levelBefore <= levelAfter;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "level_does_not_decrease_after_transferUnderlyingTo_followed_by_handleRepayment",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "transferUnderlyingTo",
                "handleRepayment",
                "_ghoTokenHarness.getFacilitatorBucketLevel"
            ],
            "start_line": 133,
            "end_line": 148,
            "block_hash": "0fd157cc7970ac1c49888bb69cb53937"
        }
    },
    {
        "id": "ERC20FlashMint_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC20FlashMint.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../../../interfaces/IERC3156FlashBorrower.sol\";\nimport \"../../../interfaces/IERC3156FlashLender.sol\";\nimport \"../ERC20.sol\";\n\nabstract contract ERC20FlashMint is ERC20, IERC3156FlashLender {\n    bytes32 private constant _RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    function maxFlashLoan(address token) public view virtual override returns (uint256) {\n        return token == address(this) ? type(uint256).max - ERC20.totalSupply() : 0;\n    }\n\n    function flashFee(address token, uint256 amount) public view virtual override returns (uint256) {\n        require(token == address(this), \"ERC20FlashMint: wrong token\");\n        amount;\n        return 0;\n    }\n\n    function _flashFeeReceiver() internal view virtual returns (address) {\n        return address(0);\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override returns (bool) {\n        require(amount <= maxFlashLoan(token), \"ERC20FlashMint: amount exceeds maxFlashLoan\");\n        uint256 fee = flashFee(token, amount);\n        _mint(address(receiver), amount);\n        require(\n            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == _RETURN_VALUE,\n            \"ERC20FlashMint: invalid return value\"\n        );\n        address flashFeeReceiver = _flashFeeReceiver();\n        _spendAllowance(address(receiver), address(this), amount + fee);\n        if (fee == 0 || flashFeeReceiver == address(0)) {\n            _burn(address(receiver), amount + fee);\n        } else {\n            _burn(address(receiver), amount);\n            _transfer(address(receiver), flashFeeReceiver, fee);\n        }\n        return true;\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "maxFlashLoan",
                "flashFee",
                "_flashFeeReceiver",
                "flashLoan"
            ],
            "state_variables": [],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC20FlashMint_letsWatchItBurns_9cf58e59",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20FlashMint.sol",
        "target_function": "flashFee/flashLoan",
        "text_chunk": "    function flashFee(address token, uint256 amount) public view virtual override returns (uint256) {\n        require(token == address(this), \"ERC20FlashMint: wrong token\");\n        amount;\n        return 0;\n    }\n\n\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override returns (bool) {\n        require(amount <= maxFlashLoan(token), \"ERC20FlashMint: amount exceeds maxFlashLoan\");\n        uint256 fee = flashFee(token, amount);\n        _mint(address(receiver), amount);\n        require(\n            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == _RETURN_VALUE,\n            \"ERC20FlashMint: invalid return value\"\n        );\n        address flashFeeReceiver = _flashFeeReceiver();\n        _spendAllowance(address(receiver), address(this), amount + fee);\n        if (fee == 0 || flashFeeReceiver == address(0)) {\n            _burn(address(receiver), amount + fee);\n        } else {\n            _burn(address(receiver), amount);\n            _transfer(address(receiver), flashFeeReceiver, fee);\n        }\n        return true;\n    }\n",
        "formal_property": "rule letsWatchItBurns(env e){\n    address receiver; address token; uint256 amount; bytes data;\n\n    uint256 feeBefore = flashFee(e, token, amount);\n    flashLoan(e, receiver, token, amount, data);\n    uint256 burned = trackedBurnAmount[receiver];\n    assert to_mathint(amount + feeBefore) == burned, \"cheater\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "letsWatchItBurns",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 18,
            "end_line": 28,
            "block_hash": "9cf58e5993110d423e5eecec35d3f37c"
        }
    },
    {
        "id": "PreciseBitwiseOps_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "PreciseBitwiseOps.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.10;\npragma experimental ABIEncoderV2;\n\ncontract PreciseBitwiseOps{\n    uint16 public constant MAX_RESERVES_COUNT = 128;\n    string public constant INVALID_RESERVE_INDEX = '74'; // 'Invalid reserve index'\n    uint256 public data;\n\n    constructor(){\n        data = 0;\n    }\n\n    function setBorrowing(\n    uint256 reserveIndex,\n    bool borrowing\n  ) public {\n    unchecked {\n      require(reserveIndex < MAX_RESERVES_COUNT, INVALID_RESERVE_INDEX);\n      uint256 bit = 1 << (reserveIndex << 1);\n      if (borrowing) {\n        data |= bit;\n      } else {\n        data &= ~bit;\n      }\n    }\n  }\n\n  function isBorrowing(\n    uint256 reserveIndex\n  ) public view returns (bool) {\n    unchecked {\n      require(reserveIndex < MAX_RESERVES_COUNT, INVALID_RESERVE_INDEX);\n      return (data >> (reserveIndex << 1)) & 1 != 0;\n    }\n  }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "setBorrowing",
                "isBorrowing"
            ],
            "state_variables": [
                "data"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "PreciseBitwiseOps_setBorrowing_499152eb",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PreciseBitwiseOps.sol",
        "target_function": "isBorrowing/setBorrowing",
        "text_chunk": "  function isBorrowing(\n    uint256 reserveIndex\n  ) public view returns (bool) {\n    unchecked {\n      require(reserveIndex < MAX_RESERVES_COUNT, INVALID_RESERVE_INDEX);\n      return (data >> (reserveIndex << 1)) & 1 != 0;\n    }\n  }\n\n\n    function setBorrowing(\n    uint256 reserveIndex,\n    bool borrowing\n  ) public {\n    unchecked {\n      require(reserveIndex < MAX_RESERVES_COUNT, INVALID_RESERVE_INDEX);\n      uint256 bit = 1 << (reserveIndex << 1);\n      if (borrowing) {\n        data |= bit;\n      } else {\n        data &= ~bit;\n      }\n    }\n  }\n",
        "formal_property": "rule setBorrowing(uint256 reserveIndex, bool borrowing)\n{\t\n\tsetBorrowing(reserveIndex, borrowing);\n\tassert isBorrowing(reserveIndex) == borrowing, \"unexpected result\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "setBorrowing",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 8,
            "end_line": 12,
            "block_hash": "499152ebededff1a5ec397cb8f497c9b"
        }
    },
    {
        "id": "GovernorPreventLateQuorum_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "GovernorPreventLateQuorum.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../../utils/math/Math.sol\";\n\nabstract contract GovernorPreventLateQuorum is Governor {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    uint64 private _voteExtension;\n    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;\n\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n\n    constructor(uint64 initialVoteExtension) {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }\n\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());\n    }\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        uint256 result = super._castVote(proposalId, account, support, reason, params);\n\n        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];\n\n        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {\n            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();\n\n            if (extendedDeadlineValue > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadlineValue);\n            }\n\n            extendedDeadline.setDeadline(extendedDeadlineValue);\n        }\n\n        return result;\n    }\n\n    function lateQuorumVoteExtension() public view virtual returns (uint64) {\n        return _voteExtension;\n    }\n\n    function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }\n\n    function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {\n        emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension);\n        _voteExtension = newVoteExtension;\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "proposalDeadline",
                "_castVote",
                "lateQuorumVoteExtension",
                "setLateQuorumVoteExtension",
                "_setLateQuorumVoteExtension"
            ],
            "state_variables": [
                "_extendedDeadlines",
                "_voteExtension"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "GovernorPreventLateQuorum_quorumReachedEffect_3893aaa1",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GovernorPreventLateQuorum.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../../utils/math/Math.sol\";\n\nabstract contract GovernorPreventLateQuorum is Governor {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    uint64 private _voteExtension;\n    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;\n\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n\n    constructor(uint64 initialVoteExtension) {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }\n\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());\n    }\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        uint256 result = super._castVote(proposalId, account, support, reason, params);\n\n        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];\n\n        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {\n            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();\n\n            if (extendedDeadlineValue > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadlineValue);\n            }\n\n            extendedDeadline.setDeadline(extendedDeadlineValue);\n        }\n\n        return result;\n    }\n\n    function lateQuorumVoteExtension() public view virtual returns (uint64) {\n        return _voteExtension;\n    }\n\n    function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }\n\n    function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {\n        emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension);\n        _voteExtension = newVoteExtension;\n    }\n}",
        "formal_property": "invariant quorumReachedEffect(env e, uint256 pId)\n    quorumReached(e, pId) => proposalCreated(pId) // bug: 0 supply 0 votes => quorumReached\n    // filtered { f -> f.selector != updateQuorumNumerator(uint256).selector } // * fails for this function\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "quorumReachedEffect",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 87,
            "end_line": 89,
            "block_hash": "3893aaa16f3c572b80dbe4cb7059c9fa"
        }
    },
    {
        "id": "GovernorPreventLateQuorum_proposalNotCreatedEffects_da848933",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GovernorPreventLateQuorum.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../../utils/math/Math.sol\";\n\nabstract contract GovernorPreventLateQuorum is Governor {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    uint64 private _voteExtension;\n    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;\n\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n\n    constructor(uint64 initialVoteExtension) {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }\n\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());\n    }\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        uint256 result = super._castVote(proposalId, account, support, reason, params);\n\n        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];\n\n        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {\n            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();\n\n            if (extendedDeadlineValue > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadlineValue);\n            }\n\n            extendedDeadline.setDeadline(extendedDeadlineValue);\n        }\n\n        return result;\n    }\n\n    function lateQuorumVoteExtension() public view virtual returns (uint64) {\n        return _voteExtension;\n    }\n\n    function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }\n\n    function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {\n        emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension);\n        _voteExtension = newVoteExtension;\n    }\n}",
        "formal_property": "invariant proposalNotCreatedEffects(env e, uint256 pId)\n    !proposalCreated(pId) => proposalNotCreated(e, pId)\n    // filtered { f -> f.selector != updateQuorumNumerator(uint256).selector } // * fails for this function\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "proposalNotCreatedEffects",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 96,
            "end_line": 98,
            "block_hash": "da84893396b3c64c6e687b0c45be2f3b"
        }
    },
    {
        "id": "GovernorPreventLateQuorum_proposalInOneState_00f46914",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GovernorPreventLateQuorum.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../../utils/math/Math.sol\";\n\nabstract contract GovernorPreventLateQuorum is Governor {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    uint64 private _voteExtension;\n    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;\n\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n\n    constructor(uint64 initialVoteExtension) {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }\n\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());\n    }\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        uint256 result = super._castVote(proposalId, account, support, reason, params);\n\n        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];\n\n        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {\n            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();\n\n            if (extendedDeadlineValue > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadlineValue);\n            }\n\n            extendedDeadline.setDeadline(extendedDeadlineValue);\n        }\n\n        return result;\n    }\n\n    function lateQuorumVoteExtension() public view virtual returns (uint64) {\n        return _voteExtension;\n    }\n\n    function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }\n\n    function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {\n        emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension);\n        _voteExtension = newVoteExtension;\n    }\n}",
        "formal_property": "invariant proposalInOneState(env e, uint256 pId) \n    proposalNotCreated(e, pId) || deadlineExtendable(e, pId) || deadlineExtended(e, pId)\n    // filtered { f -> f.selector != updateQuorumNumerator(uint256).selector } // * fails for this function\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "proposalInOneState",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 105,
            "end_line": 107,
            "block_hash": "00f4691423c21c2b248ef1da55338f4a"
        }
    },
    {
        "id": "GovernorPreventLateQuorum_deadlineChangeEffects_9ed80703",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorPreventLateQuorum.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../../utils/math/Math.sol\";\n\nabstract contract GovernorPreventLateQuorum is Governor {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    uint64 private _voteExtension;\n    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;\n\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n\n    constructor(uint64 initialVoteExtension) {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }\n\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());\n    }\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        uint256 result = super._castVote(proposalId, account, support, reason, params);\n\n        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];\n\n        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {\n            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();\n\n            if (extendedDeadlineValue > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadlineValue);\n            }\n\n            extendedDeadline.setDeadline(extendedDeadlineValue);\n        }\n\n        return result;\n    }\n\n    function lateQuorumVoteExtension() public view virtual returns (uint64) {\n        return _voteExtension;\n    }\n\n    function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }\n\n    function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {\n        emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension);\n        _voteExtension = newVoteExtension;\n    }\n}",
        "formal_property": "rule deadlineChangeEffects(method f) filtered {f -> !f.isView} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "deadlineChangeEffects",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 123,
            "end_line": 123,
            "block_hash": "9ed80703b16f29ba05a405ff75ca4354"
        }
    },
    {
        "id": "GovernorPreventLateQuorum_deadlineCantBeUnextended_01aa3557",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorPreventLateQuorum.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../../utils/math/Math.sol\";\n\nabstract contract GovernorPreventLateQuorum is Governor {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    uint64 private _voteExtension;\n    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;\n\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n\n    constructor(uint64 initialVoteExtension) {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }\n\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());\n    }\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        uint256 result = super._castVote(proposalId, account, support, reason, params);\n\n        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];\n\n        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {\n            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();\n\n            if (extendedDeadlineValue > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadlineValue);\n            }\n\n            extendedDeadline.setDeadline(extendedDeadlineValue);\n        }\n\n        return result;\n    }\n\n    function lateQuorumVoteExtension() public view virtual returns (uint64) {\n        return _voteExtension;\n    }\n\n    function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }\n\n    function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {\n        emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension);\n        _voteExtension = newVoteExtension;\n    }\n}",
        "formal_property": "rule deadlineCantBeUnextended(method f) \n    filtered {\n        f -> !f.isView\n        // && f.selector != updateQuorumNumerator(uint256).selector // * fails for this function\n    } {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "deadlineCantBeUnextended",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 141,
            "end_line": 145,
            "block_hash": "01aa35578c2d987611a5b84808f807f9"
        }
    },
    {
        "id": "GovernorPreventLateQuorum_canExtendDeadlineOnce_b0e8eb1f",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorPreventLateQuorum.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../../utils/math/Math.sol\";\n\nabstract contract GovernorPreventLateQuorum is Governor {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    uint64 private _voteExtension;\n    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;\n\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n\n    constructor(uint64 initialVoteExtension) {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }\n\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());\n    }\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        uint256 result = super._castVote(proposalId, account, support, reason, params);\n\n        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];\n\n        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {\n            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();\n\n            if (extendedDeadlineValue > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadlineValue);\n            }\n\n            extendedDeadline.setDeadline(extendedDeadlineValue);\n        }\n\n        return result;\n    }\n\n    function lateQuorumVoteExtension() public view virtual returns (uint64) {\n        return _voteExtension;\n    }\n\n    function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }\n\n    function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {\n        emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension);\n        _voteExtension = newVoteExtension;\n    }\n}",
        "formal_property": "rule canExtendDeadlineOnce(method f) filtered {f -> !f.isView} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "canExtendDeadlineOnce",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 162,
            "end_line": 162,
            "block_hash": "b0e8eb1f7498dccd19a02eda42896781"
        }
    },
    {
        "id": "GovernorPreventLateQuorum_hasVotedCorrelationNonzero_a02644ea",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorPreventLateQuorum.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../../utils/math/Math.sol\";\n\nabstract contract GovernorPreventLateQuorum is Governor {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    uint64 private _voteExtension;\n    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;\n\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n\n    constructor(uint64 initialVoteExtension) {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }\n\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());\n    }\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        uint256 result = super._castVote(proposalId, account, support, reason, params);\n\n        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];\n\n        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {\n            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();\n\n            if (extendedDeadlineValue > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadlineValue);\n            }\n\n            extendedDeadline.setDeadline(extendedDeadlineValue);\n        }\n\n        return result;\n    }\n\n    function lateQuorumVoteExtension() public view virtual returns (uint64) {\n        return _voteExtension;\n    }\n\n    function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }\n\n    function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {\n        emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension);\n        _voteExtension = newVoteExtension;\n    }\n}",
        "formal_property": "rule hasVotedCorrelationNonzero(uint256 pId, method f, env e) filtered {f -> !f.isView} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hasVotedCorrelationNonzero",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 186,
            "end_line": 186,
            "block_hash": "a02644ea49a9fdba0ace4d47344c2812"
        }
    },
    {
        "id": "GovernorPreventLateQuorum_againstVotesDontCount_3fa2e186",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorPreventLateQuorum.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../../utils/math/Math.sol\";\n\nabstract contract GovernorPreventLateQuorum is Governor {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    uint64 private _voteExtension;\n    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;\n\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n\n    constructor(uint64 initialVoteExtension) {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }\n\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());\n    }\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        uint256 result = super._castVote(proposalId, account, support, reason, params);\n\n        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];\n\n        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {\n            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();\n\n            if (extendedDeadlineValue > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadlineValue);\n            }\n\n            extendedDeadline.setDeadline(extendedDeadlineValue);\n        }\n\n        return result;\n    }\n\n    function lateQuorumVoteExtension() public view virtual returns (uint64) {\n        return _voteExtension;\n    }\n\n    function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }\n\n    function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {\n        emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension);\n        _voteExtension = newVoteExtension;\n    }\n}",
        "formal_property": "rule againstVotesDontCount(method f) filtered {f -> !f.isView} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "againstVotesDontCount",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 222,
            "end_line": 222,
            "block_hash": "3fa2e18635bb9fbd2e1c8eea2346e058"
        }
    },
    {
        "id": "GovernorPreventLateQuorum_deadlineExtenededIfQuorumReached_0b1a4deb",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorPreventLateQuorum.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../../utils/math/Math.sol\";\n\nabstract contract GovernorPreventLateQuorum is Governor {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    uint64 private _voteExtension;\n    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;\n\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n\n    constructor(uint64 initialVoteExtension) {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }\n\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());\n    }\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        uint256 result = super._castVote(proposalId, account, support, reason, params);\n\n        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];\n\n        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {\n            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();\n\n            if (extendedDeadlineValue > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadlineValue);\n            }\n\n            extendedDeadline.setDeadline(extendedDeadlineValue);\n        }\n\n        return result;\n    }\n\n    function lateQuorumVoteExtension() public view virtual returns (uint64) {\n        return _voteExtension;\n    }\n\n    function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }\n\n    function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {\n        emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension);\n        _voteExtension = newVoteExtension;\n    }\n}",
        "formal_property": "rule deadlineExtenededIfQuorumReached(method f) filtered {f -> !f.isView} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "deadlineExtenededIfQuorumReached",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 242,
            "end_line": 242,
            "block_hash": "0b1a4deb87454e4c22af13a788b3c4b0"
        }
    },
    {
        "id": "GovernorPreventLateQuorum_extendedDeadlineValueSetIfQuorumReached_f73c72c3",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorPreventLateQuorum.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../../utils/math/Math.sol\";\n\nabstract contract GovernorPreventLateQuorum is Governor {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    uint64 private _voteExtension;\n    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;\n\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n\n    constructor(uint64 initialVoteExtension) {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }\n\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());\n    }\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        uint256 result = super._castVote(proposalId, account, support, reason, params);\n\n        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];\n\n        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {\n            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();\n\n            if (extendedDeadlineValue > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadlineValue);\n            }\n\n            extendedDeadline.setDeadline(extendedDeadlineValue);\n        }\n\n        return result;\n    }\n\n    function lateQuorumVoteExtension() public view virtual returns (uint64) {\n        return _voteExtension;\n    }\n\n    function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }\n\n    function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {\n        emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension);\n        _voteExtension = newVoteExtension;\n    }\n}",
        "formal_property": "rule extendedDeadlineValueSetIfQuorumReached(method f) filtered {f -> !f.isView} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "extendedDeadlineValueSetIfQuorumReached",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 264,
            "end_line": 264,
            "block_hash": "f73c72c3c6b3dd95936fea650c175021"
        }
    },
    {
        "id": "GovernorPreventLateQuorum_deadlineNeverReduced_a3b44d5d",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorPreventLateQuorum.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\nimport \"../../utils/math/Math.sol\";\n\nabstract contract GovernorPreventLateQuorum is Governor {\n    using SafeCast for uint256;\n    using Timers for Timers.BlockNumber;\n\n    uint64 private _voteExtension;\n    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;\n\n    event ProposalExtended(uint256 indexed proposalId, uint64 extendedDeadline);\n    event LateQuorumVoteExtensionSet(uint64 oldVoteExtension, uint64 newVoteExtension);\n\n    constructor(uint64 initialVoteExtension) {\n        _setLateQuorumVoteExtension(initialVoteExtension);\n    }\n\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());\n    }\n\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual override returns (uint256) {\n        uint256 result = super._castVote(proposalId, account, support, reason, params);\n\n        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];\n\n        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {\n            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();\n\n            if (extendedDeadlineValue > proposalDeadline(proposalId)) {\n                emit ProposalExtended(proposalId, extendedDeadlineValue);\n            }\n\n            extendedDeadline.setDeadline(extendedDeadlineValue);\n        }\n\n        return result;\n    }\n\n    function lateQuorumVoteExtension() public view virtual returns (uint64) {\n        return _voteExtension;\n    }\n\n    function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {\n        _setLateQuorumVoteExtension(newVoteExtension);\n    }\n\n    function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {\n        emit LateQuorumVoteExtensionSet(_voteExtension, newVoteExtension);\n        _voteExtension = newVoteExtension;\n    }\n}",
        "formal_property": "rule deadlineNeverReduced(method f) filtered {f -> !f.isView} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "deadlineNeverReduced",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 286,
            "end_line": 286,
            "block_hash": "a3b44d5df59415109859383fba02fb93"
        }
    },
    {
        "id": "GovernorCountingSimple_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\n\nabstract contract GovernorCountingSimple is Governor {\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    function proposalVotes(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);\n    }\n\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= proposalvote.forVotes + proposalvote.abstainVotes;\n    }\n\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return proposalvote.forVotes > proposalvote.againstVotes;\n    }\n\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory\n    ) internal virtual override {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        require(!proposalvote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");\n        proposalvote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalvote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalvote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalvote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "COUNTING_MODE",
                "hasVoted",
                "proposalVotes",
                "_quorumReached",
                "_voteSucceeded",
                "_countVote"
            ],
            "state_variables": [
                "forVotes",
                "againstVotes",
                "_proposalVotes",
                "abstainVotes",
                "hasVoted"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "GovernorCountingSimple_SumOfVotesCastEqualSumOfPowerOfVotedPerProposal_3cc6e1a5",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "hasVoted",
        "text_chunk": "    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n",
        "formal_property": "invariant SumOfVotesCastEqualSumOfPowerOfVotedPerProposal(uint256 pId) \n\ttracked_weight(pId) == ghost_sum_vote_power_by_id(pId)\n\n/*\n * sum of all votes casted is equal to the sum of voting power of those who voted\n */\ninvariant SumOfVotesCastEqualSumOfPowerOfVoted() \n\tsum_tracked_weight() == sum_all_votes_power()\n* sum of all votes casted is greater or equal to the sum of voting power of those who voted at a specific proposal\n*/\ninvariant OneIsNotMoreThanAll(uint256 pId) \n\tsum_all_votes_power() >= tracked_weight(pId)\n//////////////////////////////////////////////////////////////////////////////\n///////////////////////////////// RULES //////////////////////////////////////\n * Only sender's voting status can be changed by execution of any cast vote function\n// Checked for castVote only. all 3 castVote functions call _castVote, so the completeness of the verification is counted on\n // the fact that the 3 functions themselves makes no changes, but rather call an internal function to execute.\n // That means that we do not check those 3 functions directly, however for castVote & castVoteWithReason it is quite trivial\n // to understand why this is ok. For castVoteBySig we basically assume that the signature referendum is correct without checking it.\n // We could check each function separately and pass the rule, but that would have uglyfied the code with no concrete \n // benefit, as it is evident that nothing is happening in the first 2 functions (calling a view function), and we do not desire to check the signature verification.\nrule noVoteForSomeoneElse(uint256 pId, uint8 sup, method f) {\n    env e; calldataarg args;\n    address voter = e.msg.sender;\n    address user;\n    bool hasVotedBefore_User = hasVoted(e, pId, user);\n    castVote@withrevert(e, pId, sup);\n    require(!lastReverted);\n    bool hasVotedAfter_User = hasVoted(e, pId, user);\n    assert user != voter => hasVotedBefore_User == hasVotedAfter_User;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "SumOfVotesCastEqualSumOfPowerOfVotedPerProposal",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "ghost_sum_vote_power_by_id"
            ],
            "start_line": 100,
            "end_line": 146,
            "block_hash": "3cc6e1a598a5ba7e312b46c014f7285b"
        }
    },
    {
        "id": "GovernorCountingSimple_noVoteForSomeoneElse_58a3768c",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "hasVoted",
        "text_chunk": "    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n",
        "formal_property": "rule noVoteForSomeoneElse(uint256 pId, uint8 sup, method f) {\n    env e; calldataarg args;\n\n    address voter = e.msg.sender;\n    address user;\n    bool hasVotedBefore_User = hasVoted(e, pId, user);\n    castVote@withrevert(e, pId, sup);\n    require(!lastReverted);\n    bool hasVotedAfter_User = hasVoted(e, pId, user);\n    assert user != voter => hasVotedBefore_User == hasVotedAfter_User;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "noVoteForSomeoneElse",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 132,
            "end_line": 146,
            "block_hash": "58a3768c1f3192f9e2346197ad30efc4"
        }
    },
    {
        "id": "GovernorCountingSimple_votingWeightMonotonicity_f9744902",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\n\nabstract contract GovernorCountingSimple is Governor {\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    function proposalVotes(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);\n    }\n\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= proposalvote.forVotes + proposalvote.abstainVotes;\n    }\n\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return proposalvote.forVotes > proposalvote.againstVotes;\n    }\n\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory\n    ) internal virtual override {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        require(!proposalvote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");\n        proposalvote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalvote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalvote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalvote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n}",
        "formal_property": "rule votingWeightMonotonicity(method f){\n    uint256 votingWeightBefore = sum_tracked_weight();\n\n    env e; \n    calldataarg args;\n    f(e, args);\n    uint256 votingWeightAfter = sum_tracked_weight();\n    assert votingWeightBefore <= votingWeightAfter, \"Voting weight was decreased somehow\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "votingWeightMonotonicity",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 152,
            "end_line": 162,
            "block_hash": "f9744902ef7e23d70e0d4813cef47589"
        }
    },
    {
        "id": "GovernorCountingSimple_hasVotedCorrelation_aedb2280",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "hasVoted",
        "text_chunk": "    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n",
        "formal_property": "rule hasVotedCorrelation(uint256 pId, method f, env e, uint256 bn) {\n    address acc = e.msg.sender;\n    \n    uint256 againstBefore = votesAgainst();\n    uint256 forBefore = votesFor();\n    uint256 abstainBefore = votesAbstain();\n\n    bool hasVotedBefore = hasVoted(e, pId, acc);\n    helperFunctionsWithRevert(pId, f, e);\n    require(!lastReverted);\n    uint256 againstAfter = votesAgainst();\n    uint256 forAfter = votesFor();\n    uint256 abstainAfter = votesAbstain();\n    bool hasVotedAfter = hasVoted(e, pId, acc);\n    // want all vote categories to not decrease and at least one category to increase\n    assert (!hasVotedBefore && hasVotedAfter) => (againstBefore <= againstAfter && forBefore <= forAfter && abstainBefore <= abstainAfter), \"no correlation: some category decreased\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hasVotedCorrelation",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 168,
            "end_line": 188,
            "block_hash": "aedb2280c240a0ed78397f4d5813e7fd"
        }
    },
    {
        "id": "GovernorCountingSimple_privilegedOnlyNumerator_21ee4bc4",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\n\nabstract contract GovernorCountingSimple is Governor {\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    function proposalVotes(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);\n    }\n\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= proposalvote.forVotes + proposalvote.abstainVotes;\n    }\n\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return proposalvote.forVotes > proposalvote.againstVotes;\n    }\n\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory\n    ) internal virtual override {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        require(!proposalvote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");\n        proposalvote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalvote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalvote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalvote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n}",
        "formal_property": "rule privilegedOnlyNumerator(method f, uint256 newQuorumNumerator){\n    env e;\n    calldataarg arg;\n    uint256 quorumNumBefore = quorumNumerator(e);\n\n    f(e, arg);\n    uint256 quorumNumAfter = quorumNumerator(e);\n    address executorCheck = getExecutor(e);\n    assert quorumNumBefore != quorumNumAfter => e.msg.sender == executorCheck, \"non privileged user changed quorum numerator\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "privilegedOnlyNumerator",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "quorum",
                "quorumNumerator",
                "getExecutor"
            ],
            "start_line": 194,
            "end_line": 205,
            "block_hash": "21ee4bc4be4e4407f38c365bb5a1bb58"
        }
    },
    {
        "id": "GovernorCountingSimple_privilegedOnlyTimelock_2d2fc4d5",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\n\nabstract contract GovernorCountingSimple is Governor {\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    function proposalVotes(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);\n    }\n\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= proposalvote.forVotes + proposalvote.abstainVotes;\n    }\n\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return proposalvote.forVotes > proposalvote.againstVotes;\n    }\n\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory\n    ) internal virtual override {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        require(!proposalvote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");\n        proposalvote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalvote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalvote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalvote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n}",
        "formal_property": "rule privilegedOnlyTimelock(method f, uint256 newQuorumNumerator){\n    env e;\n    calldataarg arg;\n    uint256 timelockBefore = timelock(e);\n\n    f(e, arg);\n    uint256 timelockAfter = timelock(e);\n    assert timelockBefore != timelockAfter => e.msg.sender == timelockBefore, \"non privileged user changed timelock\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "privilegedOnlyTimelock",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "timelock"
            ],
            "start_line": 207,
            "end_line": 217,
            "block_hash": "2d2fc4d516a0fbe6bffd4979cbf2a6db"
        }
    },
    {
        "id": "LaunchEvent_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "owner",
                "is",
                "currentPhase",
                "depositAVAX",
                "withdrawAVAX",
                "createPair",
                "withdrawLiquidity",
                "withdrawIncentives",
                "emergencyWithdraw",
                "allowEmergencyWithdraw",
                "skim",
                "getPenalty",
                "getIncentives",
                "getReserves",
                "getRJoeAmount",
                "pairBalance",
                "_atPhase",
                "_timelockElapsed",
                "_isStopped",
                "_safeTransferAVAX"
            ],
            "state_variables": [
                "floorPrice",
                "phaseOneNoFeeDuration",
                "rJoe",
                "tokenIncentivesBalance",
                "tokenAllocated",
                "avaxAllocated",
                "tokenIncentivesForUsers",
                "maxAllocation",
                "hasWithdrawnPair",
                "hasWithdrawnIncentives",
                "tokenIncentivesPercent",
                "pair",
                "tokenIncentiveIssuerRefund",
                "balance",
                "rJoeNeeded",
                "issuerTimelock",
                "fixedWithdrawPenalty",
                "getUserInfo",
                "phaseTwoDuration",
                "rJoePerAvax",
                "phaseOneDuration",
                "tokenReserve",
                "WAVAX",
                "auctionStart",
                "stopped",
                "rocketJoeFactory",
                "avaxReserve",
                "factory",
                "issuer",
                "token",
                "router",
                "lpSupply",
                "userTimelock",
                "maxWithdrawPenalty",
                "allocation"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "LaunchEvent_factoryGetPairCorrelationCurrentVals_64223241",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "factoryGetPairCorrelationCurrentVals",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "initialize",
                "issuer",
                "auctionStart",
                "tokenIncentivesPercent",
                "floorPrice",
                "userTimelock",
                "issuerTimelock",
                "maxWithdrawPenalty",
                "fixedWithdrawPenalty",
                "maxAllocation",
                "WAVAX",
                "token"
            ],
            "start_line": 153,
            "end_line": 160,
            "block_hash": "642232410a15b85048f54fb60583fa8c"
        }
    },
    {
        "id": "LaunchEvent_factoryGetPairCorrelationNewVals_ccaea0db",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n    {\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            require token == _token;\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "factoryGetPairCorrelationNewVals",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "initialize",
                "issuer",
                "auctionStart",
                "tokenIncentivesPercent",
                "floorPrice",
                "userTimelock",
                "issuerTimelock",
                "maxWithdrawPenalty",
                "fixedWithdrawPenalty",
                "maxAllocation",
                "WAVAX",
                "token",
                "getNewWAVAX"
            ],
            "start_line": 165,
            "end_line": 172,
            "block_hash": "ccaea0dbb2b7bf6626cbb50e9a1bf8c3"
        }
    },
    {
        "id": "LaunchEvent_pairAndGetPairCorrelation_9dc208c2",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "invariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "pairAndGetPairCorrelation",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "WAVAX",
                "token",
                "pair"
            ],
            "start_line": 178,
            "end_line": 185,
            "block_hash": "9dc208c2e364514c9c9ddb0df11a6ac3"
        }
    },
    {
        "id": "LaunchEvent_noIssuerForNonInitialized_8692606f",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "invariant noIssuerForNonInitialized()\n    !initialized() => issuer() == 0\n\n// STATUS - verified\ninvariant noAllocationIfNonInitialized(address user)\n    !initialized() => getUserAllocation(user) == 0\ninvariant noBalanceIfNonInitialized(address user)\n    !initialized() => getUserBalance(user) == 0\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/f186e56361246ec8fd72/?anonymousKey=f862b3d27b1ace55116959f9788d3e2a6e5d56c1\ninvariant notStoppedIfNonInitialized()\n    !initialized() => !stopped()\n// STATUS - \ninvariant noAuctionStartIfNonInitialized()\n    !initialized() => auctionStart() == 0\n// ALWAYS\n// - getUI[issuer].allocation == 0\ninvariant al_issuer_allocation_zero(address user)\n    getUserAllocation(issuer()) == 0\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "noIssuerForNonInitialized",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "allowEmergencyWithdraw",
                "issuer",
                "auctionStart",
                "initialized",
                "stopped",
                "getUserAllocation",
                "getUserBalance"
            ],
            "start_line": 192,
            "end_line": 224,
            "block_hash": "8692606ff9ec1e46edfb071b037d2522"
        }
    },
    {
        "id": "LaunchEvent_al_balance_less_than_allocation_7ba3bfd6",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "invariant al_balance_less_than_allocation(address user)\n    getUserBalance(user) <= getUserAllocation(user) \n\n// STATUS - verified\n// - getUI[user].allocation <= maxAllocation\ninvariant al_userAllocation_less_than_maxAllocation(address user)\n    getUserAllocation(user) <= maxAllocation()\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "al_balance_less_than_allocation",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "maxAllocation",
                "getUserAllocation",
                "getUserBalance"
            ],
            "start_line": 229,
            "end_line": 241,
            "block_hash": "7ba3bfd6fad4021c8e1951432bf402b2"
        }
    },
    {
        "id": "LaunchEvent_al_differentTokenAndWavaxAddresses_8b34ea20",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant al_differentTokenAndWavaxAddresses(address user)\n    WAVAX() != token()\n    {\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            require getNewWAVAX() != _token;\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "al_differentTokenAndWavaxAddresses",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "initialize",
                "issuer",
                "auctionStart",
                "tokenIncentivesPercent",
                "floorPrice",
                "userTimelock",
                "issuerTimelock",
                "maxWithdrawPenalty",
                "fixedWithdrawPenalty",
                "maxAllocation",
                "WAVAX",
                "token",
                "getNewWAVAX"
            ],
            "start_line": 246,
            "end_line": 253,
            "block_hash": "8b34ea20ba4f4d035ddfcda97eee55f2"
        }
    },
    {
        "id": "LaunchEvent_isInitialized_7b6f6346",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "invariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n    {\n        preserved{\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "isInitialized",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "allowEmergencyWithdraw",
                "initialized",
                "stopped"
            ],
            "start_line": 260,
            "end_line": 272,
            "block_hash": "7b6f6346796e139319f1ea722eba87b9"
        }
    },
    {
        "id": "LaunchEvent_initIssuerTimelockNonZero_ccf1c620",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant initIssuerTimelockNonZero()\n    initialized() => issuerTimelock() >= 1\n\n// STATUS - verified\n// - `userTimelock` <= 7 days\ninvariant initUserTimelockSeven()\n    initialized() => userTimelock() <= sevenDays()\n// - `auctionStart` > block.timestamp\ninvariant initAuctionStart(env e)\n    initialized() => auctionStart() > e.block.timestamp\n    {\n        preserved with (env e2){\n            require e.block.timestamp == e2.block.timestamp;\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "initIssuerTimelockNonZero",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "initialize",
                "issuer",
                "auctionStart",
                "userTimelock",
                "issuerTimelock",
                "initialized"
            ],
            "start_line": 277,
            "end_line": 295,
            "block_hash": "ccf1c620d15b2d1be4c10be2a8988fdf"
        }
    },
    {
        "id": "LaunchEvent_initPhaseTimesSet_635fe93a",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "createPair/currentPhase",
        "text_chunk": "    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n",
        "formal_property": "invariant initPhaseTimesSet()\n    initialized() => ( PHASE_ONE_DURATION() == twoDays()\n            && PHASE_ONE_NO_FEE_DURATION() == oneDay() && PHASE_TWO_DURATION() == oneDay())\n\n// STATUS - verified\n//  - `issuerTimelock` > `userTimelock`\ninvariant initTimelocksCorrelation()\n    initialized() => issuerTimelock() > userTimelock()\n// STATUS - verified (with invariant that is not finished and with Phases, otherwise createPair() causes a violation(violation as below))\n// run: https://vaas-stg.certora.com/output/3106/2ae7324af16683029e39/?anonymousKey=7202818cb360a87ab732a0ccdd7b9b3fa8c34f50\n// - `tokenIncentivesForUsers` == `tokenIncentivesBalance`\ninvariant initIncentivesCorrelation()\n    initialized() => tokenIncentivesForUsers() == tokenIncentivesBalance()\n    {\n        preserved with (env e2){\n            requireInvariant initNotStopped();\n            require pair() == 0;\n            require currentPhase(e2) == NotStarted();\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "initPhaseTimesSet",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "currentPhase",
                "createPair",
                "issuer",
                "PHASE_ONE_DURATION",
                "PHASE_ONE_NO_FEE_DURATION",
                "PHASE_TWO_DURATION",
                "userTimelock",
                "issuerTimelock",
                "initialized",
                "token",
                "pair",
                "tokenIncentivesBalance",
                "tokenIncentivesForUsers"
            ],
            "start_line": 301,
            "end_line": 323,
            "block_hash": "635fe93a83757347201743ed6c0c56d0"
        }
    },
    {
        "id": "LaunchEvent_initTokenBalanceCheck_3c36c8b0",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "is",
        "text_chunk": "    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n",
        "formal_property": "invariant initTokenBalanceCheck()\n    initialized() =>  tokenReserve() + tokenIncentivesForUsers() == getTokenBalanceOfThis()\n    {\n        preserved with (env e2){\n            requireInvariant initNotStopped();\n            require pair() == 0;\n            require token() == SymbERC20A || token() == SymbERC20B;\n            requireInvariant initIncentivesCorrelation();\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "initTokenBalanceCheck",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "initialized",
                "token",
                "pair",
                "tokenIncentivesForUsers",
                "tokenReserve",
                "getTokenBalanceOfThis",
                "getTokenBalance"
            ],
            "start_line": 332,
            "end_line": 341,
            "block_hash": "3c36c8b0877f1af3d4caad81a7e42455"
        }
    },
    {
        "id": "LaunchEvent_op_not_stopped_dfff86c7",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "invariant op_not_stopped()\n    pair() == 0 => !stopped()\n        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_not_stopped",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "allowEmergencyWithdraw",
                "stopped",
                "pair"
            ],
            "start_line": 351,
            "end_line": 353,
            "block_hash": "dfff86c75c74615572d76fde002bcd55"
        }
    },
    {
        "id": "LaunchEvent_op_user_not_withdrawn_pair_e8cceb2d",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/emergencyWithdraw/is",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n",
        "formal_property": "invariant op_user_not_withdrawn_pair(address user)\n    pair() == 0 => !userHasWithdrawnPair(user)\n\n// STATUS - verified\n// open implies user has not withdrawn\ninvariant op_user_not_withdrawn_incentives(address user)\n    pair() == 0 => !userHasWithdrawnIncentives(user)\n// STATUS - in progress\n// run: https://vaas-stg.certora.com/output/3106/4287810baacbcf95e993/?anonymousKey=e85517e16f5d7a8c2f2d68cde1b47c6a618e1d00\n// state after createPair() is out of the scope of open state\n//  - `WAVAX.balanceOf(LaunchEvent)` == \u03a3 getUI[user].balance\ninvariant opWavaxBalanceAndSumBalances()\n    pair() == 0 => getWAVAXbalanceOfThis() == sum_of_users_balances()\n    {\n        preserved{\n            requireInvariant op_not_stopped();                      // double check\ninvariant op_not_stopped()\n    pair() == 0 => !stopped()\n        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug\n            requireInvariant opWavaxBalanceAndWavaxReserve();\ninvariant opWavaxBalanceAndWavaxReserve()\n    pair() == 0 => getWAVAXbalanceOfThis() == avaxReserve()\n            requireInvariant op_not_stopped();\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_user_not_withdrawn_pair",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "createPair",
                "stopped",
                "WAVAX",
                "pair",
                "avaxReserve",
                "userHasWithdrawnPair",
                "userHasWithdrawnIncentives",
                "getWAVAXbalanceOfThis"
            ],
            "start_line": 358,
            "end_line": 379,
            "block_hash": "e8cceb2d256b2852dc895dd415cb9f65"
        }
    },
    {
        "id": "LaunchEvent_opWavaxBalanceAndWavaxReserve_96264217",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw/is",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n",
        "formal_property": "invariant opWavaxBalanceAndWavaxReserve()\n    pair() == 0 => getWAVAXbalanceOfThis() == avaxReserve()\n    {\n        preserved{\n            requireInvariant op_not_stopped();\ninvariant op_not_stopped()\n    pair() == 0 => !stopped()\n        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "opWavaxBalanceAndWavaxReserve",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "stopped",
                "WAVAX",
                "pair",
                "avaxReserve",
                "getWAVAXbalanceOfThis"
            ],
            "start_line": 385,
            "end_line": 391,
            "block_hash": "96264217a7f820fb528ef29d9a589b36"
        }
    },
    {
        "id": "LaunchEvent_opTokenBalanceCheck_32c154e8",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw/is",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n",
        "formal_property": "invariant opTokenBalanceCheck()\n    pair() == 0 =>  tokenReserve() + tokenIncentivesForUsers() == getTokenBalanceOfThis()\n    {\n        preserved with (env e2){\n            requireInvariant op_not_stopped();\ninvariant op_not_stopped()\n    pair() == 0 => !stopped()\n        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug\n            require token() == SymbERC20A || token() == SymbERC20B;\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n        preserved{\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant initIncentivesCorrelation();\n    }  \n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "opTokenBalanceCheck",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "stopped",
                "token",
                "pair",
                "tokenIncentivesForUsers",
                "tokenReserve",
                "getTokenBalanceOfThis",
                "getTokenBalance"
            ],
            "start_line": 398,
            "end_line": 407,
            "block_hash": "32c154e816995e11bfcfa709c1546b79"
        }
    },
    {
        "id": "LaunchEvent_op_avax_alloc_zero_4c623db8",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/emergencyWithdraw/is",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n",
        "formal_property": "invariant op_avax_alloc_zero()\n    pair() == 0 => avaxAllocated() == 0\n\n// STATUS - verified\n//  - lpSupply is 0\ninvariant op_lp_supply_zero()\n    pair() == 0 => lpSupply() == 0\n// createPair() violates the property: https://vaas-stg.certora.com/output/3106/6453fa43e1396eb864ad/?anonymousKey=c6322b9a791cdbea942221268091c2c963405500\n// - pair.balanceOf(address(this)) == 0\ninvariant opPairBalanceIsZero()\n    pair() == 0 => getPairBalanceOfThis() == 0\n    {\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n            requireInvariant factoryGetPairCorrelationCurrentVals(e2);\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_avax_alloc_zero",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "createPair",
                "avaxAllocated",
                "pair",
                "lpSupply",
                "getPairBalanceOfThis",
                "getPairBalance"
            ],
            "start_line": 412,
            "end_line": 432,
            "block_hash": "4c623db839ba12065fa73d1f6a935bd3"
        }
    },
    {
        "id": "LaunchEvent_opPairAndTotalSupplyCorrelation_8ef4aca5",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "invariant opPairAndTotalSupplyCorrelation()\n    pair() == 0 => getPairTotalSupply() == 0\n    {\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n            requireInvariant factoryGetPairCorrelationCurrentVals(e2);\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "opPairAndTotalSupplyCorrelation",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "pair",
                "getPairTotalSupply"
            ],
            "start_line": 437,
            "end_line": 444,
            "block_hash": "8ef4aca5f6d9ac1997580fef0c796503"
        }
    },
    {
        "id": "LaunchEvent_op_avax_reserve_sum_user_balances_9708f751",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/currentPhase/depositAVAX/emergencyWithdraw/withdrawAVAX",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n",
        "formal_property": "invariant op_avax_reserve_sum_user_balances()\n     pair() == 0 => avaxReserve() == sum_of_users_balances()\n\n// CLOSED - phase three\n// STATUS - in progress (allowEmergencyWithdraw() violation): https://vaas-stg.certora.com/output/3106/eca7dbb4b69c55f85043/?anonymousKey=44a9e39a1f83b15ab36662ee6d898cf1e147e43f\n//  - isStopped is false\ninvariant cl_not_stopped()\n    pair() != 0 => !stopped()\n// STATUS - verified https://vaas-stg.certora.com/output/3106/0ec29a324e7bdb9f86d2/?anonymousKey=deab759d00c63862d1166abb8a17b91ac040118b\n// run without preserved block: https://vaas-stg.certora.com/output/3106/cea4890e65f85e6d14eb/?anonymousKey=94c143aa0c1c85f0f961d154a6e60dafea974945\n// run with preserved block: https://vaas-stg.certora.com/output/3106/8863dca9bb0617161eb3/?anonymousKey=14fee042e6c8821f002886c4e7e0861ca072990c\n//  - avaxAllocated is \u03a3 getUA[user].balance\ninvariant cl_avax_alloc_sum_user_balances()\n    pair() != 0 => avaxAllocated() == sum_of_users_balances()\n    {\n        preserved with (env e2){\n            requireInvariant cl_not_stopped();                          // emergencyWithdraw()\n            require currentPhase(e2) == PhaseThree();                   // withdrawAVAX(uint256) and depositAVAX()\n        }\n        preserved createPair() with (env e3){\n            requireInvariant pairAndGetPairCorrelation(e3);             // createPair()\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n            requireInvariant factoryGetPairCorrelationCurrentVals(e3);  // createPair()\n            require avaxReserve() == sum_of_users_balances();          // Not sure if it's safe\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_avax_reserve_sum_user_balances",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "currentPhase",
                "depositAVAX",
                "withdrawAVAX",
                "createPair",
                "emergencyWithdraw",
                "allowEmergencyWithdraw",
                "stopped",
                "avaxAllocated",
                "pair",
                "avaxReserve"
            ],
            "start_line": 450,
            "end_line": 480,
            "block_hash": "9708f7512f38f7e97ba563f4652ade0f"
        }
    },
    {
        "id": "LaunchEvent_initially_f6e98bf0",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/currentPhase/emergencyWithdraw/is",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n",
        "formal_property": "// STATUS - in progress. (need preserved block for createPair() that invariant initially is true like require in a rule)\n// run without preserved block: \n// run with preserved block: \n// run: https://vaas-stg.certora.com/output/3106/9d1479ffd6d7489f4c84/?anonymousKey=92f17079fc91748fdd970538af733779da8888c1\ninvariant clWavaxCorrelation(env e)\n    pair() != 0 => (getWAVAXbalanceOfThis() == avaxReserve() && avaxReserve() == 0)\n    {\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n            require currentPhase(e2) == PhaseThree();\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "initially",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "currentPhase",
                "createPair",
                "WAVAX",
                "pair",
                "avaxReserve",
                "getWAVAXbalanceOfThis"
            ],
            "start_line": 483,
            "end_line": 494,
            "block_hash": "f6e98bf0d2403145840c553f925adb1b"
        }
    },
    {
        "id": "LaunchEvent_cl_pair_bal_eq_lp_sum_102fc6ff",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw/is/skim/withdrawIncentives",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n",
        "formal_property": "invariant cl_pair_bal_eq_lp_sum()\n    pair() != 0 => (getPairBalanceOfThis() == lpSupply() / 2 + unwithdrawn_users_lp_tokens)\n    {\n        preserved with (env e2){\n            requireInvariant cl_not_stopped();                          // emergencyWithdraw() and skim()\n            requireInvariant pairAndGetPairCorrelation(e2);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n            requireInvariant opPairBalanceIsZero();\n            require token() == SymbERC20A || token() == SymbERC20B;     // withdrawIncentives()\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_pair_bal_eq_lp_sum",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "withdrawIncentives",
                "emergencyWithdraw",
                "skim",
                "stopped",
                "token",
                "pair",
                "lpSupply",
                "getPairBalanceOfThis",
                "getPairBalance"
            ],
            "start_line": 501,
            "end_line": 510,
            "block_hash": "102fc6ffb8aef42b7213cd7bc3e6ed08"
        }
    },
    {
        "id": "LaunchEvent_cl_token_bal_eq_res_token_551d9cd2",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "invariant cl_token_bal_eq_res_token()\n    false\n\n// STATUS - in progress\n// run without preserved block: https://vaas-stg.certora.com/output/3106/e832cf49cb8c6eb0316a/?anonymousKey=d3e00feecadb1665fc4caf61d0f15b2c60f38459\n// run with preserved block (createPair() issue, pre-state pair() == 0 thus we can call this function): https://vaas-stg.certora.com/output/3106/b96d1d489077c95dc026/?anonymousKey=3c4fe014e274f60b7ccc58c12a3b91b558a3e632\n// - `tokenIncentivesBalance` <= `tokenIncentivesForUsers`\ninvariant clIncentivesCorrelation()\n    pair() != 0 => (tokenIncentivesBalance() <= tokenIncentivesForUsers())\n    {\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);     // createPair()\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_token_bal_eq_res_token",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "createPair",
                "token",
                "pair",
                "tokenIncentivesBalance",
                "tokenIncentivesForUsers"
            ],
            "start_line": 515,
            "end_line": 529,
            "block_hash": "551d9cd201a0f4d31e94914f46fc53a6"
        }
    },
    {
        "id": "LaunchEvent_cl_nonzero_user_pair_bal_949af2c0",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/currentPhase/emergencyWithdraw/pairBalance/withdrawAVAX",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n",
        "formal_property": "invariant cl_nonzero_user_pair_bal(address user, env e)\n    pair() != 0 => (!userHasWithdrawnPair(user) <=> pairBalance(e, user) != 0)\n    {\n        preserved with (env e2){\n            requireInvariant cl_not_stopped();                  // emergencyWithdraw()\n            require currentPhase(e2) == PhaseThree();           // withdrawAVAX(uint256)\n            requireInvariant pairAndGetPairCorrelation(e2);     // createPair()\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_nonzero_user_pair_bal",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "currentPhase",
                "withdrawAVAX",
                "createPair",
                "emergencyWithdraw",
                "pairBalance",
                "stopped",
                "pair",
                "userHasWithdrawnPair"
            ],
            "start_line": 537,
            "end_line": 545,
            "block_hash": "949af2c05fc86ae4b4235ca3510b0cfe"
        }
    },
    {
        "id": "LaunchEvent_cl_bal_this_zero_51a24eec",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "currentPhase/depositAVAX/is",
        "text_chunk": "    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n",
        "formal_property": "invariant cl_bal_this_zero()\n    pair() != 0 => getWAVAXbalanceOfThis() == 0\n    {\n        preserved with (env e2){\n            require currentPhase(e2) == PhaseThree();           // depositAVAX()\n            // should I add invariants from open state?\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_bal_this_zero",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "currentPhase",
                "depositAVAX",
                "WAVAX",
                "pair",
                "getWAVAXbalanceOfThis"
            ],
            "start_line": 552,
            "end_line": 559,
            "block_hash": "51a24eec88d58538c319b7ba381d9959"
        }
    },
    {
        "id": "LaunchEvent_but_22c5ee7f",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "currentPhase/depositAVAX",
        "text_chunk": "    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n",
        "formal_property": "// was listed as an invariant but makes more sense as a parametric rule\n//   - getUA[user].allocation is unchanging\nrule cl_user_alloc_unchanging(address user, method f, env e) {\n    require currentPhase(e) == PhaseThree(); // depositAVAX()\n\n    uint256 userAllocationBefore = getUserAllocation(user);\n    calldataarg args;\n    f(e, args);\n    uint256 userAllocationAfter = getUserAllocation(user);\n    assert userAllocationBefore == userAllocationAfter, \"tokenReserve was changed\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "but",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "currentPhase",
                "depositAVAX",
                "token",
                "tokenReserve",
                "getUserAllocation"
            ],
            "start_line": 597,
            "end_line": 610,
            "block_hash": "22c5ee7fd9c081bd8d0efda1d8a3d103"
        }
    },
    {
        "id": "LaunchEvent_cl_wavaxNotZero_2dd7bf12",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "pairBalance",
        "text_chunk": "    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n",
        "formal_property": "// invariant cl_wavaxNotZero()\n//     pair() != 0 => avaxAllocated() > 0\n\n// STATUS - in progress (maybe add userHasWithdrawnPair(issuer()) => tokenReserve() == 0) - does => <=> make sense?\n// run without preserved block: https://vaas-stg.certora.com/output/3106/b0f4853713af2301edcb/?anonymousKey=ea101ebc4801f04d91fddc5053dd7f37425a8089\n// run with preserved block: \n// - hasWithdrawnPair and LP token balance of user are related\n// invariant cl_hasWithdrawnPair_and_pairBalance_Correlation(env e, address user)\n//     pair() != 0 => (userHasWithdrawnPair(user) <=> getPairBalance(user) == pairBalance(e, user))\n//     {\n//         preserved{\n//             requireInvariant cl_wavaxNotZero();\n//         }\n//     }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_wavaxNotZero",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "pairBalance",
                "issuer",
                "token",
                "avaxAllocated",
                "pair",
                "tokenReserve",
                "userHasWithdrawnPair",
                "getPairBalance"
            ],
            "start_line": 902,
            "end_line": 915,
            "block_hash": "2dd7bf128809215041890e06ebf3d6e6"
        }
    },
    {
        "id": "LaunchEvent_hl_EqualityOfPairs_98e1af04",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw/is/pairBalance",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n",
        "formal_property": "invariant hl_EqualityOfPairs()\n    getPairBalanceOfThis() == getPairBalance(issuer()) + sumOfPairBalances()\n\n// STATUS - in progress\n// run without preserved block: https://vaas-stg.certora.com/output/3106/1f91c36ac4e4424e389f/?anonymousKey=c30c7ee9fd1cb8fe7198145cf50a5e0959f623e4\n// run with preserved block: \ninvariant hl_EqualityOfPairAndTotalSupply()\n    getPairBalanceOfThis() == getPairTotalSupplyOfThis()\n// run without preserved block: https://vaas-stg.certora.com/output/3106/23f2a4a600d0a020f0cb/?anonymousKey=d1d4fef9e201e201fd039a0dd0ddc1ea5306c9d7\n// run with preserved block: https://vaas-stg.certora.com/output/3106/9a888396ade18f00c01a/?anonymousKey=a7cdb01cf4b007d42ee8c2eb885757bfeebef6e6\ninvariant hl_TotalSupplyEquality()\n    getPairTotalSupply() == getPairTotalSupplyOfThis()\n    {\n        preserved with (env e2){\n            requireInvariant factoryGetPairCorrelationCurrentVals(e2);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n        }\n    }\n            // requireInvariant factoryGetPairCorrelationNewVals(e2);\n            requireInvariant pairAndGetPairCorrelation(e2);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\n            require Weth != currentContract;\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_EqualityOfPairs",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "issuer",
                "pair",
                "getPairBalanceOfThis",
                "getPairBalance",
                "getPairTotalSupply",
                "getPairTotalSupplyOfThis"
            ],
            "start_line": 1049,
            "end_line": 1072,
            "block_hash": "98e1af045582cb861b47aea81c47405d"
        }
    },
    {
        "id": "LaunchEvent_hl_EqualityOfToken_55222b90",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "depositAVAX/is/withdrawIncentives",
        "text_chunk": "    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n",
        "formal_property": "invariant hl_EqualityOfToken(env e) \n    getTokenBalanceOfThis() == tokenReserve() + tokenIncentivesBalance()\n    {\n        preserved with (env e2){\n            require token() == SymbERC20A || token() == SymbERC20B;     // depositAVAX() and many more          // token != instead of ==\n            require e2.msg.sender != currentContract;                   // withdrawIncentives()\n            require e.msg.sender == e2.msg.sender;       \n            // require e2.msg.sender == issuer();               \n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_EqualityOfToken",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "depositAVAX",
                "withdrawIncentives",
                "issuer",
                "token",
                "tokenIncentivesBalance",
                "tokenReserve",
                "getTokenBalanceOfThis",
                "getTokenBalance"
            ],
            "start_line": 1081,
            "end_line": 1090,
            "block_hash": "55222b90af36994d3f49c6e751d8f818"
        }
    },
    {
        "id": "LaunchEvent_op_token_res_fixed_4c0789a1",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "rule op_token_res_fixed(method f, env e) {\n\n    require pair() == 0;\n    requireInvariant pairAndGetPairCorrelation(e);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    require initialized();\n    require !stopped();\n    uint256 tokenReserveBefore = tokenReserve();\n    calldataarg args;\n    f(e, args);\n    uint256 tokenReserveAfter = tokenReserve();\n    assert tokenReserveBefore == tokenReserveAfter, \"tokenReserve was changed\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_token_res_fixed",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "initialized",
                "stopped",
                "token",
                "pair",
                "tokenReserve"
            ],
            "start_line": 574,
            "end_line": 591,
            "block_hash": "4c0789a19ca27a3db89c22889cbfd09a"
        }
    },
    {
        "id": "LaunchEvent_cl_user_alloc_unchanging_766e4fe7",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "currentPhase/depositAVAX",
        "text_chunk": "    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n",
        "formal_property": "rule cl_user_alloc_unchanging(address user, method f, env e) {\n    require currentPhase(e) == PhaseThree(); // depositAVAX()\n\n    uint256 userAllocationBefore = getUserAllocation(user);\n    calldataarg args;\n    f(e, args);\n    uint256 userAllocationAfter = getUserAllocation(user);\n    assert userAllocationBefore == userAllocationAfter, \"tokenReserve was changed\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_user_alloc_unchanging",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "currentPhase",
                "depositAVAX",
                "token",
                "tokenReserve",
                "getUserAllocation"
            ],
            "start_line": 599,
            "end_line": 610,
            "block_hash": "766e4fe7e562e005c71708e6e3efe691"
        }
    },
    {
        "id": "LaunchEvent_cl_avax_alloc_fixed_4745c99e",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "rule cl_avax_alloc_fixed(method f, env e) {\n    require pair() != 0;\n    requireInvariant pairAndGetPairCorrelation(e);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    uint256 wavaxAllocatedBefore = avaxAllocated();\n    calldataarg args;\n    f(e, args);\n    uint256 wavaxAllocatedAfter = avaxAllocated();\n    assert wavaxAllocatedBefore == wavaxAllocatedAfter, \"not yet implemented\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_avax_alloc_fixed",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "avaxAllocated",
                "pair"
            ],
            "start_line": 622,
            "end_line": 634,
            "block_hash": "4745c99e07e0c2385772e24b5f0431b5"
        }
    },
    {
        "id": "LaunchEvent_cl_lp_supply_fixed_b18365ef",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "rule cl_lp_supply_fixed(method f, env e) {\n    require pair() != 0;\n    requireInvariant pairAndGetPairCorrelation(e);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    uint256 lpSupplyBefore = lpSupply();\n    calldataarg args;\n    f(e, args);\n    uint256 lpSupplyAfter = lpSupply();\n    assert lpSupplyBefore == lpSupplyAfter, \"not yet implemented\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_lp_supply_fixed",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "pair",
                "lpSupply"
            ],
            "start_line": 639,
            "end_line": 651,
            "block_hash": "b18365ef1be68837b3be2d7116662e04"
        }
    },
    {
        "id": "LaunchEvent_al_userAllocationNonDecreasing_d2adb9b1",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "rule al_userAllocationNonDecreasing(method f, env e){     \n    address user;\n\n    uint256 allocationBefore = getUserAllocation(user);\n    calldataarg args;\n    f(e, args);\n    uint256 allocationAfter = getUserAllocation(user);\n    assert allocationBefore <= allocationAfter, \"allocation was decreased\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "al_userAllocationNonDecreasing",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "getUserAllocation"
            ],
            "start_line": 664,
            "end_line": 675,
            "block_hash": "d2adb9b1da2a968637cdbcbda6178491"
        }
    },
    {
        "id": "LaunchEvent_al_stoppedOnlyByOwner_38da33cb",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "owner",
        "text_chunk": "    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "rule al_stoppedOnlyByOwner(method f, env e){\n    bool isStoppedBefore = stopped();\n\n    calldataarg args;\n    f(e, args);\n    bool isStoppedAfter = stopped();\n    assert isStoppedBefore != isStoppedAfter => (e.msg.sender == getOwner() && isStoppedBefore == false), \"pair was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "al_stoppedOnlyByOwner",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "stopped",
                "pair",
                "getOwner"
            ],
            "start_line": 680,
            "end_line": 689,
            "block_hash": "38da33cb3b374b07b1e93b228bce97a2"
        }
    },
    {
        "id": "LaunchEvent_op_balanceChangeByDepositOrWithdraw_75f80f11",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "depositAVAX/withdrawAVAX",
        "text_chunk": "    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n",
        "formal_property": "rule op_balanceChangeByDepositOrWithdraw(method f, env e){     \n    address user;\n\n    uint256 balanceBefore = getUserBalance(user);\n    calldataarg args;\n    f(e, args);\n    uint256 balanceAfter = getUserBalance(user);\n    assert balanceBefore != balanceAfter <=> (e.msg.sender == user && (f.selector == depositAVAX().selector || f.selector == withdrawAVAX(uint256).selector)), \"pair was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_balanceChangeByDepositOrWithdraw",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "depositAVAX",
                "withdrawAVAX",
                "pair",
                "getUserBalance"
            ],
            "start_line": 697,
            "end_line": 708,
            "block_hash": "75f80f11cce8e5f1f3ab3ce491e3532a"
        }
    },
    {
        "id": "LaunchEvent_op_allocationChangeByDeposit_2cb6427b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "depositAVAX",
        "text_chunk": "    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n",
        "formal_property": "rule op_allocationChangeByDeposit(method f, env e){\n    address user;\n\n    uint256 allocationBefore = getUserAllocation(user);\n    calldataarg args;\n    f(e, args);\n    uint256 allocationAfter = getUserAllocation(user);\n    assert allocationBefore != allocationAfter => (f.selector == depositAVAX().selector && e.msg.sender == user), \"allocation was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_allocationChangeByDeposit",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "depositAVAX",
                "getUserAllocation"
            ],
            "start_line": 713,
            "end_line": 724,
            "block_hash": "2cb6427b77a4cd472f292f6bdd426ebc"
        }
    },
    {
        "id": "LaunchEvent_op_tokenReserveUnchange_a5c9b7c5",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/emergencyWithdraw/withdrawLiquidity",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n",
        "formal_property": "rule op_tokenReserveUnchange(method f, env e){\n    require pair() == 0;                    // createPair() and withdrawLiquidity()\n    requireInvariant pairAndGetPairCorrelation(e);   // createPair()\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    requireInvariant opPairAndTotalSupplyCorrelation();     // createPair()\ninvariant opPairAndTotalSupplyCorrelation()\n    pair() == 0 => getPairTotalSupply() == 0\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);\n            requireInvariant factoryGetPairCorrelationCurrentVals(e2);\n    requireInvariant op_not_stopped();      // emergencyWithdraw()\ninvariant op_not_stopped()\n    pair() == 0 => !stopped()\n        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug\n    requireInvariant isInitialized();       // initialize()\n    uint256 tokenReserveBefore = tokenReserve();\n    calldataarg args;\n    f(e, args);\n    uint256 tokenReserveAfter = tokenReserve();\n    assert tokenReserveBefore == tokenReserveAfter, \"tokenReserve was changed\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_tokenReserveUnchange",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "createPair",
                "withdrawLiquidity",
                "emergencyWithdraw",
                "stopped",
                "token",
                "pair",
                "tokenReserve"
            ],
            "start_line": 730,
            "end_line": 745,
            "block_hash": "a5c9b7c59c6e6cfbcf43aa7866e5248f"
        }
    },
    {
        "id": "LaunchEvent_op_tokenIncentivesBalanceUnchange_c120e2b5",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw/withdrawIncentives",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n",
        "formal_property": "rule op_tokenIncentivesBalanceUnchange(method f, env e){\n    require pair() == 0;                    // withdrawIncentives()\n    requireInvariant op_not_stopped();      // emergencyWithdraw()\ninvariant op_not_stopped()\n    pair() == 0 => !stopped()\n        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug\n    requireInvariant isInitialized();       // initialize()\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n    {\n        preserved{\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n    uint256 tokenIncentivesBalanceBefore = tokenIncentivesBalance();\n    calldataarg args;\n    f(e, args);\n    uint256 tokenIncentivesBalanceAfter = tokenIncentivesBalance();\n    assert tokenIncentivesBalanceBefore == tokenIncentivesBalanceAfter, \"tokenIncentivesBalance was changed\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_tokenIncentivesBalanceUnchange",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "withdrawIncentives",
                "emergencyWithdraw",
                "stopped",
                "token",
                "pair",
                "tokenIncentivesBalance"
            ],
            "start_line": 751,
            "end_line": 764,
            "block_hash": "c120e2b5db9edd6856fb1bb950a66d85"
        }
    },
    {
        "id": "LaunchEvent_op_tokenIncentivesForUsersUnchange_2035289a",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "rule op_tokenIncentivesForUsersUnchange(method f, env e){\n    require pair() == 0;                    // createPair()\n    requireInvariant pairAndGetPairCorrelation(e);   // createPair()\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    requireInvariant opPairAndTotalSupplyCorrelation();     // createPair()\ninvariant opPairAndTotalSupplyCorrelation()\n    pair() == 0 => getPairTotalSupply() == 0\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);\n            requireInvariant factoryGetPairCorrelationCurrentVals(e2);\n    requireInvariant isInitialized();       // initialize()\n    uint256 tokenIncentivesForUsersBefore = tokenIncentivesForUsers();\n    calldataarg args;\n    f(e, args);\n    uint256 tokenIncentivesForUsersAfter = tokenIncentivesForUsers();\n    assert tokenIncentivesForUsersBefore == tokenIncentivesForUsersAfter, \"tokenRestokenIncentivesForUserserve was changed\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_tokenIncentivesForUsersUnchange",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "createPair",
                "token",
                "pair",
                "tokenIncentivesForUsers"
            ],
            "start_line": 770,
            "end_line": 784,
            "block_hash": "2035289afbd4b179cc9e72433d5cbe52"
        }
    },
    {
        "id": "LaunchEvent_op_tokenIncentiveIssuerRefundUnchange_012a0fbe",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "rule op_tokenIncentiveIssuerRefundUnchange(method f, env e){\n    require pair() == 0;                                    // createPair()\n    requireInvariant pairAndGetPairCorrelation(e);          // createPair()\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    requireInvariant opPairAndTotalSupplyCorrelation();     // createPair()\ninvariant opPairAndTotalSupplyCorrelation()\n    pair() == 0 => getPairTotalSupply() == 0\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);\n            requireInvariant factoryGetPairCorrelationCurrentVals(e2);\n    uint256 tokenIncentiveIssuerRefundBefore = tokenIncentiveIssuerRefund();\n    calldataarg args;\n    f(e, args);\n    uint256 tokenIncentiveIssuerRefundAfter = tokenIncentiveIssuerRefund();\n    assert tokenIncentiveIssuerRefundBefore == tokenIncentiveIssuerRefundAfter, \"tokenIncentiveIssuerRefund was changed\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_tokenIncentiveIssuerRefundUnchange",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "createPair",
                "token",
                "pair",
                "tokenIncentiveIssuerRefund"
            ],
            "start_line": 790,
            "end_line": 803,
            "block_hash": "012a0fbee7bfa14f5cbe3e08d3aa3f7d"
        }
    },
    {
        "id": "LaunchEvent_tr_pairOnlyChange_df1224b1",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "rule tr_pairOnlyChange(method f, env e){     \n    requireInvariant pairAndGetPairCorrelation(e);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    address pairBefore = pair();\n    calldataarg args;\n    f(e, args);\n    address pairAfter = pair();\n    assert pairBefore != pairAfter <=> f.selector == createPair().selector, \"pair was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "tr_pairOnlyChange",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "createPair",
                "pair"
            ],
            "start_line": 820,
            "end_line": 831,
            "block_hash": "df1224b18909228ea33d00a9ea90802b"
        }
    },
    {
        "id": "LaunchEvent_tr_initializedOnlyChange_cc04200a",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "rule tr_initializedOnlyChange(method f){     \n    bool initBefore = initialized();\n\n    env e;\n    calldataarg args;\n    f(e, args);\n    bool initAfter = initialized();\n    assert initBefore != initAfter <=> f.selector == initialize(address, uint256, address, uint256, uint256, uint256, uint256, uint256, uint256, uint256).selector, \"initialized was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "tr_initializedOnlyChange",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "initialize",
                "initialized"
            ],
            "start_line": 835,
            "end_line": 845,
            "block_hash": "cc04200ac77d4c86c47c637c8d147b57"
        }
    },
    {
        "id": "LaunchEvent_tr_incentivesForUsersChanges_6edf9b0f",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "createPair",
        "text_chunk": "    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n",
        "formal_property": "rule tr_incentivesForUsersChanges(method f){     \n    uint256 incentivesBefore = tokenIncentivesForUsers();\n\n    env e;\n    calldataarg args;\n    f(e, args);\n    uint256 incentivesAfter = tokenIncentivesForUsers();\n    assert incentivesBefore != incentivesAfter \n                => f.selector == initialize(address, uint256, address, uint256, uint256, uint256, uint256, uint256, uint256, uint256).selector\n                || f.selector == createPair().selector, \"tokenIncentivesForUsers was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "tr_incentivesForUsersChanges",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "createPair",
                "token",
                "tokenIncentivesForUsers"
            ],
            "start_line": 849,
            "end_line": 861,
            "block_hash": "6edf9b0f209465dadfc69e936beb916e"
        }
    },
    {
        "id": "LaunchEvent_tr_incentiveIssuerRefundChanges_9dfd5655",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "createPair",
        "text_chunk": "    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n",
        "formal_property": "rule tr_incentiveIssuerRefundChanges(method f){     \n    uint256 incentivesBefore = tokenIncentiveIssuerRefund();\n\n    env e;\n    calldataarg args;\n    f(e, args);\n    uint256 incentivesAfter = tokenIncentiveIssuerRefund();\n    assert incentivesBefore != incentivesAfter => f.selector == createPair().selector, \"tokenIncentiveIssuerRefund was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "tr_incentiveIssuerRefundChanges",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "createPair",
                "token",
                "tokenIncentiveIssuerRefund"
            ],
            "start_line": 865,
            "end_line": 875,
            "block_hash": "9dfd5655868c14d1068a3b550b42994c"
        }
    },
    {
        "id": "LaunchEvent_cl_unchangingPair_4a1e2e99",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "rule cl_unchangingPair(method f, env e){\n    require pair() != 0;\n    requireInvariant pairAndGetPairCorrelation(e);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    address pairBefore = pair();\n    calldataarg args;\n    f(e, args);\n    address pairAfter = pair();\n    assert pairBefore == pairAfter, \"pair was changed in close stage\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_unchangingPair",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "pair"
            ],
            "start_line": 887,
            "end_line": 899,
            "block_hash": "4a1e2e994154cce111a5f85c225405ff"
        }
    },
    {
        "id": "LaunchEvent_cl_hasWithdrawnPair_pairBalance_OnlyChangeUser_1df066e2",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "pairBalance/withdrawLiquidity",
        "text_chunk": "    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n",
        "formal_property": "rule cl_hasWithdrawnPair_pairBalance_OnlyChangeUser(method f, env e){\n    address user;\n    require user != currentContract;\n    require user == e.msg.sender;\n    require user != issuer();\n\n    bool hasWPairBefore = userHasWithdrawnPair(user);\n    uint256 userPairBalanceBefore = getPairBalance(user);\n    uint256 possiblePairBalance = pairBalance(e, user);\n    helperFunctionsForWithdrawLiquidity(f, e);\n    \n    bool hasWPairAfter = userHasWithdrawnPair(user);\n    uint256 userPairBalanceAfter = getPairBalance(user);\n    assert (hasWPairBefore != hasWPairAfter && userPairBalanceAfter == userPairBalanceBefore + possiblePairBalance) <=> f.selector == withdrawLiquidity().selector, \"hasWithdrawnPair was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_hasWithdrawnPair_pairBalance_OnlyChangeUser",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "withdrawLiquidity",
                "pairBalance",
                "issuer",
                "pair",
                "userHasWithdrawnPair",
                "getPairBalance"
            ],
            "start_line": 923,
            "end_line": 939,
            "block_hash": "1df066e2722c3945aa84481034c71a00"
        }
    },
    {
        "id": "LaunchEvent_cl_hasWithdrawnPair_pairBalance_OnlyChangeIssuer_4b3ad46e",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "pairBalance/withdrawLiquidity",
        "text_chunk": "    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n",
        "formal_property": "rule cl_hasWithdrawnPair_pairBalance_OnlyChangeIssuer(method f, env e){\n    address user;\n    require user != currentContract;\n    require user == e.msg.sender;\n    require user == issuer();\n    require token() == SymbERC20A || token() == SymbERC20B;\n\n    bool hasWPairBefore = userHasWithdrawnPair(user);\n    uint256 userPairBalanceBefore = getPairBalance(user);\n    helperFunctionsForWithdrawLiquidity(f, e);\n    \n    bool hasWPairAfter = userHasWithdrawnPair(user);\n    uint256 userPairBalanceAfter = getPairBalance(user);\n    assert (hasWPairBefore != hasWPairAfter && userPairBalanceAfter == userPairBalanceBefore + (lpSupply() / 2)) <=> f.selector == withdrawLiquidity().selector, \"hasWithdrawnPair was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_hasWithdrawnPair_pairBalance_OnlyChangeIssuer",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "withdrawLiquidity",
                "pairBalance",
                "issuer",
                "token",
                "pair",
                "lpSupply",
                "userHasWithdrawnPair",
                "getPairBalance"
            ],
            "start_line": 942,
            "end_line": 958,
            "block_hash": "4b3ad46e7d838c7c88990d08b2af5376"
        }
    },
    {
        "id": "LaunchEvent_cl_pairAndTokenBalancesNonIncreasing_35be1fc6",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/currentPhase/depositAVAX/emergencyWithdraw/is/pairBalance",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n",
        "formal_property": "rule cl_pairAndTokenBalancesNonIncreasing(method f, env e){\n    require pair() != 0;                                // createPair()\n    requireInvariant pairAndGetPairCorrelation(e);      // createPair()\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    requireInvariant isInitialized();                   // initialize()\n    require currentPhase(e) == PhaseThree();            // depositAVAX() \n    uint256 tokenBalanceBefore = getTokenBalanceOfThis();\n    uint256 pairBalanceBefore = getPairBalanceOfThis();\n    calldataarg args;\n    f(e, args);\n    uint256 tokenBalanceAfter = getTokenBalanceOfThis();\n    uint256 pairBalanceAfter = getPairBalanceOfThis();\n    assert tokenBalanceBefore >= tokenBalanceAfter, \"token balance was increased\";\n    assert pairBalanceBefore >= pairBalanceAfter, \"pair balance was increased\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_pairAndTokenBalancesNonIncreasing",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "currentPhase",
                "depositAVAX",
                "createPair",
                "pairBalance",
                "token",
                "pair",
                "getTokenBalanceOfThis",
                "getPairBalanceOfThis",
                "getPairBalance",
                "getTokenBalance"
            ],
            "start_line": 966,
            "end_line": 984,
            "block_hash": "35be1fc67fdcd311849c3f2402b54805"
        }
    },
    {
        "id": "LaunchEvent_cl_hasWithdrawnIncentivesOnlyChange_901acb5d",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "withdrawIncentives",
        "text_chunk": "    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n",
        "formal_property": "rule cl_hasWithdrawnIncentivesOnlyChange(method f, env e){\n    bool hasWIncenBefore = userHasWithdrawnIncentives(e.msg.sender);\n\n    calldataarg args;\n    f(e, args);\n    bool hasWIncenAfter = userHasWithdrawnIncentives(e.msg.sender);\n    assert hasWIncenBefore != hasWIncenAfter => f.selector == withdrawIncentives().selector, \"hasWithdrawnIncentives was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_hasWithdrawnIncentivesOnlyChange",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "withdrawIncentives",
                "userHasWithdrawnIncentives"
            ],
            "start_line": 989,
            "end_line": 998,
            "block_hash": "901acb5db53842b4701d5b2852ef3969"
        }
    },
    {
        "id": "LaunchEvent_cl_tokenIncentivesBalancesNonIncreasing_782c4268",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "rule cl_tokenIncentivesBalancesNonIncreasing(method f, env e){\n    require initialized();\n    // require pair() != 0;\n    // require pair() == Factory.getPair(e, WAVAX(), token());\n\n    uint256 tokenIncentivesBalanceBefore = tokenIncentivesBalance();\n    calldataarg args;\n    f(e, args);\n    uint256 tokenIncentivesBalanceAfter = tokenIncentivesBalance();\n    assert tokenIncentivesBalanceBefore >= tokenIncentivesBalanceAfter, \"token incentives balance was increased\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_tokenIncentivesBalancesNonIncreasing",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "initialize",
                "initialized",
                "WAVAX",
                "token",
                "pair",
                "tokenIncentivesBalance"
            ],
            "start_line": 1005,
            "end_line": 1018,
            "block_hash": "782c42687dc54b18e1159733122c80b3"
        }
    },
    {
        "id": "LaunchEvent_cl_tokenIncentivesBalanceCanBeZero_20bf34c1",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "emergencyWithdraw",
        "text_chunk": "    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "rule cl_tokenIncentivesBalanceCanBeZero(method f, env e){\n    require initialized();          // initialize()\n\n    uint256 tokenIncentivesBalanceBefore = tokenIncentivesBalance();\n    require tokenIncentivesBalanceBefore > 0;\n    calldataarg args;\n    f(e, args);\n    uint256 tokenIncentivesBalanceAfter = tokenIncentivesBalance();\n    assert tokenIncentivesBalanceAfter == 0 <=> f.selector == emergencyWithdraw().selector, \"tokenIncentivesBalance is 0 unintentionally\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_tokenIncentivesBalanceCanBeZero",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "emergencyWithdraw",
                "initialized",
                "token",
                "tokenIncentivesBalance"
            ],
            "start_line": 1025,
            "end_line": 1038,
            "block_hash": "20bf34c13094f7e4595b254ef062e0a2"
        }
    },
    {
        "id": "LaunchEvent_hl_depositAdditivity_167b3f15",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "depositAVAX",
        "text_chunk": "    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n",
        "formal_property": "rule hl_depositAdditivity(env e, env e2){\n    require e.msg.value > 0;\n    require e.msg.value == 2 * e2.msg.value;\n    require e.msg.sender != e2.msg.sender;\n\n    uint256 userOneBalanceBefore = getUserBalance(e.msg.sender);\n    depositAVAX(e);\n    uint256 userOneBalanceAfter = getUserBalance(e.msg.sender);\n    \n    uint256 userTwoBalanceBefore = getUserBalance(e2.msg.sender);\n    require userOneBalanceBefore == userTwoBalanceBefore;\n    depositAVAX(e2);\n    uint256 userTwoBalanceAfter = getUserBalance(e2.msg.sender);\n    assert userOneBalanceAfter == userTwoBalanceAfter, \"deposit is not additive\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_depositAdditivity",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "depositAVAX",
                "getUserBalance"
            ],
            "start_line": 1097,
            "end_line": 1113,
            "block_hash": "167b3f1523dfc2de1f777beb8fdafd03"
        }
    },
    {
        "id": "LaunchEvent_hl_withdrawAdditivity_d369e83e",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "withdrawAVAX",
        "text_chunk": "    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n",
        "formal_property": "rule hl_withdrawAdditivity(env e){\n    uint256 single; uint256 doubleOne; uint256 doubleTwo;\n    require single > 0 && doubleOne > 0 && doubleTwo > 0;\n    require single == doubleOne + doubleTwo;\n\n    uint256 userBalanceAtStart = getUserBalance(e.msg.sender);\n    storage initialStorage = lastStorage;\n    withdrawAVAX(e, single);\n    uint256 userBalanceAfterSingle = getUserBalance(e.msg.sender);\n    withdrawAVAX(e, doubleOne) at initialStorage;\n    withdrawAVAX(e, doubleTwo);\n    uint256 userBalanceAfterDouble = getUserBalance(e.msg.sender);\n    assert userBalanceAfterSingle == userBalanceAfterDouble, \"withdraw is not additive\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_withdrawAdditivity",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "withdrawAVAX",
                "getUserBalance"
            ],
            "start_line": 1117,
            "end_line": 1135,
            "block_hash": "d369e83e42bd8c8daadbe8cb5843c834"
        }
    },
    {
        "id": "LaunchEvent_hl_moreDepositMoreGet_790a5a70",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "pairBalance/withdrawIncentives/withdrawLiquidity",
        "text_chunk": "    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n",
        "formal_property": "rule hl_moreDepositMoreGet(method f, env e, env e2){\n    require e.msg.sender != e2.msg.sender;\n    require e.msg.sender != issuer();\n    require e2.msg.sender != issuer();\n    require e.msg.sender != currentContract;\n    require e2.msg.sender != currentContract;\n    require lpSupply() >= avaxAllocated(); // assumption, need to double check\n    require token() == SymbERC20A || token() == SymbERC20B;\n\n    uint256 balanceOfuser1 = getUserBalance(e.msg.sender);\n    uint256 balanceOfuser2 = getUserBalance(e2.msg.sender);\n    require balanceOfuser2 > balanceOfuser1;\n    require avaxAllocated() >= balanceOfuser2 + balanceOfuser1;\n    uint256 pairOfuser1Before = getPairBalance(e.msg.sender);\n    uint256 tokenOfuser1Before = getTokenBalance(e.msg.sender);\n    uint256 pairOfuser2Before = getPairBalance(e2.msg.sender);\n    uint256 tokenOfuser2Before = getTokenBalance(e2.msg.sender);\n    require pairOfuser1Before == pairOfuser2Before;\n    require tokenOfuser1Before == tokenOfuser2Before;\n    withdrawLiquidity(e);\n    withdrawIncentives(e);\n    // check how much can I withdrawLiquidity or how much I withdrawn\n    uint256 pairOfuser1After = getPairBalance(e.msg.sender);\n    // check how much can I withdrawIncentives or how much I withdrawn\n    uint256 tokenOfuser1After = getTokenBalance(e.msg.sender);\n    withdrawLiquidity(e2);\n    withdrawIncentives(e2);\n    uint256 pairOfuser2After = getPairBalance(e2.msg.sender);\n    uint256 tokenOfuser2After = getTokenBalance(e2.msg.sender);\n    //assert\n    assert pairOfuser1After < pairOfuser2After && tokenOfuser1After < tokenOfuser2After, \"more deposit doesn't guarantee more rewards\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_moreDepositMoreGet",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "withdrawLiquidity",
                "withdrawIncentives",
                "issuer",
                "token",
                "avaxAllocated",
                "pair",
                "lpSupply",
                "getUserBalance",
                "getPairBalance",
                "getTokenBalance"
            ],
            "start_line": 1149,
            "end_line": 1188,
            "block_hash": "790a5a7064f3bce7ae6490fdd3ce19d7"
        }
    },
    {
        "id": "LaunchEvent_hl_withdrawLateMorePenalty_8a17898a",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "getPenalty",
        "text_chunk": "    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n",
        "formal_property": "rule hl_withdrawLateMorePenalty(method f, env e, env e2){\n    // define phase 1, the second half\n\n    require auctionStart() < e.block.timestamp;\n    require e.block.timestamp < e2.block.timestamp;\n    require e.block.timestamp > oneDay() && e.block.timestamp < twoDays();\n    require e2.block.timestamp < twoDays();\n    require e.msg.sender == e2.msg.sender;\n    require e.msg.sender != issuer();\n    require e.msg.sender != currentContract;\n    uint256 earlyPenalty = getPenalty(e);\n    uint256 latePenalty = getPenalty(e2);\n    assert earlyPenalty < latePenalty, \"penalty isn't greater\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_withdrawLateMorePenalty",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "getPenalty",
                "issuer",
                "auctionStart"
            ],
            "start_line": 1194,
            "end_line": 1210,
            "block_hash": "8a17898abf9c102a2d8a65de6adc9035"
        }
    },
    {
        "id": "LaunchEvent_hl_twoSideInverse_80aa2045",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "depositAVAX/withdrawAVAX",
        "text_chunk": "    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n",
        "formal_property": "rule hl_twoSideInverse(env e){\n    uint256 amount;\n\n    storage initialStorage = lastStorage;\n    depositAVAX(e);\n    withdrawAVAX(e, amount);\n    uint256 balanceOfUser1 = getUserBalance(e.msg.sender);\n    withdrawAVAX(e, amount) at initialStorage;\n    uint256 balanceOfUser2 = getUserBalance(e.msg.sender);\n    assert balanceOfUser1 == balanceOfUser2, \"balances are different\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_twoSideInverse",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "depositAVAX",
                "withdrawAVAX",
                "getUserBalance"
            ],
            "start_line": 1218,
            "end_line": 1232,
            "block_hash": "80aa2045947e3f82b3abeee6dd244908"
        }
    },
    {
        "id": "LaunchEvent_hl_noDepositFrontRun_151f3736",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "depositAVAX",
        "text_chunk": "    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n",
        "formal_property": "rule hl_noDepositFrontRun(method f, env e, env e2){\n    require e.msg.sender != e2.msg.sender;\n\n    calldataarg args;\n    storage initialStorage = lastStorage;\n    uint256 userBalanceBefore = getUserBalance(e.msg.sender);\n    depositAVAX(e);\n    uint256 userBalanceAfter1 = getUserBalance(e.msg.sender);\n    f(e2, args) at initialStorage;\n    uint256 userBalanceAfter2 = getUserBalance(e.msg.sender);\n    assert userBalanceBefore + e.msg.value == userBalanceAfter1 && userBalanceBefore + e.msg.value == userBalanceAfter2, \"frontrun on Deposit\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_noDepositFrontRun",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "depositAVAX",
                "getUserBalance"
            ],
            "start_line": 1237,
            "end_line": 1254,
            "block_hash": "151f37363be90758a3940799841d3321"
        }
    },
    {
        "id": "LaunchEvent_hl_noWithdrawFrontRun_cca8d8ad",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "withdrawAVAX",
        "text_chunk": "    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n",
        "formal_property": "rule hl_noWithdrawFrontRun(method f, env e, env e2){\n    require e.msg.sender != e2.msg.sender;\n    uint256 amount;\n\n    calldataarg args;\n    storage initialStorage = lastStorage;\n    uint256 userBalanceBefore = getUserBalance(e.msg.sender);\n    withdrawAVAX(e, amount);\n    uint256 userBalanceAfter1 = getUserBalance(e.msg.sender);\n    f(e2, args) at initialStorage;\n    uint256 userBalanceAfter2 = getUserBalance(e.msg.sender);\n    assert userBalanceBefore - amount == userBalanceAfter1 && userBalanceBefore - amount == userBalanceAfter2, \"frontrun on Withdraw\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_noWithdrawFrontRun",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "withdrawAVAX",
                "getUserBalance"
            ],
            "start_line": 1259,
            "end_line": 1277,
            "block_hash": "cca8d8adfb14ae7fc0f98fe62f8c6066"
        }
    },
    {
        "id": "LaunchEvent_hl_noWithdrawLiquidityFrontRun_b7cb43d2",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "pairBalance/withdrawLiquidity",
        "text_chunk": "    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n",
        "formal_property": "rule hl_noWithdrawLiquidityFrontRun(method f, env e, env e2){\n    require e.msg.sender != e2.msg.sender;\n    require e.msg.sender != currentContract;\n    require e2.msg.sender != currentContract;\n\n    calldataarg args;\n    storage initialStorage = lastStorage;\n    uint256 userBalanceBefore = getPairBalance(e.msg.sender);\n    uint256 whatShouldGet1 = pairBalance(e, e.msg.sender);\n    withdrawLiquidity(e);\n    uint256 userBalanceAfter1 = getPairBalance(e.msg.sender);\n    f(e2, args) at initialStorage;\n    uint256 whatShouldGet2 = pairBalance(e, e.msg.sender);\n    uint256 userBalanceAfter2 = getPairBalance(e.msg.sender);\n    assert whatShouldGet1 == whatShouldGet2, \"should get differs\";\n    assert userBalanceBefore + whatShouldGet1 == userBalanceAfter1 && userBalanceBefore + whatShouldGet2 == userBalanceAfter2, \"frontrun on WithdrawLiquidity\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_noWithdrawLiquidityFrontRun",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "withdrawLiquidity",
                "pairBalance",
                "pair",
                "getPairBalance"
            ],
            "start_line": 1283,
            "end_line": 1304,
            "block_hash": "b7cb43d2fc2073ea37275c84a49fbb21"
        }
    },
    {
        "id": "LaunchEvent_hl_createPairAtLeastOnce_0544e780",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "createPair",
        "text_chunk": "    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n",
        "formal_property": "rule hl_createPairAtLeastOnce(env e){\n    require !stopped();\n\n    // storage\n    createPair(e);\n    assert !lastReverted, \"createPair DoS\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_createPairAtLeastOnce",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "createPair",
                "stopped"
            ],
            "start_line": 1309,
            "end_line": 1320,
            "block_hash": "0544e780e07279cd32029365b1446898"
        }
    },
    {
        "id": "ERC20fixed_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC20fixed.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ContractsAndProperties/IERC20.sol\";\nimport \"../ContractsAndProperties/IERC20Metadata.sol\";\n\ncontract ERC20Fixed is IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    address public _owner;\n    constructor() {\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender);\n        _;\n    }\n    function name() public view virtual override returns (string memory) {\n        return \"\";\n    }\n    function symbol() public view virtual override returns (string memory) {\n        return \"\";\n    }\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"ERC20: transfer amount exceeds allowance\"\n        ); \n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        _transfer(sender, recipient, amount);\n\n        return true;\n    }\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        ); \n        return true;\n    }\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        ); \n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n    function mint(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n    function burn(address account, uint256 amount) onlyOwner() public virtual override {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function deposit() external payable {\n        _balances[msg.sender] += msg.value;\n        _totalSupply += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount <= _balances[msg.sender]);\n        _balances[msg.sender] -= amount;\n        _totalSupply -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success);\n    }\n\n\n    function addAmount(uint256 amount) external {\n            _balances[msg.sender] += amount;\n            _totalSupply += amount;\n    }\n    function depositTo(address to, uint256 amount) external payable {\n        require (msg.value > amount);\n        require (to != address(this));\n        unchecked {\n            _transfer(address(this), to, amount);\n            _transfer(address(this), msg.sender, msg.value - amount);\n        }\n    }\n\n    function add(uint256 x, uint256 y) external pure returns(uint256) {\n        unchecked {\n         return x + y;\n        }\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "name",
                "symbol",
                "decimals",
                "totalSupply",
                "balanceOf",
                "transfer",
                "allowance",
                "approve",
                "transferFrom",
                "increaseAllowance",
                "decreaseAllowance",
                "_transfer",
                "mint",
                "burn",
                "_approve",
                "_beforeTokenTransfer",
                "_afterTokenTransfer",
                "deposit",
                "withdraw",
                "addAmount",
                "depositTo",
                "add"
            ],
            "state_variables": [
                "_owner",
                "_totalSupply",
                "_balances",
                "_allowances"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC20fixed_totalSupplyIsSumOfBalances_285e39c7",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20fixed.sol",
        "target_function": "deposit/totalSupply",
        "text_chunk": "    function deposit() external payable {\n        _balances[msg.sender] += msg.value;\n        _totalSupply += msg.value;\n    }\n\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n",
        "formal_property": "invariant totalSupplyIsSumOfBalances()\n    totalSupply() == sum_of_balances;\n\n// satisfy examples\n// Generate an example trace for a first deposit operation that succeeds.\nrule satisfyFirstDepositSucceeds(){\n    env e;\n    require totalSupply() == 0;\n    deposit(e);\n    satisfy totalSupply() == e.msg.value;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "totalSupplyIsSumOfBalances",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 115,
            "end_line": 125,
            "block_hash": "285e39c7d27d6684ce81fc3add26661f"
        }
    },
    {
        "id": "ERC20fixed_transferSpec_96d1fa76",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20fixed.sol",
        "target_function": "balanceOf/transfer",
        "text_chunk": "    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n",
        "formal_property": "rule transferSpec {\n    address sender; address recip; uint amount;\n\n    env e;\n    require e.msg.sender == sender;\n    mathint balance_sender_before = balanceOf(sender);\n    mathint balance_recip_before = balanceOf(recip);\n    transfer(e, recip, amount);\n    mathint balance_sender_after = balanceOf(sender);\n    mathint balance_recip_after = balanceOf(recip);\n    require sender != recip;\n    assert balance_sender_after == balance_sender_before - amount,\n        \"transfer must decrease sender's balance by amount\";\n    assert balance_recip_after == balance_recip_before + amount,\n        \"transfer must increase recipient's balance by amount\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferSpec",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 17,
            "end_line": 38,
            "block_hash": "96d1fa76267dd6fb0082ae5e7e37977a"
        }
    },
    {
        "id": "ERC20fixed_transferReverts_935c84fa",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20fixed.sol",
        "target_function": "balanceOf/transfer",
        "text_chunk": "    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n",
        "formal_property": "rule transferReverts {\n    env e; address recip; uint amount;\n\n    require balanceOf(e.msg.sender) < amount;\n    transfer@withrevert(e, recip, amount);\n    assert lastReverted,\n        \"transfer(recip,amount) must revert if sender's balance is less than `amount`\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferReverts",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 43,
            "end_line": 52,
            "block_hash": "935c84fa69048b09163dafe6b685fb7f"
        }
    },
    {
        "id": "ERC20fixed_transferDoesntRevert_d2547cc1",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20fixed.sol",
        "target_function": "balanceOf/transfer",
        "text_chunk": "    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n",
        "formal_property": "rule transferDoesntRevert {\n    env e; address recipient; uint amount;\n\n    require balanceOf(e.msg.sender) > amount;\n    require e.msg.value == 0;\n    require balanceOf(recipient) + amount < max_uint;\n    require e.msg.sender != 0;\n    require recipient != 0;\n    transfer@withrevert(e, recipient, amount);\n    assert !lastReverted;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferDoesntRevert",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 63,
            "end_line": 74,
            "block_hash": "d2547cc132c3ce386ed9442048c13926"
        }
    },
    {
        "id": "ERC20fixed_onlyHolderCanChangeAllowance_14ef529a",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20fixed.sol",
        "target_function": "allowance/approve/increaseAllowance",
        "text_chunk": "    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        ); \n        return true;\n    }\n",
        "formal_property": "rule onlyHolderCanChangeAllowance {\n    address holder; address spender;\n\n    mathint allowance_before = allowance(holder, spender);\n    method f; env e; calldataarg args; // was: env e; uint256 amount;\n    f(e, args);                        // was: approve(e, spender, amount);\n    mathint allowance_after = allowance(holder, spender);\n    assert allowance_after > allowance_before => e.msg.sender == holder,\n        \"approve must only change the sender's allowance\";\n    assert allowance_after > allowance_before =>\n        (f.selector == sig:approve(address,uint).selector || f.selector == sig:increaseAllowance(address,uint).selector),\n        \"only approve and increaseAllowance can increase allowances\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "onlyHolderCanChangeAllowance",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 79,
            "end_line": 94,
            "block_hash": "14ef529a39a79314577fd0a21b875b69"
        }
    },
    {
        "id": "ERC20fixed_satisfyFirstDepositSucceeds_07cfc619",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20fixed.sol",
        "target_function": "deposit/totalSupply",
        "text_chunk": "    function deposit() external payable {\n        _balances[msg.sender] += msg.value;\n        _totalSupply += msg.value;\n    }\n\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n",
        "formal_property": "rule satisfyFirstDepositSucceeds(){\n    env e;\n    require totalSupply() == 0;\n    deposit(e);\n    satisfy totalSupply() == e.msg.value;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "satisfyFirstDepositSucceeds",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 120,
            "end_line": 125,
            "block_hash": "07cfc619e447ef40f139f5a3619eb82e"
        }
    },
    {
        "id": "ERC20fixed_satisfyLastWithdrawSucceeds_6ee7c75f",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20fixed.sol",
        "target_function": "deposit/totalSupply/withdraw",
        "text_chunk": "    function deposit() external payable {\n        _balances[msg.sender] += msg.value;\n        _totalSupply += msg.value;\n    }\n\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n\n    function withdraw(uint256 amount) external {\n        require(amount <= _balances[msg.sender]);\n        _balances[msg.sender] -= amount;\n        _totalSupply -= amount;\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success);\n    }\n",
        "formal_property": "rule satisfyLastWithdrawSucceeds() {\n    env e;\n    uint256 amount;\n    requireInvariant totalSupplyIsSumOfBalances();\ninvariant totalSupplyIsSumOfBalances()\n    totalSupply() == sum_of_balances;\n\n// satisfy examples\n// Generate an example trace for a first deposit operation that succeeds.\nrule satisfyFirstDepositSucceeds(){\n    require totalSupply() == 0;\n    deposit(e);\n    satisfy totalSupply() == e.msg.value;\n}\n    require totalSupply() > 0;\n    withdraw(e, amount);\n    satisfy totalSupply() == 0;\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "satisfyLastWithdrawSucceeds",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 128,
            "end_line": 135,
            "block_hash": "6ee7c75f2fa5a96fdbeceb723611b055"
        }
    },
    {
        "id": "ERC20fixed_satisfyWithManyOps_c8a1a286",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20fixed.sol",
        "target_function": "balanceOf/deposit/depositTo/totalSupply/transfer",
        "text_chunk": "    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n\n    function deposit() external payable {\n        _balances[msg.sender] += msg.value;\n        _totalSupply += msg.value;\n    }\n\n\n    function depositTo(address to, uint256 amount) external payable {\n        require (msg.value > amount);\n        require (to != address(this));\n        unchecked {\n            _transfer(address(this), to, amount);\n            _transfer(address(this), msg.sender, msg.value - amount);\n        }\n    }\n\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n",
        "formal_property": "rule satisfyWithManyOps(){\n    env e; env e1; env e2; env e3;\n    address recipient; uint amount;\n\n    requireInvariant totalSupplyIsSumOfBalances();\ninvariant totalSupplyIsSumOfBalances()\n    totalSupply() == sum_of_balances;\n// satisfy examples\n// Generate an example trace for a first deposit operation that succeeds.\nrule satisfyFirstDepositSucceeds(){\n    env e;\n    require totalSupply() == 0;\n    deposit(e);\n    satisfy totalSupply() == e.msg.value;\n}\n    // The following two requirement are to avoid overflow exmaples.\n    require balanceOf(e.msg.sender) > e.msg.value + 10 * amount;\n    require balanceOf(recipient) + amount < max_uint;\n    require e.msg.sender != 0;\n    require recipient != 0;\n    deposit(e1);\n    depositTo(e2, recipient, amount);\n    transfer(e3, recipient, amount);\n    assert totalSupply() > 0;  \n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "satisfyWithManyOps",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 138,
            "end_line": 152,
            "block_hash": "c8a1a2866f474a71ce76422128e3a93b"
        }
    },
    {
        "id": "ERC20fixed_satisfyVacuityCorrection_ceb1d0d7",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20fixed.sol",
        "target_function": "balanceOf/transfer",
        "text_chunk": "    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n",
        "formal_property": "rule satisfyVacuityCorrection {\n    env e; address recip; uint amount;\n\n    require balanceOf(e.msg.sender) > 0;\n    transfer(e, recip, amount);\n    satisfy balanceOf(e.msg.sender) == 0;\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "satisfyVacuityCorrection",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 157,
            "end_line": 165,
            "block_hash": "ceb1d0d7f04f111d68244427a37f71e9"
        }
    },
    {
        "id": "BallGame_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "BallGame.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\ncontract BallGame {\n\n    uint8 public ballPosition;\n\n    constructor() {\n        ballPosition = 1;\n    }\n    \n    function pass() external {\n        if (ballPosition == 1)\n            ballPosition = 3;\n        else if (ballPosition == 3)\n            ballPosition = 1;\n        else\n            ballPosition = 2;\n    }\n\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "pass"
            ],
            "state_variables": [
                "ballPosition"
            ],
            "is_standard": "UNKNOWN"
        }
    }
]