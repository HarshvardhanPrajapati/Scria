[
    {
        "id": "Vat_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "Vat.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n/// vat.sol -- Dai CDP database\n\n// Note: this is a somewhat updated version from that on Ethereum mainnet,\n// representing an intermediate product during preparation for deployment of\n// MCD on other domains. See https://github.com/makerdao/xdomain-dss. It is not\n// recommended to use or deploy this version. This repo is for pedagogical\n// purposes only.\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.13;\n\ncontract Vat {\n    // --- Data ---\n    mapping (address => uint256) public wards;\n\n    mapping(address => mapping (address => uint256)) public can;\n\n    // From https://hackmd.io/@SaferMaker/DAICertoraSurprise\n    // Vat.debt is an accumulator value that stores the sum over all DAI balances. \n    // Vat.vice is just the total bad debt (it is also technically an accumulator since bad debt is always \u201cassigned\u201d \n    // to some address). \n    // Vat.ilks[i].Art is yet another accumulator that is the sum over \u201cnormalized\u201d debt for a given collateral type (\u201cilk\u201d).\n    // Normalized debt is a value that when multiplied by the appropriate rate gives the current DAI debt.\n    struct Ilk {\n        uint256 Art;   // Total Normalized Debt     [wad] \n        uint256 rate;  // Accumulated Rates         [ray]\n        uint256 spot;  // Price with Safety Margin  [ray]\n        uint256 line;  // Debt Ceiling              [rad]\n        uint256 dust;  // Urn Debt Floor            [rad]\n    }\n    struct Urn {\n        uint256 ink;   // Locked Collateral  [wad]\n        uint256 art;   // Normalised Debt    [wad]\n    }\n\n    mapping (bytes32 => Ilk)                       public ilks;\n    mapping (bytes32 => mapping (address => Urn )) public urns;\n    mapping (bytes32 => mapping (address => uint)) public gem;  // [wad]\n    mapping (address => uint256)                   public dai;  // [rad]\n    mapping (address => uint256)                   public sin;  // [rad]\n\n    uint256 public debt;  // Total Dai Issued    [rad]\n    uint256 public vice;  // Total Unbacked Dai  [rad]\n    uint256 public Line;  // Total Debt Ceiling  [rad]\n    uint256 public live;  // Active Flag\n\n    // --- Events ---\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n    event Init(bytes32 indexed ilk);\n    event File(bytes32 indexed what, uint256 data);\n    event File(bytes32 indexed ilk, bytes32 indexed what, uint256 data);\n    event Cage();\n    event Hope(address indexed from, address indexed to);\n    event Nope(address indexed from, address indexed to);\n    event Slip(bytes32 indexed ilk, address indexed usr, int256 wad);\n    event Flux(bytes32 indexed ilk, address indexed src, address indexed dst, uint256 wad);\n    event Move(address indexed src, address indexed dst, uint256 rad);\n    event Frob(bytes32 indexed i, address indexed u, address v, address w, int256 dink, int256 dart);\n    event Fork(bytes32 indexed ilk, address indexed src, address indexed dst, int256 dink, int256 dart);\n    event Grab(bytes32 indexed i, address indexed u, address v, address w, int256 dink, int256 dart);\n    event Heal(address indexed u, uint256 rad);\n    event Suck(address indexed u, address indexed v, uint256 rad);\n    event Fold(bytes32 indexed i, address indexed u, int256 rate);\n\n    modifier auth {\n        require(wards[msg.sender] == 1, \"Vat/not-authorized\");\n        _;\n    }\n\n    function wish(address bit, address usr) internal view returns (bool) {\n        return either(bit == usr, can[bit][usr] == 1);\n    }\n\n    // --- Init ---\n    constructor() {\n        wards[msg.sender] = 1;\n        live = 1;\n        emit Rely(msg.sender);\n    }\n\n    // --- Math ---\n    function _add(uint256 x, int256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + uint256(y);\n        }\n        require(y >= 0 || z <= x);\n        require(y <= 0 || z >= x);\n    }\n\n    function _sub(uint256 x, int256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - uint256(y);\n        }\n        require(y <= 0 || z <= x);\n        require(y >= 0 || z >= x);\n    }\n\n    function _int256(uint256 x) internal pure returns (int256 y) {\n        require((y = int256(x)) >= 0);\n    }\n\n    // --- Administration ---\n    function rely(address usr) external auth {\n        require(live == 1, \"Vat/not-live\");\n        wards[usr] = 1;\n        emit Rely(usr);\n    }\n\n    function deny(address usr) external auth {\n        require(live == 1, \"Vat/not-live\");\n        wards[usr] = 0;\n        emit Deny(usr);\n    }\n\n    function init(bytes32 ilk) external auth {\n        require(ilks[ilk].rate == 0, \"Vat/ilk-already-init\");\n        ilks[ilk].rate = 10 ** 27;\n        emit Init(ilk);\n    }\n\n    function file(bytes32 what, uint256 data) external auth {\n        require(live == 1, \"Vat/not-live\");\n        if (what == \"Line\") Line = data;\n        else revert(\"Vat/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    function file(bytes32 ilk, bytes32 what, uint256 data) external auth {\n        require(live == 1, \"Vat/not-live\");\n        if (what == \"spot\") ilks[ilk].spot = data;\n        else if (what == \"line\") ilks[ilk].line = data;\n        else if (what == \"dust\") ilks[ilk].dust = data;\n        else revert(\"Vat/file-unrecognized-param\");\n        emit File(ilk, what, data);\n    }\n\n    function cage() external auth {\n        live = 0;\n        emit Cage();\n    }\n\n    // --- Structs getters ---\n    function Art(bytes32 ilk) external view returns (uint256 Art_) {\n        Art_ = ilks[ilk].Art;\n    }\n\n    function rate(bytes32 ilk) external view returns (uint256 rate_) {\n        rate_ = ilks[ilk].rate;\n    }\n\n    function spot(bytes32 ilk) external view returns (uint256 spot_) {\n        spot_ = ilks[ilk].spot;\n    }\n\n    function line(bytes32 ilk) external view returns (uint256 line_) {\n        line_ = ilks[ilk].line;\n    }\n\n    function dust(bytes32 ilk) external view returns (uint256 dust_) {\n        dust_ = ilks[ilk].dust;\n    }\n\n    function ink(bytes32 ilk, address urn) external view returns (uint256 ink_) {\n        ink_ = urns[ilk][urn].ink;\n    }\n\n    function art(bytes32 ilk, address urn) external view returns (uint256 art_) {\n        art_ = urns[ilk][urn].art;\n    }\n\n    // --- Allowance ---\n    function hope(address usr) external {\n        can[msg.sender][usr] = 1;\n        emit Hope(msg.sender, usr);\n    }\n\n    function nope(address usr) external {\n        can[msg.sender][usr] = 0;\n        emit Nope(msg.sender, usr);\n    }\n\n    // --- Fungibility ---\n    function slip(bytes32 ilk, address usr, int256 wad) external auth {\n        gem[ilk][usr] = _add(gem[ilk][usr], wad);\n        emit Slip(ilk, usr, wad);\n    }\n\n    function flux(bytes32 ilk, address src, address dst, uint256 wad) external {\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\n        gem[ilk][src] = gem[ilk][src] - wad;\n        gem[ilk][dst] = gem[ilk][dst] + wad;\n        emit Flux(ilk, src, dst, wad);\n    }\n\n    function move(address src, address dst, uint256 rad) external {\n        require(wish(src, msg.sender), \"Vat/not-allowed\");\n        dai[src] = dai[src] - rad;\n        dai[dst] = dai[dst] + rad;\n        emit Move(src, dst, rad);\n    }\n\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    // --- CDP Manipulation ---\n    function frob(bytes32 i, address u, address v, address w, int256 dink, int256 dart) external {\n        // system is live\n        require(live == 1, \"Vat/not-live\");\n\n        Urn memory urn = urns[i][u];\n        Ilk memory ilk = ilks[i];\n        // ilk has been initialised\n        require(ilk.rate != 0, \"Vat/ilk-not-init\");\n\n        urn.ink = _add(urn.ink, dink);\n        urn.art = _add(urn.art, dart);\n        ilk.Art = _add(ilk.Art, dart);\n\n        int256 dtab = _int256(ilk.rate) * dart;\n        uint256 tab = ilk.rate * urn.art;\n        debt     = _add(debt, dtab);\n\n        // either debt has decreased, or debt ceilings are not exceeded\n        require(either(dart <= 0, both(ilk.Art * ilk.rate <= ilk.line, debt <= Line)), \"Vat/ceiling-exceeded\");\n        // urn is either less risky than before, or it is safe\n        require(either(both(dart <= 0, dink >= 0), tab <= urn.ink * ilk.spot), \"Vat/not-safe\");\n\n        // urn is either more safe, or the owner consents\n        require(either(both(dart <= 0, dink >= 0), wish(u, msg.sender)), \"Vat/not-allowed-u\");\n        // collateral src consents\n        require(either(dink <= 0, wish(v, msg.sender)), \"Vat/not-allowed-v\");\n        // debt dst consents\n        require(either(dart >= 0, wish(w, msg.sender)), \"Vat/not-allowed-w\");\n\n        // urn has no debt, or a non-dusty amount\n        require(either(urn.art == 0, tab >= ilk.dust), \"Vat/dust\");\n\n        gem[i][v] = _sub(gem[i][v], dink);\n        dai[w]    = _add(dai[w],    dtab);\n\n        urns[i][u] = urn;\n        ilks[i]    = ilk;\n\n        emit Frob(i, u, v, w, dink, dart);\n    }\n\n    // --- CDP Fungibility ---\n    function fork(bytes32 ilk, address src, address dst, int256 dink, int256 dart) external {\n        Urn storage u = urns[ilk][src];\n        Urn storage v = urns[ilk][dst];\n        Ilk storage i = ilks[ilk];\n\n        u.ink = _sub(u.ink, dink);\n        u.art = _sub(u.art, dart);\n        v.ink = _add(v.ink, dink);\n        v.art = _add(v.art, dart);\n\n        uint256 utab = u.art * i.rate;\n        uint256 vtab = v.art * i.rate;\n\n        // both sides consent\n        require(both(wish(src, msg.sender), wish(dst, msg.sender)), \"Vat/not-allowed\");\n\n        // both sides safe\n        require(utab <= u.ink * i.spot, \"Vat/not-safe-src\");\n        require(vtab <= v.ink * i.spot, \"Vat/not-safe-dst\");\n\n        // both sides non-dusty\n        require(either(utab >= i.dust, u.art == 0), \"Vat/dust-src\");\n        require(either(vtab >= i.dust, v.art == 0), \"Vat/dust-dst\");\n\n        emit Fork(ilk, src, dst, dink, dart);\n    }\n\n    // --- CDP Confiscation ---\n    function grab(bytes32 i, address u, address v, address w, int256 dink, int256 dart) external auth {\n        Urn storage urn = urns[i][u];\n        Ilk storage ilk = ilks[i];\n\n        urn.ink = _add(urn.ink, dink);\n        urn.art = _add(urn.art, dart);\n        ilk.Art = _add(ilk.Art, dart);\n\n        int256 dtab = _int256(ilk.rate) * dart;\n\n        gem[i][v] = _sub(gem[i][v], dink);\n        sin[w]    = _sub(sin[w],    dtab);\n        vice      = _sub(vice,      dtab);\n\n        emit Grab(i, u, v, w, dink, dart);\n    }\n\n    // --- Settlement ---\n    function heal(uint256 rad) external {\n        address u = msg.sender;\n        sin[u] = sin[u] - rad;\n        dai[u] = dai[u] - rad;\n        vice   = vice   - rad;\n        debt   = debt   - rad;\n\n        emit Heal(msg.sender, rad);\n    }\n\n    function suck(address u, address v, uint256 rad) external auth {\n        sin[u] = sin[u] + rad;\n        dai[v] = dai[v] + rad;\n        vice   = vice   + rad;\n        debt   = debt   + rad;\n\n        emit Suck(u, v, rad);\n    }\n\n    // --- Rates ---\n    function fold(bytes32 i, address u, int256 rate_) external auth {\n        require(live == 1, \"Vat/not-live\");\n        Ilk storage ilk = ilks[i];\n        ilk.rate    = _add(ilk.rate, rate_);\n        int256 rad  = _int256(ilk.Art) * rate_;\n        dai[u]      = _add(dai[u], rad);\n        debt        = _add(debt,   rad);\n\n        emit Fold(i, u, rate_);\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "wish",
                "_add",
                "_sub",
                "_int256",
                "rely",
                "deny",
                "init",
                "file",
                "cage",
                "Art",
                "rate",
                "spot",
                "line",
                "dust",
                "ink",
                "art",
                "hope",
                "nope",
                "slip",
                "flux",
                "move",
                "either",
                "both",
                "frob",
                "fork",
                "grab",
                "heal",
                "suck",
                "fold"
            ],
            "is_standard": "UNKNOWN"
        }
    }
]