[
    {
        "id": "Accounts_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "Accounts.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is\n  IAccounts,\n  ICeloVersionedContract,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct SignerAuthorization {\n    bool started;\n    bool completed;\n  }\n\n  struct Account {\n    bool exists;\n    // [Deprecated] Each account may authorize signing keys to use for voting,\n    // validating or attestation. These keys may not be keys of other accounts,\n    // and may not be authorized by any other account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  struct PaymentDelegation {\n    // Address that should receive a fraction of validator payments.\n    address beneficiary;\n    // Fraction of payment to delegate to `beneficiary`.\n    FixidityLib.Fraction fraction;\n  }\n\n  mapping(address => Account) internal accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n  // Default signers by account (replaces the legacy Signers struct on Account)\n  mapping(address => mapping(bytes32 => address)) defaultSigners;\n  // All signers and their roles for a given account\n  // solhint-disable-next-line max-line-length\n  mapping(address => mapping(bytes32 => mapping(address => SignerAuthorization))) signerAuthorizations;\n\n  bytes32 public constant EIP712_AUTHORIZE_SIGNER_TYPEHASH = keccak256(\n    \"AuthorizeSigner(address account,address signer,bytes32 role)\"\n  );\n  bytes32 public eip712DomainSeparator;\n\n  // A per-account list of CIP8 storage roots, bypassing CIP3.\n  mapping(address => bytes[]) public offchainStorageRoots;\n\n  // Optional per-account validator payment delegation information.\n  mapping(address => PaymentDelegation) internal paymentDelegations;\n\n  bytes32 constant ValidatorSigner = keccak256(abi.encodePacked(\"celo.org/core/validator\"));\n  bytes32 constant AttestationSigner = keccak256(abi.encodePacked(\"celo.org/core/attestation\"));\n  bytes32 constant VoteSigner = keccak256(abi.encodePacked(\"celo.org/core/vote\"));\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event SignerAuthorized(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationStarted(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationCompleted(address indexed account, address signer, bytes32 indexed role);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event IndexedSignerSet(address indexed account, address signer, bytes32 role);\n  event IndexedSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event DefaultSignerSet(address indexed account, address signer, bytes32 role);\n  event DefaultSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event LegacySignerSet(address indexed account, address signer, bytes32 role);\n  event LegacySignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event SignerRemoved(address indexed account, address oldSigner, bytes32 indexed role);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n  event OffchainStorageRootAdded(address indexed account, bytes url);\n  event OffchainStorageRootRemoved(address indexed account, bytes url, uint256 index);\n  event PaymentDelegationSet(address indexed beneficiary, uint256 fraction);\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return Storage version of the contract.\n   * @return Major version of the contract.\n   * @return Minor version of the contract.\n   * @return Patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 4, 1);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setEip712DomainSeparator();\n  }\n\n  /**\n   * @notice Sets the EIP712 domain separator for the Celo Accounts abstraction.\n   */\n  function setEip712DomainSeparator() public {\n    uint256 chainId;\n    assembly {\n      chainId := chainid\n    }\n\n    eip712DomainSeparator = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(\"Celo Core Contracts\")),\n        keccak256(\"1.0\"),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),\n      \"Account already exists or address is an authorized signer for another account\"\n    );\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Register with createAccount to set account name\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Adds a new CIP8 storage root.\n   * @param url The URL pointing to the offchain storage root.\n   */\n  function addStorageRoot(bytes calldata url) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    offchainStorageRoots[msg.sender].push(url);\n    emit OffchainStorageRootAdded(msg.sender, url);\n  }\n\n  /**\n   * @notice Removes a CIP8 storage root.\n   * @param index The index of the storage root to be removed in the account's\n   * list of storage roots.\n   * @dev The order of storage roots may change after this operation (the last\n   * storage root will be moved to `index`), be aware of this if removing\n   * multiple storage roots at a time.\n   */\n  function removeStorageRoot(uint256 index) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(index < offchainStorageRoots[msg.sender].length, \"Invalid storage root index\");\n    uint256 lastIndex = offchainStorageRoots[msg.sender].length - 1;\n    bytes memory url = offchainStorageRoots[msg.sender][index];\n    offchainStorageRoots[msg.sender][index] = offchainStorageRoots[msg.sender][lastIndex];\n    offchainStorageRoots[msg.sender].length--;\n    emit OffchainStorageRootRemoved(msg.sender, url, index);\n  }\n\n  /**\n   * @notice Returns the full list of offchain storage roots for an account.\n   * @param account The account whose storage roots to return.\n   * @return Concatenated storage root URLs.\n   * @return Lengths of storage root URLs.\n   */\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n  /**\n   * @notice Sets validator payment delegation settings.\n   * @param beneficiary The address that should receive a portion of validator\n   * payments.\n   * @param fraction The fraction of the validator's payment that should be\n   * diverted to `beneficiary` every epoch, given as FixidityLib value. Must not\n   * be greater than 1.\n   * @dev Use `deletePaymentDelegation` to unset the payment delegation.\n   */\n  function setPaymentDelegation(address beneficiary, uint256 fraction) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(beneficiary != address(0), \"Beneficiary cannot be address 0x0\");\n    FixidityLib.Fraction memory f = FixidityLib.wrap(fraction);\n    require(f.lte(FixidityLib.fixed1()), \"Fraction must not be greater than 1\");\n    paymentDelegations[msg.sender] = PaymentDelegation(beneficiary, f);\n    emit PaymentDelegationSet(beneficiary, fraction);\n  }\n\n  /**\n   * @notice Removes a validator's payment delegation by setting benficiary and\n   * fraction to 0.\n   */\n  function deletePaymentDelegation() public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    paymentDelegations[msg.sender] = PaymentDelegation(address(0x0), FixidityLib.wrap(0));\n    emit PaymentDelegationSet(address(0x0), 0);\n  }\n\n  /**\n   * @notice Gets validator payment delegation settings.\n   * @param account Account of the validator.\n   * @return Beneficiary address of payment delegated.\n   * @return Fraction of payment delegated.\n   */\n  function getPaymentDelegation(address account) external view returns (address, uint256) {\n    PaymentDelegation storage delegation = paymentDelegations[account];\n    return (delegation.beneficiary, delegation.fraction.unwrap());\n  }\n\n  /**\n   * @notice Set the indexed signer for a specific role\n   * @param signer the address to set as default\n   * @param role the role to register a default signer for\n   */\n  function setIndexedSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(isNotAccount(signer), \"Cannot authorize account as signer\");\n    require(\n      isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Not a signer for this account\"\n    );\n    require(isSigner(msg.sender, signer, role), \"Must authorize signer before setting as default\");\n\n    Account storage account = accounts[msg.sender];\n    if (isLegacyRole(role)) {\n      if (role == VoteSigner) {\n        account.signers.vote = signer;\n      } else if (role == AttestationSigner) {\n        account.signers.attestation = signer;\n      } else if (role == ValidatorSigner) {\n        account.signers.validator = signer;\n      }\n      emit LegacySignerSet(msg.sender, signer, role);\n    } else {\n      defaultSigners[msg.sender][role] = signer;\n      emit DefaultSignerSet(msg.sender, signer, role);\n    }\n\n    emit IndexedSignerSet(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to act as a signer, for `role`, on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s EIP712 signature over `role`, `msg.sender`\n   *      and `signer`.\n   */\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  function legacyAuthorizeSignerWithSignature(\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) private {\n    authorizeAddress(signer, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Begin the process of authorizing an address to sign on behalf of the account\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   */\n  function authorizeSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register sender with Account.createAccount\");\n    require(\n      isNotAccount(signer) && isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Cannot re-authorize address signer\"\n    );\n\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: false\n    });\n    emit SignerAuthorizationStarted(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Finish the process of authorizing an address to sign on behalf of the account.\n   * @param account The address of account that authorized signing.\n   * @param role The role to finish authorizing for.\n   */\n  function completeSignerAuthorization(address account, bytes32 role) public {\n    require(\n      isAccount(account),\n      \"Unknown Account: Address that authorized signing must be a registered Account\"\n    );\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSignerForAnotherAccount(account, msg.sender),\n      \"Cannot re-authorize address signer\"\n    );\n    require(\n      signerAuthorizations[account][role][msg.sender].started == true,\n      \"Signer authorization not started\"\n    );\n\n    authorizedBy[msg.sender] = account;\n    signerAuthorizations[account][role][msg.sender].completed = true;\n    emit SignerAuthorizationCompleted(account, msg.sender, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the legacy signer for role\n   * @param _account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isLegacySigner(address _account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    Account storage account = accounts[_account];\n    if (role == ValidatorSigner && account.signers.validator == signer) {\n      return true;\n    } else if (role == AttestationSigner && account.signers.attestation == signer) {\n      return true;\n    } else if (role == VoteSigner && account.signers.vote == signer) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the default signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isDefaultSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return defaultSigners[account][role] == signer;\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as an indexed signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isIndexedSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return\n      isLegacyRole(role)\n        ? isLegacySigner(account, signer, role)\n        : isDefaultSigner(account, signer, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as a signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isSigner(address account, address signer, bytes32 role) public view returns (bool) {\n    return\n      isLegacySigner(account, signer, role) ||\n      (signerAuthorizations[account][role][signer].completed && authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Removes the signer for a default role.\n   * @param role The role that has been authorized.\n   */\n  function removeDefaultSigner(bytes32 role) public {\n    address signer = defaultSigners[msg.sender][role];\n    defaultSigners[msg.sender][role] = address(0);\n    emit DefaultSignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Remove one of the Validator, Attestation or\n   * Vote signers from an account. Should only be called from\n   * methods that check the role is a legacy signer.\n   * @param role The role that has been authorized.\n   */\n  function removeLegacySigner(bytes32 role) private {\n    Account storage account = accounts[msg.sender];\n\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n      account.signers.validator = address(0);\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n      account.signers.attestation = address(0);\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n      account.signers.vote = address(0);\n    }\n    emit LegacySignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized and indexed signer\n   * for a specific role\n   * @param role The role of the signer.\n   */\n  function removeIndexedSigner(bytes32 role) public {\n    address oldSigner = getIndexedSigner(msg.sender, role);\n    isLegacyRole(role) ? removeLegacySigner(role) : removeDefaultSigner(role);\n\n    emit IndexedSignerRemoved(msg.sender, oldSigner, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized signer for a specific role and\n   * if the signer is indexed, remove that as well.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function removeSigner(address signer, bytes32 role) public {\n    if (isIndexedSigner(msg.sender, signer, role)) {\n      removeIndexedSigner(role);\n    }\n\n    delete signerAuthorizations[msg.sender][role][signer];\n    emit SignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized vote signer for the account.\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeVoteSigner() public {\n    address signer = getLegacySigner(msg.sender, VoteSigner);\n    removeSigner(signer, VoteSigner);\n    emit VoteSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized validator signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeValidatorSigner() public {\n    address signer = getLegacySigner(msg.sender, ValidatorSigner);\n    removeSigner(signer, ValidatorSigner);\n    emit ValidatorSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized attestation signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeAttestationSigner() public {\n    address signer = getLegacySigner(msg.sender, AttestationSigner);\n    removeSigner(signer, AttestationSigner);\n    emit AttestationSignerRemoved(msg.sender, signer);\n  }\n\n  function signerToAccountWithRole(address signer, bytes32 role) internal view returns (address) {\n    address account = authorizedBy[signer];\n    if (account != address(0)) {\n      require(isSigner(account, signer, role), \"not active authorized signer for role\");\n      return account;\n    }\n\n    require(isAccount(signer), \"Must first register address with Account.createAccount\");\n    return signer;\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account that the signer is authorized to attest for.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account that signer is authorized to validate for.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account that signer is authorized to vote for.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Checks whether the role is one of Vote, Validator or Attestation\n   * @param role The role to check\n   */\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n\n  /**\n   * @notice Returns the legacy signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param _account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n  /**\n   * @notice Returns the default signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n  /**\n   * @notice Returns the indexed signer for the specified account and role.\n   * If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for one of the legacy roles\n   */\n  function hasLegacySigner(address account, bytes32 role) public view returns (bool) {\n    return getLegacySigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for a role\n   */\n  function hasDefaultSigner(address account, bytes32 role) public view returns (bool) {\n    return getDefaultSigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for the role\n   */\n  function hasIndexedSigner(address account, bytes32 role) public view returns (bool) {\n    return isLegacyRole(role) ? hasLegacySigner(account, role) : hasDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Checks whether or not the account has a signer\n   * registered for the plaintext role.\n   * @dev See `hasIndexedSigner` for more gas efficient call.\n   */\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated vote signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated vote signer.\n   */\n  function hasAuthorizedVoteSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated validator signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated validator signer.\n   */\n  function hasAuthorizedValidatorSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated attestation signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated attestation signer.\n   */\n  function hasAuthorizedAttestationSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return The length of each string in bytes.\n   * @return All strings concatenated.\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has not been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Check if `signer` has not been authorized, and if it has been previously\n   *         authorized that it was authorized by `account`.\n   * @param account The authorizing account address.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSignerForAnotherAccount(address account, address signer)\n    internal\n    view\n    returns (bool)\n  {\n    return (authorizedBy[signer] == address(0) || authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Authorizes some role of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `authorized`'s signature on `msg.sender`.\n   */\n  function authorizeAddress(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Returns the address that signed the provided role authorization.\n   * @param account The `account` property signed over in the EIP712 signature\n   * @param signer The `signer` property signed over in the EIP712 signature\n   * @param role The `role` property signed over in the EIP712 signature\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The address that signed the provided role authorization.\n   */\n  function getRoleAuthorizationSigner(\n    address account,\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 structHash = keccak256(\n      abi.encode(EIP712_AUTHORIZE_SIGNER_TYPEHASH, account, signer, role)\n    );\n    return Signatures.getSignerOfTypedDataHash(eip712DomainSeparator, structHash, v, r, s);\n  }\n\n  /**\n   * @notice Authorizes a role of `msg.sender`'s account to another address (`authorized`).\n   * @param authorized The address to authorize.\n   * @param role The role to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that this signature is EIP712 compliant over the authorizing `account`\n   * (`msg.sender`), `signer` (`authorized`) and `role`.\n   */\n  function authorizeAddressWithRole(address authorized, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    private\n  {\n    address signer = getRoleAuthorizationSigner(msg.sender, authorized, role, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Authorizes an address to `msg.sender`'s account\n   * @param authorized The address to authorize.\n   * @dev Fails if the address is already authorized for another account or is an account itself.\n   */\n  function authorize(address authorized) private {\n    require(\n      isAccount(msg.sender),\n      \"Unknown account: sender must register with createAccount first\"\n    );\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSignerForAnotherAccount(msg.sender, authorized),\n      \"Cannot re-authorize address or locked gold account for another account\"\n    );\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "getVersionNumber",
                "initialize",
                "setEip712DomainSeparator",
                "setAccount",
                "createAccount",
                "setName",
                "setWalletAddress",
                "setAccountDataEncryptionKey",
                "setMetadataURL",
                "addStorageRoot",
                "removeStorageRoot",
                "getOffchainStorageRoots",
                "setPaymentDelegation",
                "deletePaymentDelegation",
                "getPaymentDelegation",
                "setIndexedSigner",
                "authorizeSignerWithSignature",
                "legacyAuthorizeSignerWithSignature",
                "authorizeVoteSigner",
                "authorizeValidatorSigner",
                "authorizeValidatorSignerWithPublicKey",
                "authorizeValidatorSignerWithKeys",
                "authorizeAttestationSigner",
                "authorizeSigner",
                "completeSignerAuthorization",
                "isLegacySigner",
                "isDefaultSigner",
                "isIndexedSigner",
                "isSigner",
                "removeDefaultSigner",
                "removeLegacySigner",
                "removeIndexedSigner",
                "removeSigner",
                "removeVoteSigner",
                "removeValidatorSigner",
                "removeAttestationSigner",
                "signerToAccountWithRole",
                "attestationSignerToAccount",
                "validatorSignerToAccount",
                "voteSignerToAccount",
                "signerToAccount",
                "isLegacyRole",
                "getLegacySigner",
                "getDefaultSigner",
                "getIndexedSigner",
                "getVoteSigner",
                "getValidatorSigner",
                "getAttestationSigner",
                "hasLegacySigner",
                "hasDefaultSigner",
                "hasIndexedSigner",
                "hasAuthorizedSigner",
                "hasAuthorizedVoteSigner",
                "hasAuthorizedValidatorSigner",
                "hasAuthorizedAttestationSigner",
                "getName",
                "getMetadataURL",
                "batchGetMetadataURL",
                "getDataEncryptionKey",
                "getWalletAddress",
                "isAccount",
                "isNotAccount",
                "isAuthorizedSigner",
                "isNotAuthorizedSigner",
                "isNotAuthorizedSignerForAnotherAccount",
                "authorizeAddress",
                "getRoleAuthorizationSigner",
                "authorizeAddressWithRole",
                "authorize"
            ],
            "state_variables": [
                "metadataURL",
                "offchainStorageRoots",
                "beneficiary",
                "authorizedBy",
                "completed",
                "attestation",
                "name",
                "walletAddress",
                "dataEncryptionKey",
                "vote",
                "exists",
                "chainId",
                "eip712DomainSeparator",
                "accounts",
                "validator",
                "paymentDelegations",
                "signer",
                "started"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "Accounts_account_empty_if_not_exist_e007ab3e",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Accounts.sol",
        "target_function": "getAttestationSigner/getDefaultSigner/getValidatorSigner/getVoteSigner/getWalletAddress/isAccount",
        "text_chunk": "  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n",
        "formal_property": "invariant account_empty_if_not_exist(env e, address x) \n  !isAccount(x) => \n    getWalletAddress(x) == 0 &&\n    _getAttestationSigner(x) == 0 &&\n    _getVoteSigner(x) == 0 &&\n    _getValidatorSigner(x) == 0\n\n/**\n * An address d that is authorized by some account x can not become an account\n */\ninvariant address_cant_be_both_account_and_signer(address x, address d) \n  (x != 0 && d != 0 && x != d && _getAuthorizedBy(d) == x) => \n    (isAccount(x) && !isAccount(d))\n * A current signer d or account x should be authorizedby for legacy roles\ninvariant address_signer_if_authorizedby_legacy(address x, address d) \n  (x != d && x != 0 && d != 0 &&\n  \t(_getAttestationSigner(x) == d || _getVoteSigner(x) == d || _getValidatorSigner(x) == d))\n    \t=> (isAccount(x) && _getAuthorizedBy(d) == x)\n * A current signer d or account x should be authorizedby for new roles\ninvariant address_signer_if_authroizedby_new(address x, address d, bytes32 role)\n\t(x != d && x != 0 && d != 0 &&\n\t\t_getDefaultSigner(x,role) == d)\n\t\t\t=> (isAccount(x) && _getAuthorizedBy(d) == x)\n * Given account x, address d a current signer, then d can not be a current signer of account y\n * (Expensive rule)\n /*\nrule address_cant_be_both_authorizedby_of_two_address(address x, address y, address d, bytes32 r1, bytes32 r2, method f) filtered { f -> !f.isView } { \n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "account_empty_if_not_exist",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "isAccount",
                "_getAuthorizedBy",
                "getWalletAddress",
                "getAttestationSigner",
                "_getAttestationSigner",
                "getVoteSigner",
                "_getVoteSigner",
                "getValidatorSigner",
                "_getValidatorSigner",
                "getDefaultSigner",
                "_getDefaultSigner"
            ],
            "start_line": 35,
            "end_line": 72,
            "block_hash": "e007ab3e7d7d7a0118948426e3af8acf"
        }
    },
    {
        "id": "Accounts_legacyRolesAreNotUsedInNewRoles_38e6f3a0",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Accounts.sol",
        "target_function": "batchGetMetadataURL/getDefaultSigner/getMetadataURL/getOffchainStorageRoots/hasAuthorizedSigner/isLegacyRole",
        "text_chunk": "  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n\n\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n",
        "formal_property": "invariant legacyRolesAreNotUsedInNewRoles(address account, bytes32 role) \n\tisLegacyRole(role) => _getDefaultSigner(account, role) == 0\n\n/**\n * view functions in general should not revert.\n * Some exceptions and more refined revert-characteristics are provided.\n */\nrule viewFunctionsDoNotRevert(method f) filtered { f -> \n\tf.isView \n\t// some functions we ignore, and the reasons:\n\t&& f.selector != hasAuthorizedSigner(address,string).selector // Calldatasize may not match\n\t&& f.selector != batchGetMetadataURL(address[]).selector // Calldatasize may not match\n  // These require an account to exist\n\t&& f.selector != getOffchainStorageRoots(address).selector\n\t&& f.selector != offchainStorageRoots(address,uint256).selector\n} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "legacyRolesAreNotUsedInNewRoles",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "getDefaultSigner",
                "_getDefaultSigner",
                "isLegacyRole"
            ],
            "start_line": 196,
            "end_line": 212,
            "block_hash": "38e6f3a01013b0cca9b780f3973b31ee"
        }
    },
    {
        "id": "Accounts_authorizedByIsNeverReflexive_5b37fffa",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Accounts.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is\n  IAccounts,\n  ICeloVersionedContract,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct SignerAuthorization {\n    bool started;\n    bool completed;\n  }\n\n  struct Account {\n    bool exists;\n    // [Deprecated] Each account may authorize signing keys to use for voting,\n    // validating or attestation. These keys may not be keys of other accounts,\n    // and may not be authorized by any other account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  struct PaymentDelegation {\n    // Address that should receive a fraction of validator payments.\n    address beneficiary;\n    // Fraction of payment to delegate to `beneficiary`.\n    FixidityLib.Fraction fraction;\n  }\n\n  mapping(address => Account) internal accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n  // Default signers by account (replaces the legacy Signers struct on Account)\n  mapping(address => mapping(bytes32 => address)) defaultSigners;\n  // All signers and their roles for a given account\n  // solhint-disable-next-line max-line-length\n  mapping(address => mapping(bytes32 => mapping(address => SignerAuthorization))) signerAuthorizations;\n\n  bytes32 public constant EIP712_AUTHORIZE_SIGNER_TYPEHASH = keccak256(\n    \"AuthorizeSigner(address account,address signer,bytes32 role)\"\n  );\n  bytes32 public eip712DomainSeparator;\n\n  // A per-account list of CIP8 storage roots, bypassing CIP3.\n  mapping(address => bytes[]) public offchainStorageRoots;\n\n  // Optional per-account validator payment delegation information.\n  mapping(address => PaymentDelegation) internal paymentDelegations;\n\n  bytes32 constant ValidatorSigner = keccak256(abi.encodePacked(\"celo.org/core/validator\"));\n  bytes32 constant AttestationSigner = keccak256(abi.encodePacked(\"celo.org/core/attestation\"));\n  bytes32 constant VoteSigner = keccak256(abi.encodePacked(\"celo.org/core/vote\"));\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event SignerAuthorized(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationStarted(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationCompleted(address indexed account, address signer, bytes32 indexed role);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event IndexedSignerSet(address indexed account, address signer, bytes32 role);\n  event IndexedSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event DefaultSignerSet(address indexed account, address signer, bytes32 role);\n  event DefaultSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event LegacySignerSet(address indexed account, address signer, bytes32 role);\n  event LegacySignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event SignerRemoved(address indexed account, address oldSigner, bytes32 indexed role);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n  event OffchainStorageRootAdded(address indexed account, bytes url);\n  event OffchainStorageRootRemoved(address indexed account, bytes url, uint256 index);\n  event PaymentDelegationSet(address indexed beneficiary, uint256 fraction);\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return Storage version of the contract.\n   * @return Major version of the contract.\n   * @return Minor version of the contract.\n   * @return Patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 4, 1);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setEip712DomainSeparator();\n  }\n\n  /**\n   * @notice Sets the EIP712 domain separator for the Celo Accounts abstraction.\n   */\n  function setEip712DomainSeparator() public {\n    uint256 chainId;\n    assembly {\n      chainId := chainid\n    }\n\n    eip712DomainSeparator = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(\"Celo Core Contracts\")),\n        keccak256(\"1.0\"),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),\n      \"Account already exists or address is an authorized signer for another account\"\n    );\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Register with createAccount to set account name\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Adds a new CIP8 storage root.\n   * @param url The URL pointing to the offchain storage root.\n   */\n  function addStorageRoot(bytes calldata url) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    offchainStorageRoots[msg.sender].push(url);\n    emit OffchainStorageRootAdded(msg.sender, url);\n  }\n\n  /**\n   * @notice Removes a CIP8 storage root.\n   * @param index The index of the storage root to be removed in the account's\n   * list of storage roots.\n   * @dev The order of storage roots may change after this operation (the last\n   * storage root will be moved to `index`), be aware of this if removing\n   * multiple storage roots at a time.\n   */\n  function removeStorageRoot(uint256 index) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(index < offchainStorageRoots[msg.sender].length, \"Invalid storage root index\");\n    uint256 lastIndex = offchainStorageRoots[msg.sender].length - 1;\n    bytes memory url = offchainStorageRoots[msg.sender][index];\n    offchainStorageRoots[msg.sender][index] = offchainStorageRoots[msg.sender][lastIndex];\n    offchainStorageRoots[msg.sender].length--;\n    emit OffchainStorageRootRemoved(msg.sender, url, index);\n  }\n\n  /**\n   * @notice Returns the full list of offchain storage roots for an account.\n   * @param account The account whose storage roots to return.\n   * @return Concatenated storage root URLs.\n   * @return Lengths of storage root URLs.\n   */\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n  /**\n   * @notice Sets validator payment delegation settings.\n   * @param beneficiary The address that should receive a portion of validator\n   * payments.\n   * @param fraction The fraction of the validator's payment that should be\n   * diverted to `beneficiary` every epoch, given as FixidityLib value. Must not\n   * be greater than 1.\n   * @dev Use `deletePaymentDelegation` to unset the payment delegation.\n   */\n  function setPaymentDelegation(address beneficiary, uint256 fraction) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(beneficiary != address(0), \"Beneficiary cannot be address 0x0\");\n    FixidityLib.Fraction memory f = FixidityLib.wrap(fraction);\n    require(f.lte(FixidityLib.fixed1()), \"Fraction must not be greater than 1\");\n    paymentDelegations[msg.sender] = PaymentDelegation(beneficiary, f);\n    emit PaymentDelegationSet(beneficiary, fraction);\n  }\n\n  /**\n   * @notice Removes a validator's payment delegation by setting benficiary and\n   * fraction to 0.\n   */\n  function deletePaymentDelegation() public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    paymentDelegations[msg.sender] = PaymentDelegation(address(0x0), FixidityLib.wrap(0));\n    emit PaymentDelegationSet(address(0x0), 0);\n  }\n\n  /**\n   * @notice Gets validator payment delegation settings.\n   * @param account Account of the validator.\n   * @return Beneficiary address of payment delegated.\n   * @return Fraction of payment delegated.\n   */\n  function getPaymentDelegation(address account) external view returns (address, uint256) {\n    PaymentDelegation storage delegation = paymentDelegations[account];\n    return (delegation.beneficiary, delegation.fraction.unwrap());\n  }\n\n  /**\n   * @notice Set the indexed signer for a specific role\n   * @param signer the address to set as default\n   * @param role the role to register a default signer for\n   */\n  function setIndexedSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(isNotAccount(signer), \"Cannot authorize account as signer\");\n    require(\n      isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Not a signer for this account\"\n    );\n    require(isSigner(msg.sender, signer, role), \"Must authorize signer before setting as default\");\n\n    Account storage account = accounts[msg.sender];\n    if (isLegacyRole(role)) {\n      if (role == VoteSigner) {\n        account.signers.vote = signer;\n      } else if (role == AttestationSigner) {\n        account.signers.attestation = signer;\n      } else if (role == ValidatorSigner) {\n        account.signers.validator = signer;\n      }\n      emit LegacySignerSet(msg.sender, signer, role);\n    } else {\n      defaultSigners[msg.sender][role] = signer;\n      emit DefaultSignerSet(msg.sender, signer, role);\n    }\n\n    emit IndexedSignerSet(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to act as a signer, for `role`, on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s EIP712 signature over `role`, `msg.sender`\n   *      and `signer`.\n   */\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  function legacyAuthorizeSignerWithSignature(\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) private {\n    authorizeAddress(signer, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Begin the process of authorizing an address to sign on behalf of the account\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   */\n  function authorizeSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register sender with Account.createAccount\");\n    require(\n      isNotAccount(signer) && isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Cannot re-authorize address signer\"\n    );\n\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: false\n    });\n    emit SignerAuthorizationStarted(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Finish the process of authorizing an address to sign on behalf of the account.\n   * @param account The address of account that authorized signing.\n   * @param role The role to finish authorizing for.\n   */\n  function completeSignerAuthorization(address account, bytes32 role) public {\n    require(\n      isAccount(account),\n      \"Unknown Account: Address that authorized signing must be a registered Account\"\n    );\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSignerForAnotherAccount(account, msg.sender),\n      \"Cannot re-authorize address signer\"\n    );\n    require(\n      signerAuthorizations[account][role][msg.sender].started == true,\n      \"Signer authorization not started\"\n    );\n\n    authorizedBy[msg.sender] = account;\n    signerAuthorizations[account][role][msg.sender].completed = true;\n    emit SignerAuthorizationCompleted(account, msg.sender, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the legacy signer for role\n   * @param _account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isLegacySigner(address _account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    Account storage account = accounts[_account];\n    if (role == ValidatorSigner && account.signers.validator == signer) {\n      return true;\n    } else if (role == AttestationSigner && account.signers.attestation == signer) {\n      return true;\n    } else if (role == VoteSigner && account.signers.vote == signer) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the default signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isDefaultSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return defaultSigners[account][role] == signer;\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as an indexed signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isIndexedSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return\n      isLegacyRole(role)\n        ? isLegacySigner(account, signer, role)\n        : isDefaultSigner(account, signer, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as a signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isSigner(address account, address signer, bytes32 role) public view returns (bool) {\n    return\n      isLegacySigner(account, signer, role) ||\n      (signerAuthorizations[account][role][signer].completed && authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Removes the signer for a default role.\n   * @param role The role that has been authorized.\n   */\n  function removeDefaultSigner(bytes32 role) public {\n    address signer = defaultSigners[msg.sender][role];\n    defaultSigners[msg.sender][role] = address(0);\n    emit DefaultSignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Remove one of the Validator, Attestation or\n   * Vote signers from an account. Should only be called from\n   * methods that check the role is a legacy signer.\n   * @param role The role that has been authorized.\n   */\n  function removeLegacySigner(bytes32 role) private {\n    Account storage account = accounts[msg.sender];\n\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n      account.signers.validator = address(0);\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n      account.signers.attestation = address(0);\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n      account.signers.vote = address(0);\n    }\n    emit LegacySignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized and indexed signer\n   * for a specific role\n   * @param role The role of the signer.\n   */\n  function removeIndexedSigner(bytes32 role) public {\n    address oldSigner = getIndexedSigner(msg.sender, role);\n    isLegacyRole(role) ? removeLegacySigner(role) : removeDefaultSigner(role);\n\n    emit IndexedSignerRemoved(msg.sender, oldSigner, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized signer for a specific role and\n   * if the signer is indexed, remove that as well.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function removeSigner(address signer, bytes32 role) public {\n    if (isIndexedSigner(msg.sender, signer, role)) {\n      removeIndexedSigner(role);\n    }\n\n    delete signerAuthorizations[msg.sender][role][signer];\n    emit SignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized vote signer for the account.\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeVoteSigner() public {\n    address signer = getLegacySigner(msg.sender, VoteSigner);\n    removeSigner(signer, VoteSigner);\n    emit VoteSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized validator signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeValidatorSigner() public {\n    address signer = getLegacySigner(msg.sender, ValidatorSigner);\n    removeSigner(signer, ValidatorSigner);\n    emit ValidatorSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized attestation signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeAttestationSigner() public {\n    address signer = getLegacySigner(msg.sender, AttestationSigner);\n    removeSigner(signer, AttestationSigner);\n    emit AttestationSignerRemoved(msg.sender, signer);\n  }\n\n  function signerToAccountWithRole(address signer, bytes32 role) internal view returns (address) {\n    address account = authorizedBy[signer];\n    if (account != address(0)) {\n      require(isSigner(account, signer, role), \"not active authorized signer for role\");\n      return account;\n    }\n\n    require(isAccount(signer), \"Must first register address with Account.createAccount\");\n    return signer;\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account that the signer is authorized to attest for.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account that signer is authorized to validate for.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account that signer is authorized to vote for.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Checks whether the role is one of Vote, Validator or Attestation\n   * @param role The role to check\n   */\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n\n  /**\n   * @notice Returns the legacy signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param _account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n  /**\n   * @notice Returns the default signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n  /**\n   * @notice Returns the indexed signer for the specified account and role.\n   * If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for one of the legacy roles\n   */\n  function hasLegacySigner(address account, bytes32 role) public view returns (bool) {\n    return getLegacySigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for a role\n   */\n  function hasDefaultSigner(address account, bytes32 role) public view returns (bool) {\n    return getDefaultSigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for the role\n   */\n  function hasIndexedSigner(address account, bytes32 role) public view returns (bool) {\n    return isLegacyRole(role) ? hasLegacySigner(account, role) : hasDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Checks whether or not the account has a signer\n   * registered for the plaintext role.\n   * @dev See `hasIndexedSigner` for more gas efficient call.\n   */\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated vote signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated vote signer.\n   */\n  function hasAuthorizedVoteSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated validator signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated validator signer.\n   */\n  function hasAuthorizedValidatorSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated attestation signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated attestation signer.\n   */\n  function hasAuthorizedAttestationSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return The length of each string in bytes.\n   * @return All strings concatenated.\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has not been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Check if `signer` has not been authorized, and if it has been previously\n   *         authorized that it was authorized by `account`.\n   * @param account The authorizing account address.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSignerForAnotherAccount(address account, address signer)\n    internal\n    view\n    returns (bool)\n  {\n    return (authorizedBy[signer] == address(0) || authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Authorizes some role of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `authorized`'s signature on `msg.sender`.\n   */\n  function authorizeAddress(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Returns the address that signed the provided role authorization.\n   * @param account The `account` property signed over in the EIP712 signature\n   * @param signer The `signer` property signed over in the EIP712 signature\n   * @param role The `role` property signed over in the EIP712 signature\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The address that signed the provided role authorization.\n   */\n  function getRoleAuthorizationSigner(\n    address account,\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 structHash = keccak256(\n      abi.encode(EIP712_AUTHORIZE_SIGNER_TYPEHASH, account, signer, role)\n    );\n    return Signatures.getSignerOfTypedDataHash(eip712DomainSeparator, structHash, v, r, s);\n  }\n\n  /**\n   * @notice Authorizes a role of `msg.sender`'s account to another address (`authorized`).\n   * @param authorized The address to authorize.\n   * @param role The role to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that this signature is EIP712 compliant over the authorizing `account`\n   * (`msg.sender`), `signer` (`authorized`) and `role`.\n   */\n  function authorizeAddressWithRole(address authorized, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    private\n  {\n    address signer = getRoleAuthorizationSigner(msg.sender, authorized, role, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Authorizes an address to `msg.sender`'s account\n   * @param authorized The address to authorize.\n   * @dev Fails if the address is already authorized for another account or is an account itself.\n   */\n  function authorize(address authorized) private {\n    require(\n      isAccount(msg.sender),\n      \"Unknown account: sender must register with createAccount first\"\n    );\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSignerForAnotherAccount(msg.sender, authorized),\n      \"Cannot re-authorize address or locked gold account for another account\"\n    );\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}\n",
        "formal_property": "invariant authorizedByIsNeverReflexive(address a)\n\ta != 0 => _getAuthorizedBy(a) != a\n\n/**\n * If we set signerAuthroization to be completed, it means the signer is marked as authorizedBy the account.\n * The other direction may not be correct because authorizedBy is persistent while signer authorizations can be removed. \n */\ninvariant mustHaveAuthorizedByIfCompletedSignerAuthorization(address account, bytes32 role, address signer) \n\taccount != 0 => (isCompletedSignerAuthorization(account, role, signer) => _getAuthorizedBy(signer) == account)\n * For signerAuthorization, a signer can only appear as a signer of a single account.\ninvariant noMultipleAccountsPerSignerInARole(address account, address account2, bytes32 role, bytes32 role2, address signer)\n\taccount != 0 && account2 != 0\n\t\t=> (isCompletedSignerAuthorization(account, role, signer) && isCompletedSignerAuthorization(account2, role2, signer) \n\t\t\t=> account == account2) {\n\t\n\tpreserved {\n\t\trequireInvariant mustHaveAuthorizedByIfCompletedSignerAuthorization(account, role, signer);\n\t\trequireInvariant mustHaveAuthorizedByIfCompletedSignerAuthorization(account2, role2, signer);\n\t}\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "authorizedByIsNeverReflexive",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "_getAuthorizedBy",
                "isCompletedSignerAuthorization"
            ],
            "start_line": 263,
            "end_line": 285,
            "block_hash": "5b37fffa2117e0f95df799da60c427b0"
        }
    },
    {
        "id": "Accounts_accountToSignerAndInverseVote_aef3833f",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Accounts.sol",
        "target_function": "getVoteSigner/signerToAccount/voteSignerToAccount",
        "text_chunk": "  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n",
        "formal_property": "invariant accountToSignerAndInverseVote(address a, address s, bytes32 r)\n\tr == _getVoteRole() => (s == getVoteSigner(a) => voteSignerToAccount(s) == a)\n{\n\t\tpreserved {\n\t\t\trequire a != s;\n\t\t}\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "accountToSignerAndInverseVote",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "getVoteSigner",
                "voteSignerToAccount",
                "_getVoteRole"
            ],
            "start_line": 436,
            "end_line": 442,
            "block_hash": "aef3833fe58239c376185c06674cb25d"
        }
    },
    {
        "id": "Accounts_accountToSignerAndInverseValidator_77280ded",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Accounts.sol",
        "target_function": "getValidatorSigner/signerToAccount/validatorSignerToAccount",
        "text_chunk": "  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n",
        "formal_property": "invariant accountToSignerAndInverseValidator(address a, address s, bytes32 r)\t\n\tr == _getValidatorRole() => (s == getValidatorSigner(a) => validatorSignerToAccount(s) == a)\n{\n\t\tpreserved {\n\t\t\trequire a != s;\n\t\t}\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "accountToSignerAndInverseValidator",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "getValidatorSigner",
                "validatorSignerToAccount",
                "_getValidatorRole"
            ],
            "start_line": 444,
            "end_line": 450,
            "block_hash": "77280ded36b0b794efe9d6206edf7a6d"
        }
    },
    {
        "id": "Accounts_accountToSignerAndInverseAttestation_70acb189",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Accounts.sol",
        "target_function": "attestationSignerToAccount/getAttestationSigner/signerToAccount",
        "text_chunk": "  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n\n  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n",
        "formal_property": "invariant accountToSignerAndInverseAttestation(address a, address s, bytes32 r)\n\tr == _getAttestationRole() => (s == getAttestationSigner(a) => attestationSignerToAccount(s) == a)\n{\n\t\tpreserved {\n\t\t\trequire a != s;\n\t\t}\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "accountToSignerAndInverseAttestation",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "getAttestationSigner",
                "attestationSignerToAccount",
                "_getAttestationRole"
            ],
            "start_line": 452,
            "end_line": 458,
            "block_hash": "70acb189ead786e3f9b86f085c0f3e30"
        }
    },
    {
        "id": "Accounts_accountToSignerAndInverseNewRoles_fa950e98",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Accounts.sol",
        "target_function": "getIndexedSigner/signerToAccount",
        "text_chunk": "  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n",
        "formal_property": "invariant accountToSignerAndInverseNewRoles(address a, address s, bytes32 r)\t\n\tgetIndexedSigner(a, r) == s => signerToAccount(s) == a \n{\n\t\tpreserved {\n\t\t\trequire a != s;\n\t\t}\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "accountToSignerAndInverseNewRoles",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "signerToAccount",
                "getIndexedSigner"
            ],
            "start_line": 460,
            "end_line": 466,
            "block_hash": "fa950e98d9da74f07868f37a06e5d24f"
        }
    },
    {
        "id": "Accounts_address_cant_be_both_authorizedby_of_two_address_e904b23b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is\n  IAccounts,\n  ICeloVersionedContract,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct SignerAuthorization {\n    bool started;\n    bool completed;\n  }\n\n  struct Account {\n    bool exists;\n    // [Deprecated] Each account may authorize signing keys to use for voting,\n    // validating or attestation. These keys may not be keys of other accounts,\n    // and may not be authorized by any other account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  struct PaymentDelegation {\n    // Address that should receive a fraction of validator payments.\n    address beneficiary;\n    // Fraction of payment to delegate to `beneficiary`.\n    FixidityLib.Fraction fraction;\n  }\n\n  mapping(address => Account) internal accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n  // Default signers by account (replaces the legacy Signers struct on Account)\n  mapping(address => mapping(bytes32 => address)) defaultSigners;\n  // All signers and their roles for a given account\n  // solhint-disable-next-line max-line-length\n  mapping(address => mapping(bytes32 => mapping(address => SignerAuthorization))) signerAuthorizations;\n\n  bytes32 public constant EIP712_AUTHORIZE_SIGNER_TYPEHASH = keccak256(\n    \"AuthorizeSigner(address account,address signer,bytes32 role)\"\n  );\n  bytes32 public eip712DomainSeparator;\n\n  // A per-account list of CIP8 storage roots, bypassing CIP3.\n  mapping(address => bytes[]) public offchainStorageRoots;\n\n  // Optional per-account validator payment delegation information.\n  mapping(address => PaymentDelegation) internal paymentDelegations;\n\n  bytes32 constant ValidatorSigner = keccak256(abi.encodePacked(\"celo.org/core/validator\"));\n  bytes32 constant AttestationSigner = keccak256(abi.encodePacked(\"celo.org/core/attestation\"));\n  bytes32 constant VoteSigner = keccak256(abi.encodePacked(\"celo.org/core/vote\"));\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event SignerAuthorized(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationStarted(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationCompleted(address indexed account, address signer, bytes32 indexed role);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event IndexedSignerSet(address indexed account, address signer, bytes32 role);\n  event IndexedSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event DefaultSignerSet(address indexed account, address signer, bytes32 role);\n  event DefaultSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event LegacySignerSet(address indexed account, address signer, bytes32 role);\n  event LegacySignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event SignerRemoved(address indexed account, address oldSigner, bytes32 indexed role);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n  event OffchainStorageRootAdded(address indexed account, bytes url);\n  event OffchainStorageRootRemoved(address indexed account, bytes url, uint256 index);\n  event PaymentDelegationSet(address indexed beneficiary, uint256 fraction);\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return Storage version of the contract.\n   * @return Major version of the contract.\n   * @return Minor version of the contract.\n   * @return Patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 4, 1);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setEip712DomainSeparator();\n  }\n\n  /**\n   * @notice Sets the EIP712 domain separator for the Celo Accounts abstraction.\n   */\n  function setEip712DomainSeparator() public {\n    uint256 chainId;\n    assembly {\n      chainId := chainid\n    }\n\n    eip712DomainSeparator = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(\"Celo Core Contracts\")),\n        keccak256(\"1.0\"),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),\n      \"Account already exists or address is an authorized signer for another account\"\n    );\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Register with createAccount to set account name\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Adds a new CIP8 storage root.\n   * @param url The URL pointing to the offchain storage root.\n   */\n  function addStorageRoot(bytes calldata url) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    offchainStorageRoots[msg.sender].push(url);\n    emit OffchainStorageRootAdded(msg.sender, url);\n  }\n\n  /**\n   * @notice Removes a CIP8 storage root.\n   * @param index The index of the storage root to be removed in the account's\n   * list of storage roots.\n   * @dev The order of storage roots may change after this operation (the last\n   * storage root will be moved to `index`), be aware of this if removing\n   * multiple storage roots at a time.\n   */\n  function removeStorageRoot(uint256 index) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(index < offchainStorageRoots[msg.sender].length, \"Invalid storage root index\");\n    uint256 lastIndex = offchainStorageRoots[msg.sender].length - 1;\n    bytes memory url = offchainStorageRoots[msg.sender][index];\n    offchainStorageRoots[msg.sender][index] = offchainStorageRoots[msg.sender][lastIndex];\n    offchainStorageRoots[msg.sender].length--;\n    emit OffchainStorageRootRemoved(msg.sender, url, index);\n  }\n\n  /**\n   * @notice Returns the full list of offchain storage roots for an account.\n   * @param account The account whose storage roots to return.\n   * @return Concatenated storage root URLs.\n   * @return Lengths of storage root URLs.\n   */\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n  /**\n   * @notice Sets validator payment delegation settings.\n   * @param beneficiary The address that should receive a portion of validator\n   * payments.\n   * @param fraction The fraction of the validator's payment that should be\n   * diverted to `beneficiary` every epoch, given as FixidityLib value. Must not\n   * be greater than 1.\n   * @dev Use `deletePaymentDelegation` to unset the payment delegation.\n   */\n  function setPaymentDelegation(address beneficiary, uint256 fraction) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(beneficiary != address(0), \"Beneficiary cannot be address 0x0\");\n    FixidityLib.Fraction memory f = FixidityLib.wrap(fraction);\n    require(f.lte(FixidityLib.fixed1()), \"Fraction must not be greater than 1\");\n    paymentDelegations[msg.sender] = PaymentDelegation(beneficiary, f);\n    emit PaymentDelegationSet(beneficiary, fraction);\n  }\n\n  /**\n   * @notice Removes a validator's payment delegation by setting benficiary and\n   * fraction to 0.\n   */\n  function deletePaymentDelegation() public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    paymentDelegations[msg.sender] = PaymentDelegation(address(0x0), FixidityLib.wrap(0));\n    emit PaymentDelegationSet(address(0x0), 0);\n  }\n\n  /**\n   * @notice Gets validator payment delegation settings.\n   * @param account Account of the validator.\n   * @return Beneficiary address of payment delegated.\n   * @return Fraction of payment delegated.\n   */\n  function getPaymentDelegation(address account) external view returns (address, uint256) {\n    PaymentDelegation storage delegation = paymentDelegations[account];\n    return (delegation.beneficiary, delegation.fraction.unwrap());\n  }\n\n  /**\n   * @notice Set the indexed signer for a specific role\n   * @param signer the address to set as default\n   * @param role the role to register a default signer for\n   */\n  function setIndexedSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(isNotAccount(signer), \"Cannot authorize account as signer\");\n    require(\n      isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Not a signer for this account\"\n    );\n    require(isSigner(msg.sender, signer, role), \"Must authorize signer before setting as default\");\n\n    Account storage account = accounts[msg.sender];\n    if (isLegacyRole(role)) {\n      if (role == VoteSigner) {\n        account.signers.vote = signer;\n      } else if (role == AttestationSigner) {\n        account.signers.attestation = signer;\n      } else if (role == ValidatorSigner) {\n        account.signers.validator = signer;\n      }\n      emit LegacySignerSet(msg.sender, signer, role);\n    } else {\n      defaultSigners[msg.sender][role] = signer;\n      emit DefaultSignerSet(msg.sender, signer, role);\n    }\n\n    emit IndexedSignerSet(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to act as a signer, for `role`, on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s EIP712 signature over `role`, `msg.sender`\n   *      and `signer`.\n   */\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  function legacyAuthorizeSignerWithSignature(\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) private {\n    authorizeAddress(signer, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Begin the process of authorizing an address to sign on behalf of the account\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   */\n  function authorizeSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register sender with Account.createAccount\");\n    require(\n      isNotAccount(signer) && isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Cannot re-authorize address signer\"\n    );\n\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: false\n    });\n    emit SignerAuthorizationStarted(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Finish the process of authorizing an address to sign on behalf of the account.\n   * @param account The address of account that authorized signing.\n   * @param role The role to finish authorizing for.\n   */\n  function completeSignerAuthorization(address account, bytes32 role) public {\n    require(\n      isAccount(account),\n      \"Unknown Account: Address that authorized signing must be a registered Account\"\n    );\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSignerForAnotherAccount(account, msg.sender),\n      \"Cannot re-authorize address signer\"\n    );\n    require(\n      signerAuthorizations[account][role][msg.sender].started == true,\n      \"Signer authorization not started\"\n    );\n\n    authorizedBy[msg.sender] = account;\n    signerAuthorizations[account][role][msg.sender].completed = true;\n    emit SignerAuthorizationCompleted(account, msg.sender, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the legacy signer for role\n   * @param _account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isLegacySigner(address _account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    Account storage account = accounts[_account];\n    if (role == ValidatorSigner && account.signers.validator == signer) {\n      return true;\n    } else if (role == AttestationSigner && account.signers.attestation == signer) {\n      return true;\n    } else if (role == VoteSigner && account.signers.vote == signer) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the default signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isDefaultSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return defaultSigners[account][role] == signer;\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as an indexed signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isIndexedSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return\n      isLegacyRole(role)\n        ? isLegacySigner(account, signer, role)\n        : isDefaultSigner(account, signer, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as a signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isSigner(address account, address signer, bytes32 role) public view returns (bool) {\n    return\n      isLegacySigner(account, signer, role) ||\n      (signerAuthorizations[account][role][signer].completed && authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Removes the signer for a default role.\n   * @param role The role that has been authorized.\n   */\n  function removeDefaultSigner(bytes32 role) public {\n    address signer = defaultSigners[msg.sender][role];\n    defaultSigners[msg.sender][role] = address(0);\n    emit DefaultSignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Remove one of the Validator, Attestation or\n   * Vote signers from an account. Should only be called from\n   * methods that check the role is a legacy signer.\n   * @param role The role that has been authorized.\n   */\n  function removeLegacySigner(bytes32 role) private {\n    Account storage account = accounts[msg.sender];\n\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n      account.signers.validator = address(0);\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n      account.signers.attestation = address(0);\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n      account.signers.vote = address(0);\n    }\n    emit LegacySignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized and indexed signer\n   * for a specific role\n   * @param role The role of the signer.\n   */\n  function removeIndexedSigner(bytes32 role) public {\n    address oldSigner = getIndexedSigner(msg.sender, role);\n    isLegacyRole(role) ? removeLegacySigner(role) : removeDefaultSigner(role);\n\n    emit IndexedSignerRemoved(msg.sender, oldSigner, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized signer for a specific role and\n   * if the signer is indexed, remove that as well.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function removeSigner(address signer, bytes32 role) public {\n    if (isIndexedSigner(msg.sender, signer, role)) {\n      removeIndexedSigner(role);\n    }\n\n    delete signerAuthorizations[msg.sender][role][signer];\n    emit SignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized vote signer for the account.\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeVoteSigner() public {\n    address signer = getLegacySigner(msg.sender, VoteSigner);\n    removeSigner(signer, VoteSigner);\n    emit VoteSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized validator signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeValidatorSigner() public {\n    address signer = getLegacySigner(msg.sender, ValidatorSigner);\n    removeSigner(signer, ValidatorSigner);\n    emit ValidatorSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized attestation signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeAttestationSigner() public {\n    address signer = getLegacySigner(msg.sender, AttestationSigner);\n    removeSigner(signer, AttestationSigner);\n    emit AttestationSignerRemoved(msg.sender, signer);\n  }\n\n  function signerToAccountWithRole(address signer, bytes32 role) internal view returns (address) {\n    address account = authorizedBy[signer];\n    if (account != address(0)) {\n      require(isSigner(account, signer, role), \"not active authorized signer for role\");\n      return account;\n    }\n\n    require(isAccount(signer), \"Must first register address with Account.createAccount\");\n    return signer;\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account that the signer is authorized to attest for.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account that signer is authorized to validate for.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account that signer is authorized to vote for.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Checks whether the role is one of Vote, Validator or Attestation\n   * @param role The role to check\n   */\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n\n  /**\n   * @notice Returns the legacy signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param _account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n  /**\n   * @notice Returns the default signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n  /**\n   * @notice Returns the indexed signer for the specified account and role.\n   * If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for one of the legacy roles\n   */\n  function hasLegacySigner(address account, bytes32 role) public view returns (bool) {\n    return getLegacySigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for a role\n   */\n  function hasDefaultSigner(address account, bytes32 role) public view returns (bool) {\n    return getDefaultSigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for the role\n   */\n  function hasIndexedSigner(address account, bytes32 role) public view returns (bool) {\n    return isLegacyRole(role) ? hasLegacySigner(account, role) : hasDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Checks whether or not the account has a signer\n   * registered for the plaintext role.\n   * @dev See `hasIndexedSigner` for more gas efficient call.\n   */\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated vote signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated vote signer.\n   */\n  function hasAuthorizedVoteSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated validator signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated validator signer.\n   */\n  function hasAuthorizedValidatorSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated attestation signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated attestation signer.\n   */\n  function hasAuthorizedAttestationSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return The length of each string in bytes.\n   * @return All strings concatenated.\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has not been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Check if `signer` has not been authorized, and if it has been previously\n   *         authorized that it was authorized by `account`.\n   * @param account The authorizing account address.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSignerForAnotherAccount(address account, address signer)\n    internal\n    view\n    returns (bool)\n  {\n    return (authorizedBy[signer] == address(0) || authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Authorizes some role of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `authorized`'s signature on `msg.sender`.\n   */\n  function authorizeAddress(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Returns the address that signed the provided role authorization.\n   * @param account The `account` property signed over in the EIP712 signature\n   * @param signer The `signer` property signed over in the EIP712 signature\n   * @param role The `role` property signed over in the EIP712 signature\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The address that signed the provided role authorization.\n   */\n  function getRoleAuthorizationSigner(\n    address account,\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 structHash = keccak256(\n      abi.encode(EIP712_AUTHORIZE_SIGNER_TYPEHASH, account, signer, role)\n    );\n    return Signatures.getSignerOfTypedDataHash(eip712DomainSeparator, structHash, v, r, s);\n  }\n\n  /**\n   * @notice Authorizes a role of `msg.sender`'s account to another address (`authorized`).\n   * @param authorized The address to authorize.\n   * @param role The role to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that this signature is EIP712 compliant over the authorizing `account`\n   * (`msg.sender`), `signer` (`authorized`) and `role`.\n   */\n  function authorizeAddressWithRole(address authorized, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    private\n  {\n    address signer = getRoleAuthorizationSigner(msg.sender, authorized, role, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Authorizes an address to `msg.sender`'s account\n   * @param authorized The address to authorize.\n   * @dev Fails if the address is already authorized for another account or is an account itself.\n   */\n  function authorize(address authorized) private {\n    require(\n      isAccount(msg.sender),\n      \"Unknown account: sender must register with createAccount first\"\n    );\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSignerForAnotherAccount(msg.sender, authorized),\n      \"Cannot re-authorize address or locked gold account for another account\"\n    );\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}\n",
        "formal_property": "rule address_cant_be_both_authorizedby_of_two_address(address x, address y, address d, bytes32 r1, bytes32 r2, method f) filtered { f -> !f.isView } { \n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "address_cant_be_both_authorizedby_of_two_address",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 72,
            "end_line": 72,
            "block_hash": "e904b23b64e81e5cd531b3f10ad4373c"
        }
    },
    {
        "id": "Accounts_address_can_authorize_two_addresses_legacy_b470dc59",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "authorizeSignerWithSignature/authorizeValidatorSigner/authorizeVoteSigner/isAccount",
        "text_chunk": "  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n",
        "formal_property": "rule address_can_authorize_two_addresses_legacy(address x, address d1, address d2)\nrule address_can_authorize_two_addresses(address x, address d1, address d2, bytes32 role1, bytes32 role2)\n{ \n\trequire x != 0 && d1 != 0 && d2 != 0 && x != d1 && x != d2 && d1 != d2 && isAccount(x); \n\tenv e;\n\trequire e.msg.sender == x;\n  \t\n\tstorage init = lastStorage;\n\t// first, authorizing d2 as a validation signer should succeed\n\tuint8 v2;\n\tbytes32 r2;\n\tbytes32 s2;\n\tauthorizeSignerWithSignature(e, d2, role2, v2, r2, s2);  \n\n\t// Authorize d1 as a Vote signer (alternative execution path - start from the state where validator authorization started)\n\tuint8 v1;\n\tbytes32 r1;\n\tbytes32 s1;\n\tauthorizeSignerWithSignature(e, d1, role1, v1, r1, s1) at init;\n\t\n\t// Even after authorizing d1, the authorization of d2 as a Validation signer should succeed\n\t\t\n\t// AuthorizedBy(d1) and AuthorizedBy(d2) should still be x\n\tassert _getAuthorizedBy(d1) == x && _getAuthorizedBy(d2) == x, \"Authorizedby should both be x\";\n}\n\tauthorizeValidatorSigner(e, d2, v2, r2, s2);  \n\tauthorizeVoteSigner(e, d1, v1, r1, s1) at init;\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "address_can_authorize_two_addresses_legacy",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "isAccount",
                "_getAuthorizedBy"
            ],
            "start_line": 96,
            "end_line": 120,
            "block_hash": "b470dc5968f0a5cce20050b63e7af933"
        }
    },
    {
        "id": "Accounts_address_can_authorize_two_addresses_9cd11f38",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "authorizeSignerWithSignature/isAccount",
        "text_chunk": "  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n",
        "formal_property": "rule address_can_authorize_two_addresses(address x, address d1, address d2, bytes32 role1, bytes32 role2)\n{ \n\trequire x != 0 && d1 != 0 && d2 != 0 && x != d1 && x != d2 && d1 != d2 && isAccount(x); \n\tenv e;\n\trequire e.msg.sender == x;\n  \t\n\tstorage init = lastStorage;\n\t// first, authorizing d2 as a validation signer should succeed\n\tuint8 v2;\n\tbytes32 r2;\n\tbytes32 s2;\n\tauthorizeSignerWithSignature(e, d2, role2, v2, r2, s2);  \n\n\t// Authorize d1 as a Vote signer (alternative execution path - start from the state where validator authorization started)\n\tuint8 v1;\n\tbytes32 r1;\n\tbytes32 s1;\n\tauthorizeSignerWithSignature(e, d1, role1, v1, r1, s1) at init;\n\t\n\t// Even after authorizing d1, the authorization of d2 as a Validation signer should succeed\n\t\t\n\t// AuthorizedBy(d1) and AuthorizedBy(d2) should still be x\n\tassert _getAuthorizedBy(d1) == x && _getAuthorizedBy(d2) == x, \"Authorizedby should both be x\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "address_can_authorize_two_addresses",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "isAccount",
                "_getAuthorizedBy"
            ],
            "start_line": 125,
            "end_line": 149,
            "block_hash": "9cd11f386b0c64b288452695e7456385"
        }
    },
    {
        "id": "Accounts_authorizedBy_can_not_be_removed_a4a2b3e9",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is\n  IAccounts,\n  ICeloVersionedContract,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct SignerAuthorization {\n    bool started;\n    bool completed;\n  }\n\n  struct Account {\n    bool exists;\n    // [Deprecated] Each account may authorize signing keys to use for voting,\n    // validating or attestation. These keys may not be keys of other accounts,\n    // and may not be authorized by any other account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  struct PaymentDelegation {\n    // Address that should receive a fraction of validator payments.\n    address beneficiary;\n    // Fraction of payment to delegate to `beneficiary`.\n    FixidityLib.Fraction fraction;\n  }\n\n  mapping(address => Account) internal accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n  // Default signers by account (replaces the legacy Signers struct on Account)\n  mapping(address => mapping(bytes32 => address)) defaultSigners;\n  // All signers and their roles for a given account\n  // solhint-disable-next-line max-line-length\n  mapping(address => mapping(bytes32 => mapping(address => SignerAuthorization))) signerAuthorizations;\n\n  bytes32 public constant EIP712_AUTHORIZE_SIGNER_TYPEHASH = keccak256(\n    \"AuthorizeSigner(address account,address signer,bytes32 role)\"\n  );\n  bytes32 public eip712DomainSeparator;\n\n  // A per-account list of CIP8 storage roots, bypassing CIP3.\n  mapping(address => bytes[]) public offchainStorageRoots;\n\n  // Optional per-account validator payment delegation information.\n  mapping(address => PaymentDelegation) internal paymentDelegations;\n\n  bytes32 constant ValidatorSigner = keccak256(abi.encodePacked(\"celo.org/core/validator\"));\n  bytes32 constant AttestationSigner = keccak256(abi.encodePacked(\"celo.org/core/attestation\"));\n  bytes32 constant VoteSigner = keccak256(abi.encodePacked(\"celo.org/core/vote\"));\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event SignerAuthorized(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationStarted(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationCompleted(address indexed account, address signer, bytes32 indexed role);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event IndexedSignerSet(address indexed account, address signer, bytes32 role);\n  event IndexedSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event DefaultSignerSet(address indexed account, address signer, bytes32 role);\n  event DefaultSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event LegacySignerSet(address indexed account, address signer, bytes32 role);\n  event LegacySignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event SignerRemoved(address indexed account, address oldSigner, bytes32 indexed role);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n  event OffchainStorageRootAdded(address indexed account, bytes url);\n  event OffchainStorageRootRemoved(address indexed account, bytes url, uint256 index);\n  event PaymentDelegationSet(address indexed beneficiary, uint256 fraction);\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return Storage version of the contract.\n   * @return Major version of the contract.\n   * @return Minor version of the contract.\n   * @return Patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 4, 1);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setEip712DomainSeparator();\n  }\n\n  /**\n   * @notice Sets the EIP712 domain separator for the Celo Accounts abstraction.\n   */\n  function setEip712DomainSeparator() public {\n    uint256 chainId;\n    assembly {\n      chainId := chainid\n    }\n\n    eip712DomainSeparator = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(\"Celo Core Contracts\")),\n        keccak256(\"1.0\"),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),\n      \"Account already exists or address is an authorized signer for another account\"\n    );\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Register with createAccount to set account name\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Adds a new CIP8 storage root.\n   * @param url The URL pointing to the offchain storage root.\n   */\n  function addStorageRoot(bytes calldata url) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    offchainStorageRoots[msg.sender].push(url);\n    emit OffchainStorageRootAdded(msg.sender, url);\n  }\n\n  /**\n   * @notice Removes a CIP8 storage root.\n   * @param index The index of the storage root to be removed in the account's\n   * list of storage roots.\n   * @dev The order of storage roots may change after this operation (the last\n   * storage root will be moved to `index`), be aware of this if removing\n   * multiple storage roots at a time.\n   */\n  function removeStorageRoot(uint256 index) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(index < offchainStorageRoots[msg.sender].length, \"Invalid storage root index\");\n    uint256 lastIndex = offchainStorageRoots[msg.sender].length - 1;\n    bytes memory url = offchainStorageRoots[msg.sender][index];\n    offchainStorageRoots[msg.sender][index] = offchainStorageRoots[msg.sender][lastIndex];\n    offchainStorageRoots[msg.sender].length--;\n    emit OffchainStorageRootRemoved(msg.sender, url, index);\n  }\n\n  /**\n   * @notice Returns the full list of offchain storage roots for an account.\n   * @param account The account whose storage roots to return.\n   * @return Concatenated storage root URLs.\n   * @return Lengths of storage root URLs.\n   */\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n  /**\n   * @notice Sets validator payment delegation settings.\n   * @param beneficiary The address that should receive a portion of validator\n   * payments.\n   * @param fraction The fraction of the validator's payment that should be\n   * diverted to `beneficiary` every epoch, given as FixidityLib value. Must not\n   * be greater than 1.\n   * @dev Use `deletePaymentDelegation` to unset the payment delegation.\n   */\n  function setPaymentDelegation(address beneficiary, uint256 fraction) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(beneficiary != address(0), \"Beneficiary cannot be address 0x0\");\n    FixidityLib.Fraction memory f = FixidityLib.wrap(fraction);\n    require(f.lte(FixidityLib.fixed1()), \"Fraction must not be greater than 1\");\n    paymentDelegations[msg.sender] = PaymentDelegation(beneficiary, f);\n    emit PaymentDelegationSet(beneficiary, fraction);\n  }\n\n  /**\n   * @notice Removes a validator's payment delegation by setting benficiary and\n   * fraction to 0.\n   */\n  function deletePaymentDelegation() public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    paymentDelegations[msg.sender] = PaymentDelegation(address(0x0), FixidityLib.wrap(0));\n    emit PaymentDelegationSet(address(0x0), 0);\n  }\n\n  /**\n   * @notice Gets validator payment delegation settings.\n   * @param account Account of the validator.\n   * @return Beneficiary address of payment delegated.\n   * @return Fraction of payment delegated.\n   */\n  function getPaymentDelegation(address account) external view returns (address, uint256) {\n    PaymentDelegation storage delegation = paymentDelegations[account];\n    return (delegation.beneficiary, delegation.fraction.unwrap());\n  }\n\n  /**\n   * @notice Set the indexed signer for a specific role\n   * @param signer the address to set as default\n   * @param role the role to register a default signer for\n   */\n  function setIndexedSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(isNotAccount(signer), \"Cannot authorize account as signer\");\n    require(\n      isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Not a signer for this account\"\n    );\n    require(isSigner(msg.sender, signer, role), \"Must authorize signer before setting as default\");\n\n    Account storage account = accounts[msg.sender];\n    if (isLegacyRole(role)) {\n      if (role == VoteSigner) {\n        account.signers.vote = signer;\n      } else if (role == AttestationSigner) {\n        account.signers.attestation = signer;\n      } else if (role == ValidatorSigner) {\n        account.signers.validator = signer;\n      }\n      emit LegacySignerSet(msg.sender, signer, role);\n    } else {\n      defaultSigners[msg.sender][role] = signer;\n      emit DefaultSignerSet(msg.sender, signer, role);\n    }\n\n    emit IndexedSignerSet(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to act as a signer, for `role`, on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s EIP712 signature over `role`, `msg.sender`\n   *      and `signer`.\n   */\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  function legacyAuthorizeSignerWithSignature(\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) private {\n    authorizeAddress(signer, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Begin the process of authorizing an address to sign on behalf of the account\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   */\n  function authorizeSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register sender with Account.createAccount\");\n    require(\n      isNotAccount(signer) && isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Cannot re-authorize address signer\"\n    );\n\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: false\n    });\n    emit SignerAuthorizationStarted(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Finish the process of authorizing an address to sign on behalf of the account.\n   * @param account The address of account that authorized signing.\n   * @param role The role to finish authorizing for.\n   */\n  function completeSignerAuthorization(address account, bytes32 role) public {\n    require(\n      isAccount(account),\n      \"Unknown Account: Address that authorized signing must be a registered Account\"\n    );\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSignerForAnotherAccount(account, msg.sender),\n      \"Cannot re-authorize address signer\"\n    );\n    require(\n      signerAuthorizations[account][role][msg.sender].started == true,\n      \"Signer authorization not started\"\n    );\n\n    authorizedBy[msg.sender] = account;\n    signerAuthorizations[account][role][msg.sender].completed = true;\n    emit SignerAuthorizationCompleted(account, msg.sender, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the legacy signer for role\n   * @param _account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isLegacySigner(address _account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    Account storage account = accounts[_account];\n    if (role == ValidatorSigner && account.signers.validator == signer) {\n      return true;\n    } else if (role == AttestationSigner && account.signers.attestation == signer) {\n      return true;\n    } else if (role == VoteSigner && account.signers.vote == signer) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the default signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isDefaultSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return defaultSigners[account][role] == signer;\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as an indexed signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isIndexedSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return\n      isLegacyRole(role)\n        ? isLegacySigner(account, signer, role)\n        : isDefaultSigner(account, signer, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as a signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isSigner(address account, address signer, bytes32 role) public view returns (bool) {\n    return\n      isLegacySigner(account, signer, role) ||\n      (signerAuthorizations[account][role][signer].completed && authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Removes the signer for a default role.\n   * @param role The role that has been authorized.\n   */\n  function removeDefaultSigner(bytes32 role) public {\n    address signer = defaultSigners[msg.sender][role];\n    defaultSigners[msg.sender][role] = address(0);\n    emit DefaultSignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Remove one of the Validator, Attestation or\n   * Vote signers from an account. Should only be called from\n   * methods that check the role is a legacy signer.\n   * @param role The role that has been authorized.\n   */\n  function removeLegacySigner(bytes32 role) private {\n    Account storage account = accounts[msg.sender];\n\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n      account.signers.validator = address(0);\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n      account.signers.attestation = address(0);\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n      account.signers.vote = address(0);\n    }\n    emit LegacySignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized and indexed signer\n   * for a specific role\n   * @param role The role of the signer.\n   */\n  function removeIndexedSigner(bytes32 role) public {\n    address oldSigner = getIndexedSigner(msg.sender, role);\n    isLegacyRole(role) ? removeLegacySigner(role) : removeDefaultSigner(role);\n\n    emit IndexedSignerRemoved(msg.sender, oldSigner, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized signer for a specific role and\n   * if the signer is indexed, remove that as well.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function removeSigner(address signer, bytes32 role) public {\n    if (isIndexedSigner(msg.sender, signer, role)) {\n      removeIndexedSigner(role);\n    }\n\n    delete signerAuthorizations[msg.sender][role][signer];\n    emit SignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized vote signer for the account.\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeVoteSigner() public {\n    address signer = getLegacySigner(msg.sender, VoteSigner);\n    removeSigner(signer, VoteSigner);\n    emit VoteSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized validator signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeValidatorSigner() public {\n    address signer = getLegacySigner(msg.sender, ValidatorSigner);\n    removeSigner(signer, ValidatorSigner);\n    emit ValidatorSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized attestation signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeAttestationSigner() public {\n    address signer = getLegacySigner(msg.sender, AttestationSigner);\n    removeSigner(signer, AttestationSigner);\n    emit AttestationSignerRemoved(msg.sender, signer);\n  }\n\n  function signerToAccountWithRole(address signer, bytes32 role) internal view returns (address) {\n    address account = authorizedBy[signer];\n    if (account != address(0)) {\n      require(isSigner(account, signer, role), \"not active authorized signer for role\");\n      return account;\n    }\n\n    require(isAccount(signer), \"Must first register address with Account.createAccount\");\n    return signer;\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account that the signer is authorized to attest for.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account that signer is authorized to validate for.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account that signer is authorized to vote for.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Checks whether the role is one of Vote, Validator or Attestation\n   * @param role The role to check\n   */\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n\n  /**\n   * @notice Returns the legacy signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param _account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n  /**\n   * @notice Returns the default signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n  /**\n   * @notice Returns the indexed signer for the specified account and role.\n   * If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for one of the legacy roles\n   */\n  function hasLegacySigner(address account, bytes32 role) public view returns (bool) {\n    return getLegacySigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for a role\n   */\n  function hasDefaultSigner(address account, bytes32 role) public view returns (bool) {\n    return getDefaultSigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for the role\n   */\n  function hasIndexedSigner(address account, bytes32 role) public view returns (bool) {\n    return isLegacyRole(role) ? hasLegacySigner(account, role) : hasDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Checks whether or not the account has a signer\n   * registered for the plaintext role.\n   * @dev See `hasIndexedSigner` for more gas efficient call.\n   */\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated vote signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated vote signer.\n   */\n  function hasAuthorizedVoteSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated validator signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated validator signer.\n   */\n  function hasAuthorizedValidatorSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated attestation signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated attestation signer.\n   */\n  function hasAuthorizedAttestationSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return The length of each string in bytes.\n   * @return All strings concatenated.\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has not been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Check if `signer` has not been authorized, and if it has been previously\n   *         authorized that it was authorized by `account`.\n   * @param account The authorizing account address.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSignerForAnotherAccount(address account, address signer)\n    internal\n    view\n    returns (bool)\n  {\n    return (authorizedBy[signer] == address(0) || authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Authorizes some role of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `authorized`'s signature on `msg.sender`.\n   */\n  function authorizeAddress(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Returns the address that signed the provided role authorization.\n   * @param account The `account` property signed over in the EIP712 signature\n   * @param signer The `signer` property signed over in the EIP712 signature\n   * @param role The `role` property signed over in the EIP712 signature\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The address that signed the provided role authorization.\n   */\n  function getRoleAuthorizationSigner(\n    address account,\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 structHash = keccak256(\n      abi.encode(EIP712_AUTHORIZE_SIGNER_TYPEHASH, account, signer, role)\n    );\n    return Signatures.getSignerOfTypedDataHash(eip712DomainSeparator, structHash, v, r, s);\n  }\n\n  /**\n   * @notice Authorizes a role of `msg.sender`'s account to another address (`authorized`).\n   * @param authorized The address to authorize.\n   * @param role The role to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that this signature is EIP712 compliant over the authorizing `account`\n   * (`msg.sender`), `signer` (`authorized`) and `role`.\n   */\n  function authorizeAddressWithRole(address authorized, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    private\n  {\n    address signer = getRoleAuthorizationSigner(msg.sender, authorized, role, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Authorizes an address to `msg.sender`'s account\n   * @param authorized The address to authorize.\n   * @dev Fails if the address is already authorized for another account or is an account itself.\n   */\n  function authorize(address authorized) private {\n    require(\n      isAccount(msg.sender),\n      \"Unknown account: sender must register with createAccount first\"\n    );\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSignerForAnotherAccount(msg.sender, authorized),\n      \"Cannot re-authorize address or locked gold account for another account\"\n    );\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}\n",
        "formal_property": "rule authorizedBy_can_not_be_removed(method f, address signer) filtered { f -> !f.isView } {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "authorizedBy_can_not_be_removed",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 154,
            "end_line": 154,
            "block_hash": "a4a2b3e9dc5054b12fbc5044c99e0b67"
        }
    },
    {
        "id": "Accounts_initializableOnlyOnce_b050ea09",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "initialize",
        "text_chunk": "  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setEip712DomainSeparator();\n  }\n",
        "formal_property": "rule initializableOnlyOnce {\n\tenv e;\n\tcalldataarg arg;\n\tinitialize(e, arg);\n\n\tenv e2;\n\tcalldataarg arg2;\n\tinitialize@withrevert(e2, arg2);\n\tassert lastReverted;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "initializableOnlyOnce",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 167,
            "end_line": 176,
            "block_hash": "b050ea09240de3e45d3d975173972ce4"
        }
    },
    {
        "id": "Accounts_createsAccount_b3fa35bc",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "createAccount/setAccount",
        "text_chunk": "  function createAccount() public returns (bool) {\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),\n      \"Account already exists or address is an authorized signer for another account\"\n    );\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n",
        "formal_property": "rule createsAccount(method f, address a) filtered { f ->\n\t!f.isView\n\t\t&& f.selector != createAccount().selector\n\t\t&& f.selector != setAccount(string,bytes,address,uint8,bytes32,bytes32).selector\n} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "createsAccount",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 181,
            "end_line": 185,
            "block_hash": "b3fa35bc08a96f3811c44d39b96293df"
        }
    },
    {
        "id": "Accounts_viewFunctionsDoNotRevert_f62fbbb3",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "batchGetMetadataURL/getMetadataURL/getOffchainStorageRoots/hasAuthorizedSigner",
        "text_chunk": "  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n",
        "formal_property": "rule viewFunctionsDoNotRevert(method f) filtered { f -> \n\tf.isView \n\t// some functions we ignore, and the reasons:\n\t&& f.selector != hasAuthorizedSigner(address,string).selector // Calldatasize may not match\n\t&& f.selector != batchGetMetadataURL(address[]).selector // Calldatasize may not match\n\n  // These require an account to exist\n\t&& f.selector != getOffchainStorageRoots(address).selector\n\t&& f.selector != offchainStorageRoots(address,uint256).selector\n} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "viewFunctionsDoNotRevert",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 203,
            "end_line": 212,
            "block_hash": "f62fbbb3ad8f561dccdee27a5c3c7ee2"
        }
    },
    {
        "id": "Accounts_cantGoFromNoAuthorizationToCompletedInOneStepUnlessRoleIsLegacy_b6737ef3",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "authorizeSignerWithSignature",
        "text_chunk": "  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n",
        "formal_property": "rule cantGoFromNoAuthorizationToCompletedInOneStepUnlessRoleIsLegacy(method f) filtered { f -> \n\t!f.isView \n\t\t// the authorizeSignerWithSignature allows the signer to provide a signature to the account, so we exclude this option\n\t\t&& f.selector != authorizeSignerWithSignature(address,bytes32,uint8,bytes32,bytes32).selector\n} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cantGoFromNoAuthorizationToCompletedInOneStepUnlessRoleIsLegacy",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 290,
            "end_line": 294,
            "block_hash": "b6737ef360750828aa5b907b032641fc"
        }
    },
    {
        "id": "Accounts_cantMakeASignerForNonLegacyRoleWithoutApprovalOfSigner_9e4d197a",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "authorizeSignerWithSignature",
        "text_chunk": "  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n",
        "formal_property": "rule cantMakeASignerForNonLegacyRoleWithoutApprovalOfSigner(method f) filtered { f -> \n\t!f.isView \n\t\t// the authorizeSignerWithSignature allows the signer to provide a signature to the account, so we exclude this option\n\t\t&& f.selector != authorizeSignerWithSignature(address,bytes32,uint8,bytes32,bytes32).selector\t\n} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cantMakeASignerForNonLegacyRoleWithoutApprovalOfSigner",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 309,
            "end_line": 313,
            "block_hash": "9e4d197a6ad0cd822ee818a781f4809b"
        }
    },
    {
        "id": "Accounts_cannotStartSignerAuthorizationsForOtherAccounts_444b910e",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is\n  IAccounts,\n  ICeloVersionedContract,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct SignerAuthorization {\n    bool started;\n    bool completed;\n  }\n\n  struct Account {\n    bool exists;\n    // [Deprecated] Each account may authorize signing keys to use for voting,\n    // validating or attestation. These keys may not be keys of other accounts,\n    // and may not be authorized by any other account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  struct PaymentDelegation {\n    // Address that should receive a fraction of validator payments.\n    address beneficiary;\n    // Fraction of payment to delegate to `beneficiary`.\n    FixidityLib.Fraction fraction;\n  }\n\n  mapping(address => Account) internal accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n  // Default signers by account (replaces the legacy Signers struct on Account)\n  mapping(address => mapping(bytes32 => address)) defaultSigners;\n  // All signers and their roles for a given account\n  // solhint-disable-next-line max-line-length\n  mapping(address => mapping(bytes32 => mapping(address => SignerAuthorization))) signerAuthorizations;\n\n  bytes32 public constant EIP712_AUTHORIZE_SIGNER_TYPEHASH = keccak256(\n    \"AuthorizeSigner(address account,address signer,bytes32 role)\"\n  );\n  bytes32 public eip712DomainSeparator;\n\n  // A per-account list of CIP8 storage roots, bypassing CIP3.\n  mapping(address => bytes[]) public offchainStorageRoots;\n\n  // Optional per-account validator payment delegation information.\n  mapping(address => PaymentDelegation) internal paymentDelegations;\n\n  bytes32 constant ValidatorSigner = keccak256(abi.encodePacked(\"celo.org/core/validator\"));\n  bytes32 constant AttestationSigner = keccak256(abi.encodePacked(\"celo.org/core/attestation\"));\n  bytes32 constant VoteSigner = keccak256(abi.encodePacked(\"celo.org/core/vote\"));\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event SignerAuthorized(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationStarted(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationCompleted(address indexed account, address signer, bytes32 indexed role);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event IndexedSignerSet(address indexed account, address signer, bytes32 role);\n  event IndexedSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event DefaultSignerSet(address indexed account, address signer, bytes32 role);\n  event DefaultSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event LegacySignerSet(address indexed account, address signer, bytes32 role);\n  event LegacySignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event SignerRemoved(address indexed account, address oldSigner, bytes32 indexed role);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n  event OffchainStorageRootAdded(address indexed account, bytes url);\n  event OffchainStorageRootRemoved(address indexed account, bytes url, uint256 index);\n  event PaymentDelegationSet(address indexed beneficiary, uint256 fraction);\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return Storage version of the contract.\n   * @return Major version of the contract.\n   * @return Minor version of the contract.\n   * @return Patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 4, 1);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setEip712DomainSeparator();\n  }\n\n  /**\n   * @notice Sets the EIP712 domain separator for the Celo Accounts abstraction.\n   */\n  function setEip712DomainSeparator() public {\n    uint256 chainId;\n    assembly {\n      chainId := chainid\n    }\n\n    eip712DomainSeparator = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(\"Celo Core Contracts\")),\n        keccak256(\"1.0\"),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),\n      \"Account already exists or address is an authorized signer for another account\"\n    );\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Register with createAccount to set account name\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Adds a new CIP8 storage root.\n   * @param url The URL pointing to the offchain storage root.\n   */\n  function addStorageRoot(bytes calldata url) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    offchainStorageRoots[msg.sender].push(url);\n    emit OffchainStorageRootAdded(msg.sender, url);\n  }\n\n  /**\n   * @notice Removes a CIP8 storage root.\n   * @param index The index of the storage root to be removed in the account's\n   * list of storage roots.\n   * @dev The order of storage roots may change after this operation (the last\n   * storage root will be moved to `index`), be aware of this if removing\n   * multiple storage roots at a time.\n   */\n  function removeStorageRoot(uint256 index) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(index < offchainStorageRoots[msg.sender].length, \"Invalid storage root index\");\n    uint256 lastIndex = offchainStorageRoots[msg.sender].length - 1;\n    bytes memory url = offchainStorageRoots[msg.sender][index];\n    offchainStorageRoots[msg.sender][index] = offchainStorageRoots[msg.sender][lastIndex];\n    offchainStorageRoots[msg.sender].length--;\n    emit OffchainStorageRootRemoved(msg.sender, url, index);\n  }\n\n  /**\n   * @notice Returns the full list of offchain storage roots for an account.\n   * @param account The account whose storage roots to return.\n   * @return Concatenated storage root URLs.\n   * @return Lengths of storage root URLs.\n   */\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n  /**\n   * @notice Sets validator payment delegation settings.\n   * @param beneficiary The address that should receive a portion of validator\n   * payments.\n   * @param fraction The fraction of the validator's payment that should be\n   * diverted to `beneficiary` every epoch, given as FixidityLib value. Must not\n   * be greater than 1.\n   * @dev Use `deletePaymentDelegation` to unset the payment delegation.\n   */\n  function setPaymentDelegation(address beneficiary, uint256 fraction) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(beneficiary != address(0), \"Beneficiary cannot be address 0x0\");\n    FixidityLib.Fraction memory f = FixidityLib.wrap(fraction);\n    require(f.lte(FixidityLib.fixed1()), \"Fraction must not be greater than 1\");\n    paymentDelegations[msg.sender] = PaymentDelegation(beneficiary, f);\n    emit PaymentDelegationSet(beneficiary, fraction);\n  }\n\n  /**\n   * @notice Removes a validator's payment delegation by setting benficiary and\n   * fraction to 0.\n   */\n  function deletePaymentDelegation() public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    paymentDelegations[msg.sender] = PaymentDelegation(address(0x0), FixidityLib.wrap(0));\n    emit PaymentDelegationSet(address(0x0), 0);\n  }\n\n  /**\n   * @notice Gets validator payment delegation settings.\n   * @param account Account of the validator.\n   * @return Beneficiary address of payment delegated.\n   * @return Fraction of payment delegated.\n   */\n  function getPaymentDelegation(address account) external view returns (address, uint256) {\n    PaymentDelegation storage delegation = paymentDelegations[account];\n    return (delegation.beneficiary, delegation.fraction.unwrap());\n  }\n\n  /**\n   * @notice Set the indexed signer for a specific role\n   * @param signer the address to set as default\n   * @param role the role to register a default signer for\n   */\n  function setIndexedSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(isNotAccount(signer), \"Cannot authorize account as signer\");\n    require(\n      isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Not a signer for this account\"\n    );\n    require(isSigner(msg.sender, signer, role), \"Must authorize signer before setting as default\");\n\n    Account storage account = accounts[msg.sender];\n    if (isLegacyRole(role)) {\n      if (role == VoteSigner) {\n        account.signers.vote = signer;\n      } else if (role == AttestationSigner) {\n        account.signers.attestation = signer;\n      } else if (role == ValidatorSigner) {\n        account.signers.validator = signer;\n      }\n      emit LegacySignerSet(msg.sender, signer, role);\n    } else {\n      defaultSigners[msg.sender][role] = signer;\n      emit DefaultSignerSet(msg.sender, signer, role);\n    }\n\n    emit IndexedSignerSet(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to act as a signer, for `role`, on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s EIP712 signature over `role`, `msg.sender`\n   *      and `signer`.\n   */\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  function legacyAuthorizeSignerWithSignature(\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) private {\n    authorizeAddress(signer, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Begin the process of authorizing an address to sign on behalf of the account\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   */\n  function authorizeSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register sender with Account.createAccount\");\n    require(\n      isNotAccount(signer) && isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Cannot re-authorize address signer\"\n    );\n\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: false\n    });\n    emit SignerAuthorizationStarted(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Finish the process of authorizing an address to sign on behalf of the account.\n   * @param account The address of account that authorized signing.\n   * @param role The role to finish authorizing for.\n   */\n  function completeSignerAuthorization(address account, bytes32 role) public {\n    require(\n      isAccount(account),\n      \"Unknown Account: Address that authorized signing must be a registered Account\"\n    );\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSignerForAnotherAccount(account, msg.sender),\n      \"Cannot re-authorize address signer\"\n    );\n    require(\n      signerAuthorizations[account][role][msg.sender].started == true,\n      \"Signer authorization not started\"\n    );\n\n    authorizedBy[msg.sender] = account;\n    signerAuthorizations[account][role][msg.sender].completed = true;\n    emit SignerAuthorizationCompleted(account, msg.sender, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the legacy signer for role\n   * @param _account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isLegacySigner(address _account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    Account storage account = accounts[_account];\n    if (role == ValidatorSigner && account.signers.validator == signer) {\n      return true;\n    } else if (role == AttestationSigner && account.signers.attestation == signer) {\n      return true;\n    } else if (role == VoteSigner && account.signers.vote == signer) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the default signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isDefaultSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return defaultSigners[account][role] == signer;\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as an indexed signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isIndexedSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return\n      isLegacyRole(role)\n        ? isLegacySigner(account, signer, role)\n        : isDefaultSigner(account, signer, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as a signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isSigner(address account, address signer, bytes32 role) public view returns (bool) {\n    return\n      isLegacySigner(account, signer, role) ||\n      (signerAuthorizations[account][role][signer].completed && authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Removes the signer for a default role.\n   * @param role The role that has been authorized.\n   */\n  function removeDefaultSigner(bytes32 role) public {\n    address signer = defaultSigners[msg.sender][role];\n    defaultSigners[msg.sender][role] = address(0);\n    emit DefaultSignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Remove one of the Validator, Attestation or\n   * Vote signers from an account. Should only be called from\n   * methods that check the role is a legacy signer.\n   * @param role The role that has been authorized.\n   */\n  function removeLegacySigner(bytes32 role) private {\n    Account storage account = accounts[msg.sender];\n\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n      account.signers.validator = address(0);\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n      account.signers.attestation = address(0);\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n      account.signers.vote = address(0);\n    }\n    emit LegacySignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized and indexed signer\n   * for a specific role\n   * @param role The role of the signer.\n   */\n  function removeIndexedSigner(bytes32 role) public {\n    address oldSigner = getIndexedSigner(msg.sender, role);\n    isLegacyRole(role) ? removeLegacySigner(role) : removeDefaultSigner(role);\n\n    emit IndexedSignerRemoved(msg.sender, oldSigner, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized signer for a specific role and\n   * if the signer is indexed, remove that as well.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function removeSigner(address signer, bytes32 role) public {\n    if (isIndexedSigner(msg.sender, signer, role)) {\n      removeIndexedSigner(role);\n    }\n\n    delete signerAuthorizations[msg.sender][role][signer];\n    emit SignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized vote signer for the account.\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeVoteSigner() public {\n    address signer = getLegacySigner(msg.sender, VoteSigner);\n    removeSigner(signer, VoteSigner);\n    emit VoteSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized validator signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeValidatorSigner() public {\n    address signer = getLegacySigner(msg.sender, ValidatorSigner);\n    removeSigner(signer, ValidatorSigner);\n    emit ValidatorSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized attestation signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeAttestationSigner() public {\n    address signer = getLegacySigner(msg.sender, AttestationSigner);\n    removeSigner(signer, AttestationSigner);\n    emit AttestationSignerRemoved(msg.sender, signer);\n  }\n\n  function signerToAccountWithRole(address signer, bytes32 role) internal view returns (address) {\n    address account = authorizedBy[signer];\n    if (account != address(0)) {\n      require(isSigner(account, signer, role), \"not active authorized signer for role\");\n      return account;\n    }\n\n    require(isAccount(signer), \"Must first register address with Account.createAccount\");\n    return signer;\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account that the signer is authorized to attest for.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account that signer is authorized to validate for.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account that signer is authorized to vote for.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Checks whether the role is one of Vote, Validator or Attestation\n   * @param role The role to check\n   */\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n\n  /**\n   * @notice Returns the legacy signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param _account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n  /**\n   * @notice Returns the default signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n  /**\n   * @notice Returns the indexed signer for the specified account and role.\n   * If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for one of the legacy roles\n   */\n  function hasLegacySigner(address account, bytes32 role) public view returns (bool) {\n    return getLegacySigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for a role\n   */\n  function hasDefaultSigner(address account, bytes32 role) public view returns (bool) {\n    return getDefaultSigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for the role\n   */\n  function hasIndexedSigner(address account, bytes32 role) public view returns (bool) {\n    return isLegacyRole(role) ? hasLegacySigner(account, role) : hasDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Checks whether or not the account has a signer\n   * registered for the plaintext role.\n   * @dev See `hasIndexedSigner` for more gas efficient call.\n   */\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated vote signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated vote signer.\n   */\n  function hasAuthorizedVoteSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated validator signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated validator signer.\n   */\n  function hasAuthorizedValidatorSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated attestation signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated attestation signer.\n   */\n  function hasAuthorizedAttestationSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return The length of each string in bytes.\n   * @return All strings concatenated.\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has not been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Check if `signer` has not been authorized, and if it has been previously\n   *         authorized that it was authorized by `account`.\n   * @param account The authorizing account address.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSignerForAnotherAccount(address account, address signer)\n    internal\n    view\n    returns (bool)\n  {\n    return (authorizedBy[signer] == address(0) || authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Authorizes some role of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `authorized`'s signature on `msg.sender`.\n   */\n  function authorizeAddress(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Returns the address that signed the provided role authorization.\n   * @param account The `account` property signed over in the EIP712 signature\n   * @param signer The `signer` property signed over in the EIP712 signature\n   * @param role The `role` property signed over in the EIP712 signature\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The address that signed the provided role authorization.\n   */\n  function getRoleAuthorizationSigner(\n    address account,\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 structHash = keccak256(\n      abi.encode(EIP712_AUTHORIZE_SIGNER_TYPEHASH, account, signer, role)\n    );\n    return Signatures.getSignerOfTypedDataHash(eip712DomainSeparator, structHash, v, r, s);\n  }\n\n  /**\n   * @notice Authorizes a role of `msg.sender`'s account to another address (`authorized`).\n   * @param authorized The address to authorize.\n   * @param role The role to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that this signature is EIP712 compliant over the authorizing `account`\n   * (`msg.sender`), `signer` (`authorized`) and `role`.\n   */\n  function authorizeAddressWithRole(address authorized, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    private\n  {\n    address signer = getRoleAuthorizationSigner(msg.sender, authorized, role, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Authorizes an address to `msg.sender`'s account\n   * @param authorized The address to authorize.\n   * @dev Fails if the address is already authorized for another account or is an account itself.\n   */\n  function authorize(address authorized) private {\n    require(\n      isAccount(msg.sender),\n      \"Unknown account: sender must register with createAccount first\"\n    );\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSignerForAnotherAccount(msg.sender, authorized),\n      \"Cannot re-authorize address or locked gold account for another account\"\n    );\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}\n",
        "formal_property": "rule cannotStartSignerAuthorizationsForOtherAccounts(method f) filtered { f -> !f.isView } {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cannotStartSignerAuthorizationsForOtherAccounts",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 335,
            "end_line": 335,
            "block_hash": "444b910ee1e9cde122b2ee32055e1b8c"
        }
    },
    {
        "id": "Accounts_cannotSetAuthorizedByWithoutSignatures_db3888f8",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "authorizeAttestationSigner/authorizeSignerWithSignature/authorizeValidatorSigner/authorizeValidatorSignerWithKeys/authorizeValidatorSignerWithPublicKey/authorizeVoteSigner",
        "text_chunk": "  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n",
        "formal_property": "rule cannotSetAuthorizedByWithoutSignatures(method f) filtered { f -> \n\t!f.isView \n\t\t&& f.selector != authorizeSignerWithSignature(address,bytes32,uint8,bytes32,bytes32).selector\n\t\t&& f.selector != authorizeAttestationSigner(address,uint8,bytes32,bytes32).selector\n\t\t&& f.selector != authorizeValidatorSigner(address,uint8,bytes32,bytes32).selector\n\t\t&& f.selector != authorizeValidatorSignerWithKeys(address,uint8,bytes32,bytes32,bytes,bytes,bytes).selector\n\t\t&& f.selector != authorizeValidatorSignerWithPublicKey(address,uint8,bytes32,bytes32,bytes).selector\n\t\t&& f.selector != authorizeVoteSigner(address,uint8,bytes32,bytes32).selector\n} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cannotSetAuthorizedByWithoutSignatures",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 351,
            "end_line": 359,
            "block_hash": "db3888f806acf15ca1018f236e9a99ee"
        }
    },
    {
        "id": "Accounts_signerAuthorizationChangePrivileges_fc2037fa",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is\n  IAccounts,\n  ICeloVersionedContract,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct SignerAuthorization {\n    bool started;\n    bool completed;\n  }\n\n  struct Account {\n    bool exists;\n    // [Deprecated] Each account may authorize signing keys to use for voting,\n    // validating or attestation. These keys may not be keys of other accounts,\n    // and may not be authorized by any other account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  struct PaymentDelegation {\n    // Address that should receive a fraction of validator payments.\n    address beneficiary;\n    // Fraction of payment to delegate to `beneficiary`.\n    FixidityLib.Fraction fraction;\n  }\n\n  mapping(address => Account) internal accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n  // Default signers by account (replaces the legacy Signers struct on Account)\n  mapping(address => mapping(bytes32 => address)) defaultSigners;\n  // All signers and their roles for a given account\n  // solhint-disable-next-line max-line-length\n  mapping(address => mapping(bytes32 => mapping(address => SignerAuthorization))) signerAuthorizations;\n\n  bytes32 public constant EIP712_AUTHORIZE_SIGNER_TYPEHASH = keccak256(\n    \"AuthorizeSigner(address account,address signer,bytes32 role)\"\n  );\n  bytes32 public eip712DomainSeparator;\n\n  // A per-account list of CIP8 storage roots, bypassing CIP3.\n  mapping(address => bytes[]) public offchainStorageRoots;\n\n  // Optional per-account validator payment delegation information.\n  mapping(address => PaymentDelegation) internal paymentDelegations;\n\n  bytes32 constant ValidatorSigner = keccak256(abi.encodePacked(\"celo.org/core/validator\"));\n  bytes32 constant AttestationSigner = keccak256(abi.encodePacked(\"celo.org/core/attestation\"));\n  bytes32 constant VoteSigner = keccak256(abi.encodePacked(\"celo.org/core/vote\"));\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event SignerAuthorized(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationStarted(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationCompleted(address indexed account, address signer, bytes32 indexed role);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event IndexedSignerSet(address indexed account, address signer, bytes32 role);\n  event IndexedSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event DefaultSignerSet(address indexed account, address signer, bytes32 role);\n  event DefaultSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event LegacySignerSet(address indexed account, address signer, bytes32 role);\n  event LegacySignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event SignerRemoved(address indexed account, address oldSigner, bytes32 indexed role);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n  event OffchainStorageRootAdded(address indexed account, bytes url);\n  event OffchainStorageRootRemoved(address indexed account, bytes url, uint256 index);\n  event PaymentDelegationSet(address indexed beneficiary, uint256 fraction);\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return Storage version of the contract.\n   * @return Major version of the contract.\n   * @return Minor version of the contract.\n   * @return Patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 4, 1);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setEip712DomainSeparator();\n  }\n\n  /**\n   * @notice Sets the EIP712 domain separator for the Celo Accounts abstraction.\n   */\n  function setEip712DomainSeparator() public {\n    uint256 chainId;\n    assembly {\n      chainId := chainid\n    }\n\n    eip712DomainSeparator = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(\"Celo Core Contracts\")),\n        keccak256(\"1.0\"),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),\n      \"Account already exists or address is an authorized signer for another account\"\n    );\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Register with createAccount to set account name\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Adds a new CIP8 storage root.\n   * @param url The URL pointing to the offchain storage root.\n   */\n  function addStorageRoot(bytes calldata url) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    offchainStorageRoots[msg.sender].push(url);\n    emit OffchainStorageRootAdded(msg.sender, url);\n  }\n\n  /**\n   * @notice Removes a CIP8 storage root.\n   * @param index The index of the storage root to be removed in the account's\n   * list of storage roots.\n   * @dev The order of storage roots may change after this operation (the last\n   * storage root will be moved to `index`), be aware of this if removing\n   * multiple storage roots at a time.\n   */\n  function removeStorageRoot(uint256 index) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(index < offchainStorageRoots[msg.sender].length, \"Invalid storage root index\");\n    uint256 lastIndex = offchainStorageRoots[msg.sender].length - 1;\n    bytes memory url = offchainStorageRoots[msg.sender][index];\n    offchainStorageRoots[msg.sender][index] = offchainStorageRoots[msg.sender][lastIndex];\n    offchainStorageRoots[msg.sender].length--;\n    emit OffchainStorageRootRemoved(msg.sender, url, index);\n  }\n\n  /**\n   * @notice Returns the full list of offchain storage roots for an account.\n   * @param account The account whose storage roots to return.\n   * @return Concatenated storage root URLs.\n   * @return Lengths of storage root URLs.\n   */\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n  /**\n   * @notice Sets validator payment delegation settings.\n   * @param beneficiary The address that should receive a portion of validator\n   * payments.\n   * @param fraction The fraction of the validator's payment that should be\n   * diverted to `beneficiary` every epoch, given as FixidityLib value. Must not\n   * be greater than 1.\n   * @dev Use `deletePaymentDelegation` to unset the payment delegation.\n   */\n  function setPaymentDelegation(address beneficiary, uint256 fraction) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(beneficiary != address(0), \"Beneficiary cannot be address 0x0\");\n    FixidityLib.Fraction memory f = FixidityLib.wrap(fraction);\n    require(f.lte(FixidityLib.fixed1()), \"Fraction must not be greater than 1\");\n    paymentDelegations[msg.sender] = PaymentDelegation(beneficiary, f);\n    emit PaymentDelegationSet(beneficiary, fraction);\n  }\n\n  /**\n   * @notice Removes a validator's payment delegation by setting benficiary and\n   * fraction to 0.\n   */\n  function deletePaymentDelegation() public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    paymentDelegations[msg.sender] = PaymentDelegation(address(0x0), FixidityLib.wrap(0));\n    emit PaymentDelegationSet(address(0x0), 0);\n  }\n\n  /**\n   * @notice Gets validator payment delegation settings.\n   * @param account Account of the validator.\n   * @return Beneficiary address of payment delegated.\n   * @return Fraction of payment delegated.\n   */\n  function getPaymentDelegation(address account) external view returns (address, uint256) {\n    PaymentDelegation storage delegation = paymentDelegations[account];\n    return (delegation.beneficiary, delegation.fraction.unwrap());\n  }\n\n  /**\n   * @notice Set the indexed signer for a specific role\n   * @param signer the address to set as default\n   * @param role the role to register a default signer for\n   */\n  function setIndexedSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(isNotAccount(signer), \"Cannot authorize account as signer\");\n    require(\n      isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Not a signer for this account\"\n    );\n    require(isSigner(msg.sender, signer, role), \"Must authorize signer before setting as default\");\n\n    Account storage account = accounts[msg.sender];\n    if (isLegacyRole(role)) {\n      if (role == VoteSigner) {\n        account.signers.vote = signer;\n      } else if (role == AttestationSigner) {\n        account.signers.attestation = signer;\n      } else if (role == ValidatorSigner) {\n        account.signers.validator = signer;\n      }\n      emit LegacySignerSet(msg.sender, signer, role);\n    } else {\n      defaultSigners[msg.sender][role] = signer;\n      emit DefaultSignerSet(msg.sender, signer, role);\n    }\n\n    emit IndexedSignerSet(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to act as a signer, for `role`, on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s EIP712 signature over `role`, `msg.sender`\n   *      and `signer`.\n   */\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  function legacyAuthorizeSignerWithSignature(\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) private {\n    authorizeAddress(signer, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Begin the process of authorizing an address to sign on behalf of the account\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   */\n  function authorizeSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register sender with Account.createAccount\");\n    require(\n      isNotAccount(signer) && isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Cannot re-authorize address signer\"\n    );\n\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: false\n    });\n    emit SignerAuthorizationStarted(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Finish the process of authorizing an address to sign on behalf of the account.\n   * @param account The address of account that authorized signing.\n   * @param role The role to finish authorizing for.\n   */\n  function completeSignerAuthorization(address account, bytes32 role) public {\n    require(\n      isAccount(account),\n      \"Unknown Account: Address that authorized signing must be a registered Account\"\n    );\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSignerForAnotherAccount(account, msg.sender),\n      \"Cannot re-authorize address signer\"\n    );\n    require(\n      signerAuthorizations[account][role][msg.sender].started == true,\n      \"Signer authorization not started\"\n    );\n\n    authorizedBy[msg.sender] = account;\n    signerAuthorizations[account][role][msg.sender].completed = true;\n    emit SignerAuthorizationCompleted(account, msg.sender, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the legacy signer for role\n   * @param _account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isLegacySigner(address _account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    Account storage account = accounts[_account];\n    if (role == ValidatorSigner && account.signers.validator == signer) {\n      return true;\n    } else if (role == AttestationSigner && account.signers.attestation == signer) {\n      return true;\n    } else if (role == VoteSigner && account.signers.vote == signer) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the default signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isDefaultSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return defaultSigners[account][role] == signer;\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as an indexed signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isIndexedSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return\n      isLegacyRole(role)\n        ? isLegacySigner(account, signer, role)\n        : isDefaultSigner(account, signer, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as a signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isSigner(address account, address signer, bytes32 role) public view returns (bool) {\n    return\n      isLegacySigner(account, signer, role) ||\n      (signerAuthorizations[account][role][signer].completed && authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Removes the signer for a default role.\n   * @param role The role that has been authorized.\n   */\n  function removeDefaultSigner(bytes32 role) public {\n    address signer = defaultSigners[msg.sender][role];\n    defaultSigners[msg.sender][role] = address(0);\n    emit DefaultSignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Remove one of the Validator, Attestation or\n   * Vote signers from an account. Should only be called from\n   * methods that check the role is a legacy signer.\n   * @param role The role that has been authorized.\n   */\n  function removeLegacySigner(bytes32 role) private {\n    Account storage account = accounts[msg.sender];\n\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n      account.signers.validator = address(0);\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n      account.signers.attestation = address(0);\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n      account.signers.vote = address(0);\n    }\n    emit LegacySignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized and indexed signer\n   * for a specific role\n   * @param role The role of the signer.\n   */\n  function removeIndexedSigner(bytes32 role) public {\n    address oldSigner = getIndexedSigner(msg.sender, role);\n    isLegacyRole(role) ? removeLegacySigner(role) : removeDefaultSigner(role);\n\n    emit IndexedSignerRemoved(msg.sender, oldSigner, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized signer for a specific role and\n   * if the signer is indexed, remove that as well.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function removeSigner(address signer, bytes32 role) public {\n    if (isIndexedSigner(msg.sender, signer, role)) {\n      removeIndexedSigner(role);\n    }\n\n    delete signerAuthorizations[msg.sender][role][signer];\n    emit SignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized vote signer for the account.\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeVoteSigner() public {\n    address signer = getLegacySigner(msg.sender, VoteSigner);\n    removeSigner(signer, VoteSigner);\n    emit VoteSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized validator signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeValidatorSigner() public {\n    address signer = getLegacySigner(msg.sender, ValidatorSigner);\n    removeSigner(signer, ValidatorSigner);\n    emit ValidatorSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized attestation signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeAttestationSigner() public {\n    address signer = getLegacySigner(msg.sender, AttestationSigner);\n    removeSigner(signer, AttestationSigner);\n    emit AttestationSignerRemoved(msg.sender, signer);\n  }\n\n  function signerToAccountWithRole(address signer, bytes32 role) internal view returns (address) {\n    address account = authorizedBy[signer];\n    if (account != address(0)) {\n      require(isSigner(account, signer, role), \"not active authorized signer for role\");\n      return account;\n    }\n\n    require(isAccount(signer), \"Must first register address with Account.createAccount\");\n    return signer;\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account that the signer is authorized to attest for.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account that signer is authorized to validate for.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account that signer is authorized to vote for.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Checks whether the role is one of Vote, Validator or Attestation\n   * @param role The role to check\n   */\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n\n  /**\n   * @notice Returns the legacy signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param _account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n  /**\n   * @notice Returns the default signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n  /**\n   * @notice Returns the indexed signer for the specified account and role.\n   * If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for one of the legacy roles\n   */\n  function hasLegacySigner(address account, bytes32 role) public view returns (bool) {\n    return getLegacySigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for a role\n   */\n  function hasDefaultSigner(address account, bytes32 role) public view returns (bool) {\n    return getDefaultSigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for the role\n   */\n  function hasIndexedSigner(address account, bytes32 role) public view returns (bool) {\n    return isLegacyRole(role) ? hasLegacySigner(account, role) : hasDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Checks whether or not the account has a signer\n   * registered for the plaintext role.\n   * @dev See `hasIndexedSigner` for more gas efficient call.\n   */\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated vote signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated vote signer.\n   */\n  function hasAuthorizedVoteSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated validator signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated validator signer.\n   */\n  function hasAuthorizedValidatorSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated attestation signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated attestation signer.\n   */\n  function hasAuthorizedAttestationSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return The length of each string in bytes.\n   * @return All strings concatenated.\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has not been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Check if `signer` has not been authorized, and if it has been previously\n   *         authorized that it was authorized by `account`.\n   * @param account The authorizing account address.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSignerForAnotherAccount(address account, address signer)\n    internal\n    view\n    returns (bool)\n  {\n    return (authorizedBy[signer] == address(0) || authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Authorizes some role of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `authorized`'s signature on `msg.sender`.\n   */\n  function authorizeAddress(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Returns the address that signed the provided role authorization.\n   * @param account The `account` property signed over in the EIP712 signature\n   * @param signer The `signer` property signed over in the EIP712 signature\n   * @param role The `role` property signed over in the EIP712 signature\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The address that signed the provided role authorization.\n   */\n  function getRoleAuthorizationSigner(\n    address account,\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 structHash = keccak256(\n      abi.encode(EIP712_AUTHORIZE_SIGNER_TYPEHASH, account, signer, role)\n    );\n    return Signatures.getSignerOfTypedDataHash(eip712DomainSeparator, structHash, v, r, s);\n  }\n\n  /**\n   * @notice Authorizes a role of `msg.sender`'s account to another address (`authorized`).\n   * @param authorized The address to authorize.\n   * @param role The role to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that this signature is EIP712 compliant over the authorizing `account`\n   * (`msg.sender`), `signer` (`authorized`) and `role`.\n   */\n  function authorizeAddressWithRole(address authorized, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    private\n  {\n    address signer = getRoleAuthorizationSigner(msg.sender, authorized, role, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Authorizes an address to `msg.sender`'s account\n   * @param authorized The address to authorize.\n   * @dev Fails if the address is already authorized for another account or is an account itself.\n   */\n  function authorize(address authorized) private {\n    require(\n      isAccount(msg.sender),\n      \"Unknown account: sender must register with createAccount first\"\n    );\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSignerForAnotherAccount(msg.sender, authorized),\n      \"Cannot re-authorize address or locked gold account for another account\"\n    );\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}\n",
        "formal_property": "rule signerAuthorizationChangePrivileges(address a, bytes32 r, address s, method f) filtered { f ->\n\t!f.isView \n} {\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "signerAuthorizationChangePrivileges",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 373,
            "end_line": 375,
            "block_hash": "fc2037fab3bb72e010066e89e2162763"
        }
    },
    {
        "id": "Accounts_check_no_fallback_ca2a70b5",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./interfaces/IAccounts.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract Accounts is\n  IAccounts,\n  ICeloVersionedContract,\n  Ownable,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry\n{\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n\n  struct Signers {\n    // The address that is authorized to vote in governance and validator elections on behalf of the\n    // account. The account can vote as well, whether or not a vote signing key has been specified.\n    address vote;\n    // The address that is authorized to manage a validator or validator group and sign consensus\n    // messages on behalf of the account. The account can manage the validator, whether or not a\n    // validator signing key has been specified. However, if a validator signing key has been\n    // specified, only that key may actually participate in consensus.\n    address validator;\n    // The address of the key with which this account wants to sign attestations on the Attestations\n    // contract\n    address attestation;\n  }\n\n  struct SignerAuthorization {\n    bool started;\n    bool completed;\n  }\n\n  struct Account {\n    bool exists;\n    // [Deprecated] Each account may authorize signing keys to use for voting,\n    // validating or attestation. These keys may not be keys of other accounts,\n    // and may not be authorized by any other account for any purpose.\n    Signers signers;\n    // The address at which the account expects to receive transfers. If it's empty/0x0, the\n    // account indicates that an address exchange should be initiated with the dataEncryptionKey\n    address walletAddress;\n    // An optional human readable identifier for the account\n    string name;\n    // The ECDSA public key used to encrypt and decrypt data for this account\n    bytes dataEncryptionKey;\n    // The URL under which an account adds metadata and claims\n    string metadataURL;\n  }\n\n  struct PaymentDelegation {\n    // Address that should receive a fraction of validator payments.\n    address beneficiary;\n    // Fraction of payment to delegate to `beneficiary`.\n    FixidityLib.Fraction fraction;\n  }\n\n  mapping(address => Account) internal accounts;\n  // Maps authorized signers to the account that provided the authorization.\n  mapping(address => address) public authorizedBy;\n  // Default signers by account (replaces the legacy Signers struct on Account)\n  mapping(address => mapping(bytes32 => address)) defaultSigners;\n  // All signers and their roles for a given account\n  // solhint-disable-next-line max-line-length\n  mapping(address => mapping(bytes32 => mapping(address => SignerAuthorization))) signerAuthorizations;\n\n  bytes32 public constant EIP712_AUTHORIZE_SIGNER_TYPEHASH = keccak256(\n    \"AuthorizeSigner(address account,address signer,bytes32 role)\"\n  );\n  bytes32 public eip712DomainSeparator;\n\n  // A per-account list of CIP8 storage roots, bypassing CIP3.\n  mapping(address => bytes[]) public offchainStorageRoots;\n\n  // Optional per-account validator payment delegation information.\n  mapping(address => PaymentDelegation) internal paymentDelegations;\n\n  bytes32 constant ValidatorSigner = keccak256(abi.encodePacked(\"celo.org/core/validator\"));\n  bytes32 constant AttestationSigner = keccak256(abi.encodePacked(\"celo.org/core/attestation\"));\n  bytes32 constant VoteSigner = keccak256(abi.encodePacked(\"celo.org/core/vote\"));\n\n  event AttestationSignerAuthorized(address indexed account, address signer);\n  event VoteSignerAuthorized(address indexed account, address signer);\n  event ValidatorSignerAuthorized(address indexed account, address signer);\n  event SignerAuthorized(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationStarted(address indexed account, address signer, bytes32 indexed role);\n  event SignerAuthorizationCompleted(address indexed account, address signer, bytes32 indexed role);\n  event AttestationSignerRemoved(address indexed account, address oldSigner);\n  event VoteSignerRemoved(address indexed account, address oldSigner);\n  event ValidatorSignerRemoved(address indexed account, address oldSigner);\n  event IndexedSignerSet(address indexed account, address signer, bytes32 role);\n  event IndexedSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event DefaultSignerSet(address indexed account, address signer, bytes32 role);\n  event DefaultSignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event LegacySignerSet(address indexed account, address signer, bytes32 role);\n  event LegacySignerRemoved(address indexed account, address oldSigner, bytes32 role);\n  event SignerRemoved(address indexed account, address oldSigner, bytes32 indexed role);\n  event AccountDataEncryptionKeySet(address indexed account, bytes dataEncryptionKey);\n  event AccountNameSet(address indexed account, string name);\n  event AccountMetadataURLSet(address indexed account, string metadataURL);\n  event AccountWalletAddressSet(address indexed account, address walletAddress);\n  event AccountCreated(address indexed account);\n  event OffchainStorageRootAdded(address indexed account, bytes url);\n  event OffchainStorageRootRemoved(address indexed account, bytes url, uint256 index);\n  event PaymentDelegationSet(address indexed beneficiary, uint256 fraction);\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return Storage version of the contract.\n   * @return Major version of the contract.\n   * @return Minor version of the contract.\n   * @return Patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 4, 1);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   */\n  function initialize(address registryAddress) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setEip712DomainSeparator();\n  }\n\n  /**\n   * @notice Sets the EIP712 domain separator for the Celo Accounts abstraction.\n   */\n  function setEip712DomainSeparator() public {\n    uint256 chainId;\n    assembly {\n      chainId := chainid\n    }\n\n    eip712DomainSeparator = keccak256(\n      abi.encode(\n        keccak256(\n          \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        ),\n        keccak256(bytes(\"Celo Core Contracts\")),\n        keccak256(\"1.0\"),\n        chainId,\n        address(this)\n      )\n    );\n  }\n\n  /**\n   * @notice Convenience Setter for the dataEncryptionKey and wallet address for an account\n   * @param name A string to set as the name of the account\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setAccount(\n    string calldata name,\n    bytes calldata dataEncryptionKey,\n    address walletAddress,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external {\n    if (!isAccount(msg.sender)) {\n      createAccount();\n    }\n    setName(name);\n    setAccountDataEncryptionKey(dataEncryptionKey);\n    setWalletAddress(walletAddress, v, r, s);\n  }\n\n  /**\n   * @notice Creates an account.\n   * @return True if account creation succeeded.\n   */\n  function createAccount() public returns (bool) {\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSigner(msg.sender),\n      \"Account already exists or address is an authorized signer for another account\"\n    );\n    Account storage account = accounts[msg.sender];\n    account.exists = true;\n    emit AccountCreated(msg.sender);\n    return true;\n  }\n\n  /**\n   * @notice Setter for the name of an account.\n   * @param name The name to set.\n   */\n  function setName(string memory name) public {\n    require(isAccount(msg.sender), \"Register with createAccount to set account name\");\n    Account storage account = accounts[msg.sender];\n    account.name = name;\n    emit AccountNameSet(msg.sender, name);\n  }\n\n  /**\n   * @notice Setter for the wallet address for an account\n   * @param walletAddress The wallet address to set for the account\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Wallet address can be zero. This means that the owner of the wallet\n   *  does not want to be paid directly without interaction, and instead wants users to\n   * contact them, using the data encryption key, and arrange a payment.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender` (unless the wallet address\n   *      is 0x0 or msg.sender).\n   */\n  function setWalletAddress(address walletAddress, uint8 v, bytes32 r, bytes32 s) public {\n    require(isAccount(msg.sender), \"Unknown account\");\n    if (!(walletAddress == msg.sender || walletAddress == address(0x0))) {\n      address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n      require(signer == walletAddress, \"Invalid signature\");\n    }\n    Account storage account = accounts[msg.sender];\n    account.walletAddress = walletAddress;\n    emit AccountWalletAddressSet(msg.sender, walletAddress);\n  }\n\n  /**\n   * @notice Setter for the data encryption key and version.\n   * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function setAccountDataEncryptionKey(bytes memory dataEncryptionKey) public {\n    require(dataEncryptionKey.length >= 33, \"data encryption key length <= 32\");\n    Account storage account = accounts[msg.sender];\n    account.dataEncryptionKey = dataEncryptionKey;\n    emit AccountDataEncryptionKeySet(msg.sender, dataEncryptionKey);\n  }\n\n  /**\n   * @notice Setter for the metadata of an account.\n   * @param metadataURL The URL to access the metadata.\n   */\n  function setMetadataURL(string calldata metadataURL) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    Account storage account = accounts[msg.sender];\n    account.metadataURL = metadataURL;\n    emit AccountMetadataURLSet(msg.sender, metadataURL);\n  }\n\n  /**\n   * @notice Adds a new CIP8 storage root.\n   * @param url The URL pointing to the offchain storage root.\n   */\n  function addStorageRoot(bytes calldata url) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    offchainStorageRoots[msg.sender].push(url);\n    emit OffchainStorageRootAdded(msg.sender, url);\n  }\n\n  /**\n   * @notice Removes a CIP8 storage root.\n   * @param index The index of the storage root to be removed in the account's\n   * list of storage roots.\n   * @dev The order of storage roots may change after this operation (the last\n   * storage root will be moved to `index`), be aware of this if removing\n   * multiple storage roots at a time.\n   */\n  function removeStorageRoot(uint256 index) external {\n    require(isAccount(msg.sender), \"Unknown account\");\n    require(index < offchainStorageRoots[msg.sender].length, \"Invalid storage root index\");\n    uint256 lastIndex = offchainStorageRoots[msg.sender].length - 1;\n    bytes memory url = offchainStorageRoots[msg.sender][index];\n    offchainStorageRoots[msg.sender][index] = offchainStorageRoots[msg.sender][lastIndex];\n    offchainStorageRoots[msg.sender].length--;\n    emit OffchainStorageRootRemoved(msg.sender, url, index);\n  }\n\n  /**\n   * @notice Returns the full list of offchain storage roots for an account.\n   * @param account The account whose storage roots to return.\n   * @return Concatenated storage root URLs.\n   * @return Lengths of storage root URLs.\n   */\n  function getOffchainStorageRoots(address account)\n    external\n    view\n    returns (bytes memory, uint256[] memory)\n  {\n    require(isAccount(account), \"Unknown account\");\n    uint256 numberRoots = offchainStorageRoots[account].length;\n    uint256 totalLength = 0;\n    for (uint256 i = 0; i < numberRoots; i++) {\n      totalLength = totalLength.add(offchainStorageRoots[account][i].length);\n    }\n\n    bytes memory concatenated = new bytes(totalLength);\n    uint256 lastIndex = 0;\n    uint256[] memory lengths = new uint256[](numberRoots);\n    for (uint256 i = 0; i < numberRoots; i++) {\n      bytes storage root = offchainStorageRoots[account][i];\n      lengths[i] = root.length;\n      for (uint256 j = 0; j < lengths[i]; j++) {\n        concatenated[lastIndex] = root[j];\n        lastIndex++;\n      }\n    }\n\n    return (concatenated, lengths);\n  }\n\n  /**\n   * @notice Sets validator payment delegation settings.\n   * @param beneficiary The address that should receive a portion of validator\n   * payments.\n   * @param fraction The fraction of the validator's payment that should be\n   * diverted to `beneficiary` every epoch, given as FixidityLib value. Must not\n   * be greater than 1.\n   * @dev Use `deletePaymentDelegation` to unset the payment delegation.\n   */\n  function setPaymentDelegation(address beneficiary, uint256 fraction) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(beneficiary != address(0), \"Beneficiary cannot be address 0x0\");\n    FixidityLib.Fraction memory f = FixidityLib.wrap(fraction);\n    require(f.lte(FixidityLib.fixed1()), \"Fraction must not be greater than 1\");\n    paymentDelegations[msg.sender] = PaymentDelegation(beneficiary, f);\n    emit PaymentDelegationSet(beneficiary, fraction);\n  }\n\n  /**\n   * @notice Removes a validator's payment delegation by setting benficiary and\n   * fraction to 0.\n   */\n  function deletePaymentDelegation() public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    paymentDelegations[msg.sender] = PaymentDelegation(address(0x0), FixidityLib.wrap(0));\n    emit PaymentDelegationSet(address(0x0), 0);\n  }\n\n  /**\n   * @notice Gets validator payment delegation settings.\n   * @param account Account of the validator.\n   * @return Beneficiary address of payment delegated.\n   * @return Fraction of payment delegated.\n   */\n  function getPaymentDelegation(address account) external view returns (address, uint256) {\n    PaymentDelegation storage delegation = paymentDelegations[account];\n    return (delegation.beneficiary, delegation.fraction.unwrap());\n  }\n\n  /**\n   * @notice Set the indexed signer for a specific role\n   * @param signer the address to set as default\n   * @param role the role to register a default signer for\n   */\n  function setIndexedSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register address with Account.createAccount\");\n    require(isNotAccount(signer), \"Cannot authorize account as signer\");\n    require(\n      isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Not a signer for this account\"\n    );\n    require(isSigner(msg.sender, signer, role), \"Must authorize signer before setting as default\");\n\n    Account storage account = accounts[msg.sender];\n    if (isLegacyRole(role)) {\n      if (role == VoteSigner) {\n        account.signers.vote = signer;\n      } else if (role == AttestationSigner) {\n        account.signers.attestation = signer;\n      } else if (role == ValidatorSigner) {\n        account.signers.validator = signer;\n      }\n      emit LegacySignerSet(msg.sender, signer, role);\n    } else {\n      defaultSigners[msg.sender][role] = signer;\n      emit DefaultSignerSet(msg.sender, signer, role);\n    }\n\n    emit IndexedSignerSet(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to act as a signer, for `role`, on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s EIP712 signature over `role`, `msg.sender`\n   *      and `signer`.\n   */\n  function authorizeSignerWithSignature(address signer, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    public\n  {\n    authorizeAddressWithRole(signer, role, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  function legacyAuthorizeSignerWithSignature(\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) private {\n    authorizeAddress(signer, v, r, s);\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: true\n    });\n\n    emit SignerAuthorized(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Authorizes an address to sign votes on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeVoteSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, VoteSigner, v, r, s);\n    setIndexedSigner(signer, VoteSigner);\n\n    emit VoteSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSigner(address signer, uint8 v, bytes32 r, bytes32 s)\n    external\n    nonReentrant\n  {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(!getValidators().isValidator(msg.sender), \"Cannot authorize validator signer\");\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithPublicKey(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updateEcdsaPublicKey(msg.sender, signer, ecdsaPublicKey),\n      \"Failed to update ECDSA public key\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign consensus messages on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param ecdsaPublicKey The ECDSA public key corresponding to `signer`.\n   * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass\n   *   proof of possession. 96 bytes.\n   * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the\n   *   account address. 48 bytes.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeValidatorSignerWithKeys(\n    address signer,\n    uint8 v,\n    bytes32 r,\n    bytes32 s,\n    bytes calldata ecdsaPublicKey,\n    bytes calldata blsPublicKey,\n    bytes calldata blsPop\n  ) external nonReentrant {\n    legacyAuthorizeSignerWithSignature(signer, ValidatorSigner, v, r, s);\n    setIndexedSigner(signer, ValidatorSigner);\n\n    require(\n      getValidators().updatePublicKeys(msg.sender, signer, ecdsaPublicKey, blsPublicKey, blsPop),\n      \"Failed to update validator keys\"\n    );\n    emit ValidatorSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Authorizes an address to sign attestations on behalf of the account.\n   * @param signer The address of the signing key to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev v, r, s constitute `signer`'s signature on `msg.sender`.\n   */\n  function authorizeAttestationSigner(address signer, uint8 v, bytes32 r, bytes32 s) public {\n    legacyAuthorizeSignerWithSignature(signer, AttestationSigner, v, r, s);\n    setIndexedSigner(signer, AttestationSigner);\n\n    emit AttestationSignerAuthorized(msg.sender, signer);\n  }\n\n  /**\n   * @notice Begin the process of authorizing an address to sign on behalf of the account\n   * @param signer The address of the signing key to authorize.\n   * @param role The role to authorize signing for.\n   */\n  function authorizeSigner(address signer, bytes32 role) public {\n    require(isAccount(msg.sender), \"Must first register sender with Account.createAccount\");\n    require(\n      isNotAccount(signer) && isNotAuthorizedSignerForAnotherAccount(msg.sender, signer),\n      \"Cannot re-authorize address signer\"\n    );\n\n    signerAuthorizations[msg.sender][role][signer] = SignerAuthorization({\n      started: true,\n      completed: false\n    });\n    emit SignerAuthorizationStarted(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Finish the process of authorizing an address to sign on behalf of the account.\n   * @param account The address of account that authorized signing.\n   * @param role The role to finish authorizing for.\n   */\n  function completeSignerAuthorization(address account, bytes32 role) public {\n    require(\n      isAccount(account),\n      \"Unknown Account: Address that authorized signing must be a registered Account\"\n    );\n    require(\n      isNotAccount(msg.sender) && isNotAuthorizedSignerForAnotherAccount(account, msg.sender),\n      \"Cannot re-authorize address signer\"\n    );\n    require(\n      signerAuthorizations[account][role][msg.sender].started == true,\n      \"Signer authorization not started\"\n    );\n\n    authorizedBy[msg.sender] = account;\n    signerAuthorizations[account][role][msg.sender].completed = true;\n    emit SignerAuthorizationCompleted(account, msg.sender, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the legacy signer for role\n   * @param _account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isLegacySigner(address _account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    Account storage account = accounts[_account];\n    if (role == ValidatorSigner && account.signers.validator == signer) {\n      return true;\n    } else if (role == AttestationSigner && account.signers.attestation == signer) {\n      return true;\n    } else if (role == VoteSigner && account.signers.vote == signer) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as the default signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isDefaultSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return defaultSigners[account][role] == signer;\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as an indexed signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isIndexedSigner(address account, address signer, bytes32 role)\n    public\n    view\n    returns (bool)\n  {\n    return\n      isLegacyRole(role)\n        ? isLegacySigner(account, signer, role)\n        : isDefaultSigner(account, signer, role);\n  }\n\n  /**\n   * @notice Whether or not the signer has been registered as a signer for role\n   * @param account The address of account that authorized signing.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function isSigner(address account, address signer, bytes32 role) public view returns (bool) {\n    return\n      isLegacySigner(account, signer, role) ||\n      (signerAuthorizations[account][role][signer].completed && authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Removes the signer for a default role.\n   * @param role The role that has been authorized.\n   */\n  function removeDefaultSigner(bytes32 role) public {\n    address signer = defaultSigners[msg.sender][role];\n    defaultSigners[msg.sender][role] = address(0);\n    emit DefaultSignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Remove one of the Validator, Attestation or\n   * Vote signers from an account. Should only be called from\n   * methods that check the role is a legacy signer.\n   * @param role The role that has been authorized.\n   */\n  function removeLegacySigner(bytes32 role) private {\n    Account storage account = accounts[msg.sender];\n\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n      account.signers.validator = address(0);\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n      account.signers.attestation = address(0);\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n      account.signers.vote = address(0);\n    }\n    emit LegacySignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized and indexed signer\n   * for a specific role\n   * @param role The role of the signer.\n   */\n  function removeIndexedSigner(bytes32 role) public {\n    address oldSigner = getIndexedSigner(msg.sender, role);\n    isLegacyRole(role) ? removeLegacySigner(role) : removeDefaultSigner(role);\n\n    emit IndexedSignerRemoved(msg.sender, oldSigner, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized signer for a specific role and\n   * if the signer is indexed, remove that as well.\n   * @param signer The address of the signer.\n   * @param role The role that has been authorized.\n   */\n  function removeSigner(address signer, bytes32 role) public {\n    if (isIndexedSigner(msg.sender, signer, role)) {\n      removeIndexedSigner(role);\n    }\n\n    delete signerAuthorizations[msg.sender][role][signer];\n    emit SignerRemoved(msg.sender, signer, role);\n  }\n\n  /**\n   * @notice Removes the currently authorized vote signer for the account.\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeVoteSigner() public {\n    address signer = getLegacySigner(msg.sender, VoteSigner);\n    removeSigner(signer, VoteSigner);\n    emit VoteSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized validator signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeValidatorSigner() public {\n    address signer = getLegacySigner(msg.sender, ValidatorSigner);\n    removeSigner(signer, ValidatorSigner);\n    emit ValidatorSignerRemoved(msg.sender, signer);\n  }\n\n  /**\n   * @notice Removes the currently authorized attestation signer for the account\n   * Note that the signers cannot be reauthorized after they have been removed.\n   */\n  function removeAttestationSigner() public {\n    address signer = getLegacySigner(msg.sender, AttestationSigner);\n    removeSigner(signer, AttestationSigner);\n    emit AttestationSignerRemoved(msg.sender, signer);\n  }\n\n  function signerToAccountWithRole(address signer, bytes32 role) internal view returns (address) {\n    address account = authorizedBy[signer];\n    if (account != address(0)) {\n      require(isSigner(account, signer, role), \"not active authorized signer for role\");\n      return account;\n    }\n\n    require(isAccount(signer), \"Must first register address with Account.createAccount\");\n    return signer;\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized attestation signer.\n   * @dev Fails if the `signer` is not an account or currently authorized attestation signer.\n   * @return The associated account that the signer is authorized to attest for.\n   */\n  function attestationSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, AttestationSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of an account or currently authorized validator signer.\n   * @dev Fails if the `signer` is not an account or currently authorized validator.\n   * @return The associated account that signer is authorized to validate for.\n   */\n  function validatorSignerToAccount(address signer) public view returns (address) {\n    return signerToAccountWithRole(signer, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or currently authorized vote signer.\n   * @dev Fails if the `signer` is not an account or currently authorized vote signer.\n   * @return The associated account that signer is authorized to vote for.\n   */\n  function voteSignerToAccount(address signer) external view returns (address) {\n    return signerToAccountWithRole(signer, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the account associated with `signer`.\n   * @param signer The address of the account or previously authorized signer.\n   * @dev Fails if the `signer` is not an account or previously authorized signer.\n   * @return The associated account.\n   */\n  function signerToAccount(address signer) external view returns (address) {\n    address authorizingAccount = authorizedBy[signer];\n    if (authorizingAccount != address(0)) {\n      return authorizingAccount;\n    } else {\n      require(isAccount(signer), \"Must first register address with Account.createAccount\");\n      return signer;\n    }\n  }\n\n  /**\n   * @notice Checks whether the role is one of Vote, Validator or Attestation\n   * @param role The role to check\n   */\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n\n  /**\n   * @notice Returns the legacy signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param _account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n  /**\n   * @notice Returns the default signer for the specified account and\n   * role. If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n  /**\n   * @notice Returns the indexed signer for the specified account and role.\n   * If no signer has been specified it will return the account itself.\n   * @param account The address of the account.\n   * @param role The role of the signer.\n   */\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Returns the vote signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign votes.\n   */\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns the validator signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can register a validator or group.\n   */\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns the attestation signer for the specified account.\n   * @param account The address of the account.\n   * @return The address with which the account can sign attestations.\n   */\n  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for one of the legacy roles\n   */\n  function hasLegacySigner(address account, bytes32 role) public view returns (bool) {\n    return getLegacySigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for a role\n   */\n  function hasDefaultSigner(address account, bytes32 role) public view returns (bool) {\n    return getDefaultSigner(account, role) != account;\n  }\n\n  /**\n   * @notice Checks whether or not the account has an indexed signer\n   * registered for the role\n   */\n  function hasIndexedSigner(address account, bytes32 role) public view returns (bool) {\n    return isLegacyRole(role) ? hasLegacySigner(account, role) : hasDefaultSigner(account, role);\n  }\n\n  /**\n   * @notice Checks whether or not the account has a signer\n   * registered for the plaintext role.\n   * @dev See `hasIndexedSigner` for more gas efficient call.\n   */\n  function hasAuthorizedSigner(address account, string calldata role) external view returns (bool) {\n    return hasIndexedSigner(account, keccak256(abi.encodePacked(role)));\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated vote signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated vote signer.\n   */\n  function hasAuthorizedVoteSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, VoteSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated validator signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated validator signer.\n   */\n  function hasAuthorizedValidatorSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, ValidatorSigner);\n  }\n\n  /**\n   * @notice Returns if account has specified a dedicated attestation signer.\n   * @param account The address of the account.\n   * @return Whether the account has specified a dedicated attestation signer.\n   */\n  function hasAuthorizedAttestationSigner(address account) external view returns (bool) {\n    return hasLegacySigner(account, AttestationSigner);\n  }\n\n  /**\n   * @notice Getter for the name of an account.\n   * @param account The address of the account to get the name for.\n   * @return name The name of the account.\n   */\n  function getName(address account) external view returns (string memory) {\n    return accounts[account].name;\n  }\n\n  /**\n   * @notice Getter for the metadata of an account.\n   * @param account The address of the account to get the metadata for.\n   * @return metadataURL The URL to access the metadata.\n   */\n  function getMetadataURL(address account) external view returns (string memory) {\n    return accounts[account].metadataURL;\n  }\n\n  /**\n   * @notice Getter for the metadata of multiple accounts.\n   * @param accountsToQuery The addresses of the accounts to get the metadata for.\n   * @return The length of each string in bytes.\n   * @return All strings concatenated.\n   */\n  function batchGetMetadataURL(address[] calldata accountsToQuery)\n    external\n    view\n    returns (uint256[] memory, bytes memory)\n  {\n    uint256 totalSize = 0;\n    uint256[] memory sizes = new uint256[](accountsToQuery.length);\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      sizes[i] = bytes(accounts[accountsToQuery[i]].metadataURL).length;\n      totalSize = totalSize.add(sizes[i]);\n    }\n\n    bytes memory data = new bytes(totalSize);\n    uint256 pointer = 0;\n    for (uint256 i = 0; i < accountsToQuery.length; i = i.add(1)) {\n      for (uint256 j = 0; j < sizes[i]; j = j.add(1)) {\n        data[pointer] = bytes(accounts[accountsToQuery[i]].metadataURL)[j];\n        pointer = pointer.add(1);\n      }\n    }\n    return (sizes, data);\n  }\n\n  /**\n   * @notice Getter for the data encryption key and version.\n   * @param account The address of the account to get the key for\n   * @return dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.\n   */\n  function getDataEncryptionKey(address account) external view returns (bytes memory) {\n    return accounts[account].dataEncryptionKey;\n  }\n\n  /**\n   * @notice Getter for the wallet address for an account\n   * @param account The address of the account to get the wallet address for\n   * @return Wallet address\n   */\n  function getWalletAddress(address account) external view returns (address) {\n    return accounts[account].walletAddress;\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `true` if account exists. Returns `false` otherwise.\n   */\n  function isAccount(address account) public view returns (bool) {\n    return (accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an account already exists.\n   * @param account The address of the account\n   * @return Returns `false` if account exists. Returns `true` otherwise.\n   */\n  function isNotAccount(address account) internal view returns (bool) {\n    return (!accounts[account].exists);\n  }\n\n  /**\n   * @notice Check if an address has been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `true` if authorized. Returns `false` otherwise.\n   */\n  function isAuthorizedSigner(address signer) external view returns (bool) {\n    return (authorizedBy[signer] != address(0));\n  }\n\n  /**\n   * @notice Check if an address has not been an authorized signer for an account.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSigner(address signer) internal view returns (bool) {\n    return (authorizedBy[signer] == address(0));\n  }\n\n  /**\n   * @notice Check if `signer` has not been authorized, and if it has been previously\n   *         authorized that it was authorized by `account`.\n   * @param account The authorizing account address.\n   * @param signer The possibly authorized address.\n   * @return Returns `false` if authorized. Returns `true` otherwise.\n   */\n  function isNotAuthorizedSignerForAnotherAccount(address account, address signer)\n    internal\n    view\n    returns (bool)\n  {\n    return (authorizedBy[signer] == address(0) || authorizedBy[signer] == account);\n  }\n\n  /**\n   * @notice Authorizes some role of `msg.sender`'s account to another address.\n   * @param authorized The address to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that once an address is authorized, it may never be authorized again.\n   * @dev v, r, s constitute `authorized`'s signature on `msg.sender`.\n   */\n  function authorizeAddress(address authorized, uint8 v, bytes32 r, bytes32 s) private {\n    address signer = Signatures.getSignerOfAddress(msg.sender, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Returns the address that signed the provided role authorization.\n   * @param account The `account` property signed over in the EIP712 signature\n   * @param signer The `signer` property signed over in the EIP712 signature\n   * @param role The `role` property signed over in the EIP712 signature\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @return The address that signed the provided role authorization.\n   */\n  function getRoleAuthorizationSigner(\n    address account,\n    address signer,\n    bytes32 role,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public view returns (address) {\n    bytes32 structHash = keccak256(\n      abi.encode(EIP712_AUTHORIZE_SIGNER_TYPEHASH, account, signer, role)\n    );\n    return Signatures.getSignerOfTypedDataHash(eip712DomainSeparator, structHash, v, r, s);\n  }\n\n  /**\n   * @notice Authorizes a role of `msg.sender`'s account to another address (`authorized`).\n   * @param authorized The address to authorize.\n   * @param role The role to authorize.\n   * @param v The recovery id of the incoming ECDSA signature.\n   * @param r Output value r of the ECDSA signature.\n   * @param s Output value s of the ECDSA signature.\n   * @dev Fails if the address is already authorized to another account or is an account itself.\n   * @dev Note that this signature is EIP712 compliant over the authorizing `account`\n   * (`msg.sender`), `signer` (`authorized`) and `role`.\n   */\n  function authorizeAddressWithRole(address authorized, bytes32 role, uint8 v, bytes32 r, bytes32 s)\n    private\n  {\n    address signer = getRoleAuthorizationSigner(msg.sender, authorized, role, v, r, s);\n    require(signer == authorized, \"Invalid signature\");\n\n    authorize(authorized);\n  }\n\n  /**\n   * @notice Authorizes an address to `msg.sender`'s account\n   * @param authorized The address to authorize.\n   * @dev Fails if the address is already authorized for another account or is an account itself.\n   */\n  function authorize(address authorized) private {\n    require(\n      isAccount(msg.sender),\n      \"Unknown account: sender must register with createAccount first\"\n    );\n    require(\n      isNotAccount(authorized) && isNotAuthorizedSignerForAnotherAccount(msg.sender, authorized),\n      \"Cannot re-authorize address or locked gold account for another account\"\n    );\n\n    authorizedBy[authorized] = msg.sender;\n  }\n}\n",
        "formal_property": "rule check_no_fallback {\n\tenv e;\n\tcalldataarg arg;\n\tinvoke_fallback(e, arg);\n\n\tassert lastReverted;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "check_no_fallback",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 393,
            "end_line": 399,
            "block_hash": "ca2a70b5d86a46c4a5352abb31f48c68"
        }
    },
    {
        "id": "Accounts_gettersInAgreement_0a8cee60",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Accounts.sol",
        "target_function": "getAttestationSigner/getDefaultSigner/getIndexedSigner/getLegacySigner/getValidatorSigner/getVoteSigner/isLegacyRole",
        "text_chunk": "  function getAttestationSigner(address account) public view returns (address) {\n    return getLegacySigner(account, AttestationSigner);\n  }\n\n\n  function getDefaultSigner(address account, bytes32 role) public view returns (address) {\n    address defaultSigner = defaultSigners[account][role];\n    return defaultSigner == address(0) ? account : defaultSigner;\n  }\n\n\n  function getIndexedSigner(address account, bytes32 role) public view returns (address) {\n    return isLegacyRole(role) ? getLegacySigner(account, role) : getDefaultSigner(account, role);\n  }\n\n\n  function getLegacySigner(address _account, bytes32 role) public view returns (address) {\n    require(isLegacyRole(role), \"Role is not a legacy signer\");\n\n    Account storage account = accounts[_account];\n    address signer;\n    if (role == ValidatorSigner) {\n      signer = account.signers.validator;\n    } else if (role == AttestationSigner) {\n      signer = account.signers.attestation;\n    } else if (role == VoteSigner) {\n      signer = account.signers.vote;\n    }\n\n    return signer == address(0) ? _account : signer;\n  }\n\n\n  function getValidatorSigner(address account) public view returns (address) {\n    return getLegacySigner(account, ValidatorSigner);\n  }\n\n\n  function getVoteSigner(address account) public view returns (address) {\n    return getLegacySigner(account, VoteSigner);\n  }\n\n\n  function isLegacyRole(bytes32 role) public pure returns (bool) {\n    return role == VoteSigner || role == ValidatorSigner || role == AttestationSigner;\n  }\n",
        "formal_property": "rule gettersInAgreement() {\n\taddress account;\n\trequire account != 0;\n\tbytes32 role;\n\taddress indexedSigner = getIndexedSigner(account, role);\n\taddress defaultSigner = getDefaultSigner(account, role);\n\taddress legacySigner = getLegacySigner(account, role);\n\taddress voteSigner = getVoteSigner(account);\n\taddress validatorSigner = getValidatorSigner(account);\n\taddress attestationSigner = getAttestationSigner(account);\n\n\tif (role == _getVoteRole()) {\n\t\tassert indexedSigner == legacySigner && indexedSigner == voteSigner, \"indexed signer agrees with legacy signer for vote role\";\n\t} else if (role == _getValidatorRole()) {\n\t\tassert indexedSigner == legacySigner && indexedSigner == validatorSigner, \"indexed signer agrees with legacy signer for validator role\";\n\t} else if (role == _getAttestationRole()) {\n\t\tassert indexedSigner == legacySigner && indexedSigner == attestationSigner, \"indexed signer agrees with legacy signer for attestation role\";\n\t} else {\n\t\tassert indexedSigner == defaultSigner, \"for any non legacy role indexed signer is default signer\";\n\t}\n\tassert indexedSigner != 0 && defaultSigner != 0 && legacySigner != 0 \n\t\t&& voteSigner != 0 && validatorSigner != 0 && attestationSigner != 0, \"signer is never address 0\";\n\t// original assertion is wrong\n\t//assert indexedSigner != account => defaultSigner != account, \"If indexed signer is a distinct address then default signer for this role is also a distinct address\";\n\tassert !isLegacyRole(role) && indexedSigner != account => defaultSigner != account, \"If indexed signer is a distinct address then default signer for this role is also a distinct address\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "gettersInAgreement",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "getAttestationSigner",
                "getVoteSigner",
                "getValidatorSigner",
                "getDefaultSigner",
                "getLegacySigner",
                "isLegacyRole",
                "_getValidatorRole",
                "_getAttestationRole",
                "_getVoteRole",
                "getIndexedSigner"
            ],
            "start_line": 404,
            "end_line": 431,
            "block_hash": "0a8cee60da56f4e00a1132ab0ddc7d93"
        }
    }
]