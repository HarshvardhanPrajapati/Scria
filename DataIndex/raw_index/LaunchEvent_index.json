[
    {
        "id": "LaunchEvent_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "owner",
                "initialize",
                "currentPhase",
                "depositAVAX",
                "withdrawAVAX",
                "createPair",
                "withdrawLiquidity",
                "withdrawIncentives",
                "emergencyWithdraw",
                "allowEmergencyWithdraw",
                "skim",
                "getPenalty",
                "getIncentives",
                "getReserves",
                "getRJoeAmount",
                "pairBalance",
                "_atPhase",
                "_timelockElapsed",
                "_isStopped",
                "_safeTransferAVAX"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "LaunchEvent_factoryGetPairCorrelationCurrentVals",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "initialize",
        "text_chunk": "function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }",
        "formal_property": "invariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);",
        "nl_summary": "",
        "metadata": {
            "rule_name": "factoryGetPairCorrelationCurrentVals",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_factoryGetPairCorrelationNewVals",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "initialize",
        "text_chunk": "function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }",
        "formal_property": "invariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n    {\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            require token == _token;",
        "nl_summary": "",
        "metadata": {
            "rule_name": "factoryGetPairCorrelationNewVals",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_pairAndGetPairCorrelation",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "pairAndGetPairCorrelation",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_noIssuerForNonInitialized",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowemergencywithdraw/emergencywithdraw",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant noIssuerForNonInitialized()\n    !initialized() => issuer() == 0\n\n// STATUS - verified\ninvariant noAllocationIfNonInitialized(address user)\n    !initialized() => getUserAllocation(user) == 0\n\n// STATUS - verified\ninvariant noBalanceIfNonInitialized(address user)\n    !initialized() => getUserBalance(user) == 0\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/f186e56361246ec8fd72/?anonymousKey=f862b3d27b1ace55116959f9788d3e2a6e5d56c1\ninvariant notStoppedIfNonInitialized()\n    !initialized() => !stopped()\n\n// STATUS - \ninvariant noAuctionStartIfNonInitialized()\n    !initialized() => auctionStart() == 0\n\n\n\n// ALWAYS\n\n\n// STATUS - verified\n// - getUI[issuer].allocation == 0\ninvariant al_issuer_allocation_zero(address user)\n    getUserAllocation(issuer()) == 0\n    {\n        preserved{\n            requireInvariant isInitialized();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "noIssuerForNonInitialized",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_al_balance_less_than_allocation",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant al_balance_less_than_allocation(address user)\n    getUserBalance(user) <= getUserAllocation(user) \n\n\n// STATUS - verified\n// - getUI[user].allocation <= maxAllocation\ninvariant al_userAllocation_less_than_maxAllocation(address user)\n    getUserAllocation(user) <= maxAllocation()\n    {\n        preserved{\n            requireInvariant isInitialized();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "al_balance_less_than_allocation",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_al_differentTokenAndWavaxAddresses",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "initialize",
        "text_chunk": "function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }",
        "formal_property": "invariant al_differentTokenAndWavaxAddresses(address user)\n    WAVAX() != token()\n    {\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            require getNewWAVAX() != _token;",
        "nl_summary": "",
        "metadata": {
            "rule_name": "al_differentTokenAndWavaxAddresses",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_isInitialized",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowemergencywithdraw/emergencywithdraw",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant isInitialized()\n    initialized()\n\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n    {\n        preserved{\n            requireInvariant notStoppedIfNonInitialized();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "isInitialized",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_initIssuerTimelockNonZero",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant initIssuerTimelockNonZero()\n    initialized() => issuerTimelock() >= 1\n\n\n// STATUS - verified\n// - `userTimelock` <= 7 days\ninvariant initUserTimelockSeven()\n    initialized() => userTimelock() <= sevenDays()\n\n\n// STATUS - verified\n// - `auctionStart` > block.timestamp\ninvariant initAuctionStart(env e)\n    initialized() => auctionStart() > e.block.timestamp\n    {\n        preserved with (env e2){\n            require e.block.timestamp == e2.block.timestamp;",
        "nl_summary": "",
        "metadata": {
            "rule_name": "initIssuerTimelockNonZero",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_initPhaseTimesSet",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "createpair",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant initPhaseTimesSet()\n    initialized() => ( PHASE_ONE_DURATION() == twoDays()\n            && PHASE_ONE_NO_FEE_DURATION() == oneDay() && PHASE_TWO_DURATION() == oneDay())\n\n\n// STATUS - verified\n//  - `issuerTimelock` > `userTimelock`\ninvariant initTimelocksCorrelation()\n    initialized() => issuerTimelock() > userTimelock()\n\n\n// STATUS - verified (with invariant that is not finished and with Phases, otherwise createPair() causes a violation(violation as below))\n// run: https://vaas-stg.certora.com/output/3106/2ae7324af16683029e39/?anonymousKey=7202818cb360a87ab732a0ccdd7b9b3fa8c34f50\n// - `tokenIncentivesForUsers` == `tokenIncentivesBalance`\ninvariant initIncentivesCorrelation()\n    initialized() => tokenIncentivesForUsers() == tokenIncentivesBalance()\n    {\n        preserved with (env e2){\n            requireInvariant initNotStopped();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "initPhaseTimesSet",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_initTokenBalanceCheck",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant initTokenBalanceCheck()\n    initialized() =>  tokenReserve() + tokenIncentivesForUsers() == getTokenBalanceOfThis()\n    {\n        preserved with (env e2){\n            requireInvariant initNotStopped();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "initTokenBalanceCheck",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_op_not_stopped",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowemergencywithdraw/createpair/emergencywithdraw",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant op_not_stopped()\n    pair() == 0 => !stopped()\n        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug\n\n\n// STATUS - verified\n// open implies user has not withdrawn\ninvariant op_user_not_withdrawn_pair(address user)\n    pair() == 0 => !userHasWithdrawnPair(user)\n\n\n// STATUS - verified\n// open implies user has not withdrawn\ninvariant op_user_not_withdrawn_incentives(address user)\n    pair() == 0 => !userHasWithdrawnIncentives(user)\n\n\n// STATUS - in progress\n// run: https://vaas-stg.certora.com/output/3106/4287810baacbcf95e993/?anonymousKey=e85517e16f5d7a8c2f2d68cde1b47c6a618e1d00\n// state after createPair() is out of the scope of open state\n//  - `WAVAX.balanceOf(LaunchEvent)` == \u03a3 getUI[user].balance\ninvariant opWavaxBalanceAndSumBalances()\n    pair() == 0 => getWAVAXbalanceOfThis() == sum_of_users_balances()\n    {\n        preserved{\n            requireInvariant op_not_stopped();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_not_stopped",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_opWavaxBalanceAndWavaxReserve",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant opWavaxBalanceAndWavaxReserve()\n    pair() == 0 => getWAVAXbalanceOfThis() == avaxReserve()\n    {\n        preserved{\n            requireInvariant op_not_stopped();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "opWavaxBalanceAndWavaxReserve",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_opTokenBalanceCheck",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant opTokenBalanceCheck()\n    pair() == 0 =>  tokenReserve() + tokenIncentivesForUsers() == getTokenBalanceOfThis()\n    {\n        preserved with (env e2){\n            requireInvariant op_not_stopped();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "opTokenBalanceCheck",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_op_avax_alloc_zero",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "createpair",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant op_avax_alloc_zero()\n    pair() == 0 => avaxAllocated() == 0\n\n\n// STATUS - verified\n//  - lpSupply is 0\ninvariant op_lp_supply_zero()\n    pair() == 0 => lpSupply() == 0\n\n\n// STATUS - verified\n// createPair() violates the property: https://vaas-stg.certora.com/output/3106/6453fa43e1396eb864ad/?anonymousKey=c6322b9a791cdbea942221268091c2c963405500\n// - pair.balanceOf(address(this)) == 0\ninvariant opPairBalanceIsZero()\n    pair() == 0 => getPairBalanceOfThis() == 0\n    {\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_avax_alloc_zero",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_opPairAndTotalSupplyCorrelation",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant opPairAndTotalSupplyCorrelation()\n    pair() == 0 => getPairTotalSupply() == 0\n    {\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);",
        "nl_summary": "",
        "metadata": {
            "rule_name": "opPairAndTotalSupplyCorrelation",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_op_avax_reserve_sum_user_balances",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowemergencywithdraw/emergencywithdraw",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant op_avax_reserve_sum_user_balances()\n     pair() == 0 => avaxReserve() == sum_of_users_balances()\n\n\n\n// CLOSED - phase three\n\n\n// STATUS - in progress (allowEmergencyWithdraw() violation): https://vaas-stg.certora.com/output/3106/eca7dbb4b69c55f85043/?anonymousKey=44a9e39a1f83b15ab36662ee6d898cf1e147e43f\n//  - isStopped is false\ninvariant cl_not_stopped()\n    pair() != 0 => !stopped()\n\n\n// STATUS - verified https://vaas-stg.certora.com/output/3106/0ec29a324e7bdb9f86d2/?anonymousKey=deab759d00c63862d1166abb8a17b91ac040118b\n// run without preserved block: https://vaas-stg.certora.com/output/3106/cea4890e65f85e6d14eb/?anonymousKey=94c143aa0c1c85f0f961d154a6e60dafea974945\n// run with preserved block: https://vaas-stg.certora.com/output/3106/8863dca9bb0617161eb3/?anonymousKey=14fee042e6c8821f002886c4e7e0861ca072990c\n//  - avaxAllocated is \u03a3 getUA[user].balance\ninvariant cl_avax_alloc_sum_user_balances()\n    pair() != 0 => avaxAllocated() == sum_of_users_balances()\n    {\n        preserved with (env e2){\n            requireInvariant cl_not_stopped();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_avax_reserve_sum_user_balances",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_clWavaxCorrelation",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant clWavaxCorrelation(env e)\n    pair() != 0 => (getWAVAXbalanceOfThis() == avaxReserve() && avaxReserve() == 0)\n    {\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);",
        "nl_summary": "",
        "metadata": {
            "rule_name": "clWavaxCorrelation",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_cl_pair_bal_eq_lp_sum",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant cl_pair_bal_eq_lp_sum()\n    pair() != 0 => (getPairBalanceOfThis() == lpSupply() / 2 + unwithdrawn_users_lp_tokens)\n    {\n        preserved with (env e2){\n            requireInvariant cl_not_stopped();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_pair_bal_eq_lp_sum",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_cl_token_bal_eq_res_token",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "createpair",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant cl_token_bal_eq_res_token()\n    false\n\n\n// STATUS - in progress\n// run without preserved block: https://vaas-stg.certora.com/output/3106/e832cf49cb8c6eb0316a/?anonymousKey=d3e00feecadb1665fc4caf61d0f15b2c60f38459\n// run with preserved block (createPair() issue, pre-state pair() == 0 thus we can call this function): https://vaas-stg.certora.com/output/3106/b96d1d489077c95dc026/?anonymousKey=3c4fe014e274f60b7ccc58c12a3b91b558a3e632\n// - `tokenIncentivesBalance` <= `tokenIncentivesForUsers`\ninvariant clIncentivesCorrelation()\n    pair() != 0 => (tokenIncentivesBalance() <= tokenIncentivesForUsers())\n    {\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_token_bal_eq_res_token",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_cl_nonzero_user_pair_bal",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "pairbalance",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant cl_nonzero_user_pair_bal(address user, env e)\n    pair() != 0 => (!userHasWithdrawnPair(user) <=> pairBalance(e, user) != 0)\n    {\n        preserved with (env e2){\n            requireInvariant cl_not_stopped();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_nonzero_user_pair_bal",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_cl_bal_this_zero",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "currentphase",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant cl_bal_this_zero()\n    pair() != 0 => getWAVAXbalanceOfThis() == 0\n    {\n        preserved with (env e2){\n            require currentPhase(e2) == PhaseThree();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_bal_this_zero",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_cl_wavaxNotZero",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "pairbalance",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant cl_wavaxNotZero()\n//     pair() != 0 => avaxAllocated() > 0\n\n// STATUS - in progress (maybe add userHasWithdrawnPair(issuer()) => tokenReserve() == 0) - does => <=> make sense?\n// run without preserved block: https://vaas-stg.certora.com/output/3106/b0f4853713af2301edcb/?anonymousKey=ea101ebc4801f04d91fddc5053dd7f37425a8089\n// run with preserved block: \n// - hasWithdrawnPair and LP token balance of user are related\n// invariant cl_hasWithdrawnPair_and_pairBalance_Correlation(env e, address user)\n//     pair() != 0 => (userHasWithdrawnPair(user) <=> getPairBalance(user) == pairBalance(e, user))\n//     {\n//         preserved{\n//             requireInvariant cl_wavaxNotZero();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_wavaxNotZero",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_hl_EqualityOfPairs",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "pairbalance",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant hl_EqualityOfPairs()\n    getPairBalanceOfThis() == getPairBalance(issuer()) + sumOfPairBalances()\n\n\n// STATUS - in progress\n// run without preserved block: https://vaas-stg.certora.com/output/3106/1f91c36ac4e4424e389f/?anonymousKey=c30c7ee9fd1cb8fe7198145cf50a5e0959f623e4\n// run with preserved block: \ninvariant hl_EqualityOfPairAndTotalSupply()\n    getPairBalanceOfThis() == getPairTotalSupplyOfThis()\n\n\n// STATUS - in progress\n// run without preserved block: https://vaas-stg.certora.com/output/3106/23f2a4a600d0a020f0cb/?anonymousKey=d1d4fef9e201e201fd039a0dd0ddc1ea5306c9d7\n// run with preserved block: https://vaas-stg.certora.com/output/3106/9a888396ade18f00c01a/?anonymousKey=a7cdb01cf4b007d42ee8c2eb885757bfeebef6e6\ninvariant hl_TotalSupplyEquality()\n    getPairTotalSupply() == getPairTotalSupplyOfThis()\n    {\n        preserved with (env e2){\n            requireInvariant factoryGetPairCorrelationCurrentVals(e2);",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_EqualityOfPairs",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "LaunchEvent_hl_EqualityOfToken",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant hl_EqualityOfToken(env e) \n    getTokenBalanceOfThis() == tokenReserve() + tokenIncentivesBalance()\n    {\n        preserved with (env e2){\n            require token() == SymbERC20A || token() == SymbERC20B;",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_EqualityOfToken",
            "rule_type": "INVARIANT"
        }
    }
]