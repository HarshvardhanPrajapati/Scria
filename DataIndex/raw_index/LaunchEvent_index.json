[
    {
        "id": "LaunchEvent_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "owner",
                "is",
                "currentPhase",
                "depositAVAX",
                "withdrawAVAX",
                "createPair",
                "withdrawLiquidity",
                "withdrawIncentives",
                "emergencyWithdraw",
                "allowEmergencyWithdraw",
                "skim",
                "getPenalty",
                "getIncentives",
                "getReserves",
                "getRJoeAmount",
                "pairBalance",
                "_atPhase",
                "_timelockElapsed",
                "_isStopped",
                "_safeTransferAVAX"
            ],
            "state_variables": [
                "floorPrice",
                "phaseOneNoFeeDuration",
                "rJoe",
                "tokenIncentivesBalance",
                "tokenAllocated",
                "avaxAllocated",
                "tokenIncentivesForUsers",
                "maxAllocation",
                "hasWithdrawnPair",
                "hasWithdrawnIncentives",
                "tokenIncentivesPercent",
                "pair",
                "tokenIncentiveIssuerRefund",
                "balance",
                "rJoeNeeded",
                "issuerTimelock",
                "fixedWithdrawPenalty",
                "getUserInfo",
                "phaseTwoDuration",
                "rJoePerAvax",
                "phaseOneDuration",
                "tokenReserve",
                "WAVAX",
                "auctionStart",
                "stopped",
                "rocketJoeFactory",
                "avaxReserve",
                "factory",
                "issuer",
                "token",
                "router",
                "lpSupply",
                "userTimelock",
                "maxWithdrawPenalty",
                "allocation"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "LaunchEvent_factoryGetPairCorrelationCurrentVals_64223241",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "factoryGetPairCorrelationCurrentVals",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "initialize",
                "issuer",
                "auctionStart",
                "tokenIncentivesPercent",
                "floorPrice",
                "userTimelock",
                "issuerTimelock",
                "maxWithdrawPenalty",
                "fixedWithdrawPenalty",
                "maxAllocation",
                "WAVAX",
                "token"
            ],
            "start_line": 153,
            "end_line": 160,
            "block_hash": "642232410a15b85048f54fb60583fa8c"
        }
    },
    {
        "id": "LaunchEvent_factoryGetPairCorrelationNewVals_ccaea0db",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n    {\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            require token == _token;\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "factoryGetPairCorrelationNewVals",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "initialize",
                "issuer",
                "auctionStart",
                "tokenIncentivesPercent",
                "floorPrice",
                "userTimelock",
                "issuerTimelock",
                "maxWithdrawPenalty",
                "fixedWithdrawPenalty",
                "maxAllocation",
                "WAVAX",
                "token",
                "getNewWAVAX"
            ],
            "start_line": 165,
            "end_line": 172,
            "block_hash": "ccaea0dbb2b7bf6626cbb50e9a1bf8c3"
        }
    },
    {
        "id": "LaunchEvent_pairAndGetPairCorrelation_9dc208c2",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "invariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "pairAndGetPairCorrelation",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "WAVAX",
                "token",
                "pair"
            ],
            "start_line": 178,
            "end_line": 185,
            "block_hash": "9dc208c2e364514c9c9ddb0df11a6ac3"
        }
    },
    {
        "id": "LaunchEvent_noIssuerForNonInitialized_8692606f",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "invariant noIssuerForNonInitialized()\n    !initialized() => issuer() == 0\n\n// STATUS - verified\ninvariant noAllocationIfNonInitialized(address user)\n    !initialized() => getUserAllocation(user) == 0\ninvariant noBalanceIfNonInitialized(address user)\n    !initialized() => getUserBalance(user) == 0\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/f186e56361246ec8fd72/?anonymousKey=f862b3d27b1ace55116959f9788d3e2a6e5d56c1\ninvariant notStoppedIfNonInitialized()\n    !initialized() => !stopped()\n// STATUS - \ninvariant noAuctionStartIfNonInitialized()\n    !initialized() => auctionStart() == 0\n// ALWAYS\n// - getUI[issuer].allocation == 0\ninvariant al_issuer_allocation_zero(address user)\n    getUserAllocation(issuer()) == 0\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "noIssuerForNonInitialized",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "allowEmergencyWithdraw",
                "issuer",
                "auctionStart",
                "initialized",
                "stopped",
                "getUserAllocation",
                "getUserBalance"
            ],
            "start_line": 192,
            "end_line": 224,
            "block_hash": "8692606ff9ec1e46edfb071b037d2522"
        }
    },
    {
        "id": "LaunchEvent_al_balance_less_than_allocation_7ba3bfd6",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "invariant al_balance_less_than_allocation(address user)\n    getUserBalance(user) <= getUserAllocation(user) \n\n// STATUS - verified\n// - getUI[user].allocation <= maxAllocation\ninvariant al_userAllocation_less_than_maxAllocation(address user)\n    getUserAllocation(user) <= maxAllocation()\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "al_balance_less_than_allocation",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "maxAllocation",
                "getUserAllocation",
                "getUserBalance"
            ],
            "start_line": 229,
            "end_line": 241,
            "block_hash": "7ba3bfd6fad4021c8e1951432bf402b2"
        }
    },
    {
        "id": "LaunchEvent_al_differentTokenAndWavaxAddresses_8b34ea20",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant al_differentTokenAndWavaxAddresses(address user)\n    WAVAX() != token()\n    {\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            require getNewWAVAX() != _token;\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "al_differentTokenAndWavaxAddresses",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "initialize",
                "issuer",
                "auctionStart",
                "tokenIncentivesPercent",
                "floorPrice",
                "userTimelock",
                "issuerTimelock",
                "maxWithdrawPenalty",
                "fixedWithdrawPenalty",
                "maxAllocation",
                "WAVAX",
                "token",
                "getNewWAVAX"
            ],
            "start_line": 246,
            "end_line": 253,
            "block_hash": "8b34ea20ba4f4d035ddfcda97eee55f2"
        }
    },
    {
        "id": "LaunchEvent_isInitialized_7b6f6346",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "invariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n    {\n        preserved{\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "isInitialized",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "allowEmergencyWithdraw",
                "initialized",
                "stopped"
            ],
            "start_line": 260,
            "end_line": 272,
            "block_hash": "7b6f6346796e139319f1ea722eba87b9"
        }
    },
    {
        "id": "LaunchEvent_initIssuerTimelockNonZero_ccf1c620",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "invariant initIssuerTimelockNonZero()\n    initialized() => issuerTimelock() >= 1\n\n// STATUS - verified\n// - `userTimelock` <= 7 days\ninvariant initUserTimelockSeven()\n    initialized() => userTimelock() <= sevenDays()\n// - `auctionStart` > block.timestamp\ninvariant initAuctionStart(env e)\n    initialized() => auctionStart() > e.block.timestamp\n    {\n        preserved with (env e2){\n            require e.block.timestamp == e2.block.timestamp;\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "initIssuerTimelockNonZero",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "initialize",
                "issuer",
                "auctionStart",
                "userTimelock",
                "issuerTimelock",
                "initialized"
            ],
            "start_line": 277,
            "end_line": 295,
            "block_hash": "ccf1c620d15b2d1be4c10be2a8988fdf"
        }
    },
    {
        "id": "LaunchEvent_initPhaseTimesSet_635fe93a",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "createPair/currentPhase",
        "text_chunk": "    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n",
        "formal_property": "invariant initPhaseTimesSet()\n    initialized() => ( PHASE_ONE_DURATION() == twoDays()\n            && PHASE_ONE_NO_FEE_DURATION() == oneDay() && PHASE_TWO_DURATION() == oneDay())\n\n// STATUS - verified\n//  - `issuerTimelock` > `userTimelock`\ninvariant initTimelocksCorrelation()\n    initialized() => issuerTimelock() > userTimelock()\n// STATUS - verified (with invariant that is not finished and with Phases, otherwise createPair() causes a violation(violation as below))\n// run: https://vaas-stg.certora.com/output/3106/2ae7324af16683029e39/?anonymousKey=7202818cb360a87ab732a0ccdd7b9b3fa8c34f50\n// - `tokenIncentivesForUsers` == `tokenIncentivesBalance`\ninvariant initIncentivesCorrelation()\n    initialized() => tokenIncentivesForUsers() == tokenIncentivesBalance()\n    {\n        preserved with (env e2){\n            requireInvariant initNotStopped();\n            require pair() == 0;\n            require currentPhase(e2) == NotStarted();\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "initPhaseTimesSet",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "currentPhase",
                "createPair",
                "issuer",
                "PHASE_ONE_DURATION",
                "PHASE_ONE_NO_FEE_DURATION",
                "PHASE_TWO_DURATION",
                "userTimelock",
                "issuerTimelock",
                "initialized",
                "token",
                "pair",
                "tokenIncentivesBalance",
                "tokenIncentivesForUsers"
            ],
            "start_line": 301,
            "end_line": 323,
            "block_hash": "635fe93a83757347201743ed6c0c56d0"
        }
    },
    {
        "id": "LaunchEvent_initTokenBalanceCheck_3c36c8b0",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "is",
        "text_chunk": "    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n",
        "formal_property": "invariant initTokenBalanceCheck()\n    initialized() =>  tokenReserve() + tokenIncentivesForUsers() == getTokenBalanceOfThis()\n    {\n        preserved with (env e2){\n            requireInvariant initNotStopped();\n            require pair() == 0;\n            require token() == SymbERC20A || token() == SymbERC20B;\n            requireInvariant initIncentivesCorrelation();\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "initTokenBalanceCheck",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "initialized",
                "token",
                "pair",
                "tokenIncentivesForUsers",
                "tokenReserve",
                "getTokenBalanceOfThis",
                "getTokenBalance"
            ],
            "start_line": 332,
            "end_line": 341,
            "block_hash": "3c36c8b0877f1af3d4caad81a7e42455"
        }
    },
    {
        "id": "LaunchEvent_op_not_stopped_dfff86c7",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "invariant op_not_stopped()\n    pair() == 0 => !stopped()\n        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_not_stopped",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "allowEmergencyWithdraw",
                "stopped",
                "pair"
            ],
            "start_line": 351,
            "end_line": 353,
            "block_hash": "dfff86c75c74615572d76fde002bcd55"
        }
    },
    {
        "id": "LaunchEvent_op_user_not_withdrawn_pair_e8cceb2d",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/emergencyWithdraw/is",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n",
        "formal_property": "invariant op_user_not_withdrawn_pair(address user)\n    pair() == 0 => !userHasWithdrawnPair(user)\n\n// STATUS - verified\n// open implies user has not withdrawn\ninvariant op_user_not_withdrawn_incentives(address user)\n    pair() == 0 => !userHasWithdrawnIncentives(user)\n// STATUS - in progress\n// run: https://vaas-stg.certora.com/output/3106/4287810baacbcf95e993/?anonymousKey=e85517e16f5d7a8c2f2d68cde1b47c6a618e1d00\n// state after createPair() is out of the scope of open state\n//  - `WAVAX.balanceOf(LaunchEvent)` ==  getUI[user].balance\ninvariant opWavaxBalanceAndSumBalances()\n    pair() == 0 => getWAVAXbalanceOfThis() == sum_of_users_balances()\n    {\n        preserved{\n            requireInvariant op_not_stopped();                      // double check\ninvariant op_not_stopped()\n    pair() == 0 => !stopped()\n        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug\n            requireInvariant opWavaxBalanceAndWavaxReserve();\ninvariant opWavaxBalanceAndWavaxReserve()\n    pair() == 0 => getWAVAXbalanceOfThis() == avaxReserve()\n            requireInvariant op_not_stopped();\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_user_not_withdrawn_pair",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "createPair",
                "stopped",
                "WAVAX",
                "pair",
                "avaxReserve",
                "userHasWithdrawnPair",
                "userHasWithdrawnIncentives",
                "getWAVAXbalanceOfThis"
            ],
            "start_line": 358,
            "end_line": 379,
            "block_hash": "e8cceb2d256b2852dc895dd415cb9f65"
        }
    },
    {
        "id": "LaunchEvent_opWavaxBalanceAndWavaxReserve_96264217",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw/is",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n",
        "formal_property": "invariant opWavaxBalanceAndWavaxReserve()\n    pair() == 0 => getWAVAXbalanceOfThis() == avaxReserve()\n    {\n        preserved{\n            requireInvariant op_not_stopped();\ninvariant op_not_stopped()\n    pair() == 0 => !stopped()\n        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "opWavaxBalanceAndWavaxReserve",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "stopped",
                "WAVAX",
                "pair",
                "avaxReserve",
                "getWAVAXbalanceOfThis"
            ],
            "start_line": 385,
            "end_line": 391,
            "block_hash": "96264217a7f820fb528ef29d9a589b36"
        }
    },
    {
        "id": "LaunchEvent_opTokenBalanceCheck_32c154e8",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw/is",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n",
        "formal_property": "invariant opTokenBalanceCheck()\n    pair() == 0 =>  tokenReserve() + tokenIncentivesForUsers() == getTokenBalanceOfThis()\n    {\n        preserved with (env e2){\n            requireInvariant op_not_stopped();\ninvariant op_not_stopped()\n    pair() == 0 => !stopped()\n        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug\n            require token() == SymbERC20A || token() == SymbERC20B;\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n        preserved{\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant initIncentivesCorrelation();\n    }  \n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "opTokenBalanceCheck",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "stopped",
                "token",
                "pair",
                "tokenIncentivesForUsers",
                "tokenReserve",
                "getTokenBalanceOfThis",
                "getTokenBalance"
            ],
            "start_line": 398,
            "end_line": 407,
            "block_hash": "32c154e816995e11bfcfa709c1546b79"
        }
    },
    {
        "id": "LaunchEvent_op_avax_alloc_zero_4c623db8",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/emergencyWithdraw/is",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n",
        "formal_property": "invariant op_avax_alloc_zero()\n    pair() == 0 => avaxAllocated() == 0\n\n// STATUS - verified\n//  - lpSupply is 0\ninvariant op_lp_supply_zero()\n    pair() == 0 => lpSupply() == 0\n// createPair() violates the property: https://vaas-stg.certora.com/output/3106/6453fa43e1396eb864ad/?anonymousKey=c6322b9a791cdbea942221268091c2c963405500\n// - pair.balanceOf(address(this)) == 0\ninvariant opPairBalanceIsZero()\n    pair() == 0 => getPairBalanceOfThis() == 0\n    {\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n            requireInvariant factoryGetPairCorrelationCurrentVals(e2);\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_avax_alloc_zero",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "createPair",
                "avaxAllocated",
                "pair",
                "lpSupply",
                "getPairBalanceOfThis",
                "getPairBalance"
            ],
            "start_line": 412,
            "end_line": 432,
            "block_hash": "4c623db839ba12065fa73d1f6a935bd3"
        }
    },
    {
        "id": "LaunchEvent_opPairAndTotalSupplyCorrelation_8ef4aca5",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "invariant opPairAndTotalSupplyCorrelation()\n    pair() == 0 => getPairTotalSupply() == 0\n    {\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n            requireInvariant factoryGetPairCorrelationCurrentVals(e2);\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "opPairAndTotalSupplyCorrelation",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "pair",
                "getPairTotalSupply"
            ],
            "start_line": 437,
            "end_line": 444,
            "block_hash": "8ef4aca5f6d9ac1997580fef0c796503"
        }
    },
    {
        "id": "LaunchEvent_op_avax_reserve_sum_user_balances_9708f751",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/currentPhase/depositAVAX/emergencyWithdraw/withdrawAVAX",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n",
        "formal_property": "invariant op_avax_reserve_sum_user_balances()\n     pair() == 0 => avaxReserve() == sum_of_users_balances()\n\n// CLOSED - phase three\n// STATUS - in progress (allowEmergencyWithdraw() violation): https://vaas-stg.certora.com/output/3106/eca7dbb4b69c55f85043/?anonymousKey=44a9e39a1f83b15ab36662ee6d898cf1e147e43f\n//  - isStopped is false\ninvariant cl_not_stopped()\n    pair() != 0 => !stopped()\n// STATUS - verified https://vaas-stg.certora.com/output/3106/0ec29a324e7bdb9f86d2/?anonymousKey=deab759d00c63862d1166abb8a17b91ac040118b\n// run without preserved block: https://vaas-stg.certora.com/output/3106/cea4890e65f85e6d14eb/?anonymousKey=94c143aa0c1c85f0f961d154a6e60dafea974945\n// run with preserved block: https://vaas-stg.certora.com/output/3106/8863dca9bb0617161eb3/?anonymousKey=14fee042e6c8821f002886c4e7e0861ca072990c\n//  - avaxAllocated is  getUA[user].balance\ninvariant cl_avax_alloc_sum_user_balances()\n    pair() != 0 => avaxAllocated() == sum_of_users_balances()\n    {\n        preserved with (env e2){\n            requireInvariant cl_not_stopped();                          // emergencyWithdraw()\n            require currentPhase(e2) == PhaseThree();                   // withdrawAVAX(uint256) and depositAVAX()\n        }\n        preserved createPair() with (env e3){\n            requireInvariant pairAndGetPairCorrelation(e3);             // createPair()\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n            requireInvariant factoryGetPairCorrelationCurrentVals(e3);  // createPair()\n            require avaxReserve() == sum_of_users_balances();          // Not sure if it's safe\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_avax_reserve_sum_user_balances",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "currentPhase",
                "depositAVAX",
                "withdrawAVAX",
                "createPair",
                "emergencyWithdraw",
                "allowEmergencyWithdraw",
                "stopped",
                "avaxAllocated",
                "pair",
                "avaxReserve"
            ],
            "start_line": 450,
            "end_line": 480,
            "block_hash": "9708f7512f38f7e97ba563f4652ade0f"
        }
    },
    {
        "id": "LaunchEvent_initially_f6e98bf0",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/currentPhase/emergencyWithdraw/is",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n",
        "formal_property": "// STATUS - in progress. (need preserved block for createPair() that invariant initially is true like require in a rule)\n// run without preserved block: \n// run with preserved block: \n// run: https://vaas-stg.certora.com/output/3106/9d1479ffd6d7489f4c84/?anonymousKey=92f17079fc91748fdd970538af733779da8888c1\ninvariant clWavaxCorrelation(env e)\n    pair() != 0 => (getWAVAXbalanceOfThis() == avaxReserve() && avaxReserve() == 0)\n    {\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n            require currentPhase(e2) == PhaseThree();\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "initially",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "currentPhase",
                "createPair",
                "WAVAX",
                "pair",
                "avaxReserve",
                "getWAVAXbalanceOfThis"
            ],
            "start_line": 483,
            "end_line": 494,
            "block_hash": "f6e98bf0d2403145840c553f925adb1b"
        }
    },
    {
        "id": "LaunchEvent_cl_pair_bal_eq_lp_sum_102fc6ff",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw/is/skim/withdrawIncentives",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n",
        "formal_property": "invariant cl_pair_bal_eq_lp_sum()\n    pair() != 0 => (getPairBalanceOfThis() == lpSupply() / 2 + unwithdrawn_users_lp_tokens)\n    {\n        preserved with (env e2){\n            requireInvariant cl_not_stopped();                          // emergencyWithdraw() and skim()\n            requireInvariant pairAndGetPairCorrelation(e2);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n            requireInvariant opPairBalanceIsZero();\n            require token() == SymbERC20A || token() == SymbERC20B;     // withdrawIncentives()\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_pair_bal_eq_lp_sum",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "withdrawIncentives",
                "emergencyWithdraw",
                "skim",
                "stopped",
                "token",
                "pair",
                "lpSupply",
                "getPairBalanceOfThis",
                "getPairBalance"
            ],
            "start_line": 501,
            "end_line": 510,
            "block_hash": "102fc6ffb8aef42b7213cd7bc3e6ed08"
        }
    },
    {
        "id": "LaunchEvent_cl_token_bal_eq_res_token_551d9cd2",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "invariant cl_token_bal_eq_res_token()\n    false\n\n// STATUS - in progress\n// run without preserved block: https://vaas-stg.certora.com/output/3106/e832cf49cb8c6eb0316a/?anonymousKey=d3e00feecadb1665fc4caf61d0f15b2c60f38459\n// run with preserved block (createPair() issue, pre-state pair() == 0 thus we can call this function): https://vaas-stg.certora.com/output/3106/b96d1d489077c95dc026/?anonymousKey=3c4fe014e274f60b7ccc58c12a3b91b558a3e632\n// - `tokenIncentivesBalance` <= `tokenIncentivesForUsers`\ninvariant clIncentivesCorrelation()\n    pair() != 0 => (tokenIncentivesBalance() <= tokenIncentivesForUsers())\n    {\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);     // createPair()\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_token_bal_eq_res_token",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "createPair",
                "token",
                "pair",
                "tokenIncentivesBalance",
                "tokenIncentivesForUsers"
            ],
            "start_line": 515,
            "end_line": 529,
            "block_hash": "551d9cd201a0f4d31e94914f46fc53a6"
        }
    },
    {
        "id": "LaunchEvent_cl_nonzero_user_pair_bal_949af2c0",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/currentPhase/emergencyWithdraw/pairBalance/withdrawAVAX",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n",
        "formal_property": "invariant cl_nonzero_user_pair_bal(address user, env e)\n    pair() != 0 => (!userHasWithdrawnPair(user) <=> pairBalance(e, user) != 0)\n    {\n        preserved with (env e2){\n            requireInvariant cl_not_stopped();                  // emergencyWithdraw()\n            require currentPhase(e2) == PhaseThree();           // withdrawAVAX(uint256)\n            requireInvariant pairAndGetPairCorrelation(e2);     // createPair()\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_nonzero_user_pair_bal",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "currentPhase",
                "withdrawAVAX",
                "createPair",
                "emergencyWithdraw",
                "pairBalance",
                "stopped",
                "pair",
                "userHasWithdrawnPair"
            ],
            "start_line": 537,
            "end_line": 545,
            "block_hash": "949af2c05fc86ae4b4235ca3510b0cfe"
        }
    },
    {
        "id": "LaunchEvent_cl_bal_this_zero_51a24eec",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "currentPhase/depositAVAX/is",
        "text_chunk": "    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n",
        "formal_property": "invariant cl_bal_this_zero()\n    pair() != 0 => getWAVAXbalanceOfThis() == 0\n    {\n        preserved with (env e2){\n            require currentPhase(e2) == PhaseThree();           // depositAVAX()\n            // should I add invariants from open state?\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_bal_this_zero",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "currentPhase",
                "depositAVAX",
                "WAVAX",
                "pair",
                "getWAVAXbalanceOfThis"
            ],
            "start_line": 552,
            "end_line": 559,
            "block_hash": "51a24eec88d58538c319b7ba381d9959"
        }
    },
    {
        "id": "LaunchEvent_but_22c5ee7f",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "currentPhase/depositAVAX",
        "text_chunk": "    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n",
        "formal_property": "// was listed as an invariant but makes more sense as a parametric rule\n//   - getUA[user].allocation is unchanging\nrule cl_user_alloc_unchanging(address user, method f, env e) {\n    require currentPhase(e) == PhaseThree(); // depositAVAX()\n\n    uint256 userAllocationBefore = getUserAllocation(user);\n    calldataarg args;\n    f(e, args);\n    uint256 userAllocationAfter = getUserAllocation(user);\n    assert userAllocationBefore == userAllocationAfter, \"tokenReserve was changed\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "but",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "currentPhase",
                "depositAVAX",
                "token",
                "tokenReserve",
                "getUserAllocation"
            ],
            "start_line": 597,
            "end_line": 610,
            "block_hash": "22c5ee7fd9c081bd8d0efda1d8a3d103"
        }
    },
    {
        "id": "LaunchEvent_cl_wavaxNotZero_2dd7bf12",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "pairBalance",
        "text_chunk": "    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n",
        "formal_property": "// invariant cl_wavaxNotZero()\n//     pair() != 0 => avaxAllocated() > 0\n\n// STATUS - in progress (maybe add userHasWithdrawnPair(issuer()) => tokenReserve() == 0) - does => <=> make sense?\n// run without preserved block: https://vaas-stg.certora.com/output/3106/b0f4853713af2301edcb/?anonymousKey=ea101ebc4801f04d91fddc5053dd7f37425a8089\n// run with preserved block: \n// - hasWithdrawnPair and LP token balance of user are related\n// invariant cl_hasWithdrawnPair_and_pairBalance_Correlation(env e, address user)\n//     pair() != 0 => (userHasWithdrawnPair(user) <=> getPairBalance(user) == pairBalance(e, user))\n//     {\n//         preserved{\n//             requireInvariant cl_wavaxNotZero();\n//         }\n//     }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_wavaxNotZero",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "pairBalance",
                "issuer",
                "token",
                "avaxAllocated",
                "pair",
                "tokenReserve",
                "userHasWithdrawnPair",
                "getPairBalance"
            ],
            "start_line": 902,
            "end_line": 915,
            "block_hash": "2dd7bf128809215041890e06ebf3d6e6"
        }
    },
    {
        "id": "LaunchEvent_hl_EqualityOfPairs_98e1af04",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw/is/pairBalance",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n",
        "formal_property": "invariant hl_EqualityOfPairs()\n    getPairBalanceOfThis() == getPairBalance(issuer()) + sumOfPairBalances()\n\n// STATUS - in progress\n// run without preserved block: https://vaas-stg.certora.com/output/3106/1f91c36ac4e4424e389f/?anonymousKey=c30c7ee9fd1cb8fe7198145cf50a5e0959f623e4\n// run with preserved block: \ninvariant hl_EqualityOfPairAndTotalSupply()\n    getPairBalanceOfThis() == getPairTotalSupplyOfThis()\n// run without preserved block: https://vaas-stg.certora.com/output/3106/23f2a4a600d0a020f0cb/?anonymousKey=d1d4fef9e201e201fd039a0dd0ddc1ea5306c9d7\n// run with preserved block: https://vaas-stg.certora.com/output/3106/9a888396ade18f00c01a/?anonymousKey=a7cdb01cf4b007d42ee8c2eb885757bfeebef6e6\ninvariant hl_TotalSupplyEquality()\n    getPairTotalSupply() == getPairTotalSupplyOfThis()\n    {\n        preserved with (env e2){\n            requireInvariant factoryGetPairCorrelationCurrentVals(e2);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n        }\n    }\n            // requireInvariant factoryGetPairCorrelationNewVals(e2);\n            requireInvariant pairAndGetPairCorrelation(e2);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\n            require Weth != currentContract;\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_EqualityOfPairs",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "issuer",
                "pair",
                "getPairBalanceOfThis",
                "getPairBalance",
                "getPairTotalSupply",
                "getPairTotalSupplyOfThis"
            ],
            "start_line": 1049,
            "end_line": 1072,
            "block_hash": "98e1af045582cb861b47aea81c47405d"
        }
    },
    {
        "id": "LaunchEvent_hl_EqualityOfToken_55222b90",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "LaunchEvent.sol",
        "target_function": "depositAVAX/is/withdrawIncentives",
        "text_chunk": "    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n",
        "formal_property": "invariant hl_EqualityOfToken(env e) \n    getTokenBalanceOfThis() == tokenReserve() + tokenIncentivesBalance()\n    {\n        preserved with (env e2){\n            require token() == SymbERC20A || token() == SymbERC20B;     // depositAVAX() and many more          // token != instead of ==\n            require e2.msg.sender != currentContract;                   // withdrawIncentives()\n            require e.msg.sender == e2.msg.sender;       \n            // require e2.msg.sender == issuer();               \n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_EqualityOfToken",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "depositAVAX",
                "withdrawIncentives",
                "issuer",
                "token",
                "tokenIncentivesBalance",
                "tokenReserve",
                "getTokenBalanceOfThis",
                "getTokenBalance"
            ],
            "start_line": 1081,
            "end_line": 1090,
            "block_hash": "55222b90af36994d3f49c6e751d8f818"
        }
    },
    {
        "id": "LaunchEvent_op_token_res_fixed_4c0789a1",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "rule op_token_res_fixed(method f, env e) {\n\n    require pair() == 0;\n    requireInvariant pairAndGetPairCorrelation(e);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    require initialized();\n    require !stopped();\n    uint256 tokenReserveBefore = tokenReserve();\n    calldataarg args;\n    f(e, args);\n    uint256 tokenReserveAfter = tokenReserve();\n    assert tokenReserveBefore == tokenReserveAfter, \"tokenReserve was changed\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_token_res_fixed",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "initialized",
                "stopped",
                "token",
                "pair",
                "tokenReserve"
            ],
            "start_line": 574,
            "end_line": 591,
            "block_hash": "4c0789a19ca27a3db89c22889cbfd09a"
        }
    },
    {
        "id": "LaunchEvent_cl_user_alloc_unchanging_766e4fe7",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "currentPhase/depositAVAX",
        "text_chunk": "    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n",
        "formal_property": "rule cl_user_alloc_unchanging(address user, method f, env e) {\n    require currentPhase(e) == PhaseThree(); // depositAVAX()\n\n    uint256 userAllocationBefore = getUserAllocation(user);\n    calldataarg args;\n    f(e, args);\n    uint256 userAllocationAfter = getUserAllocation(user);\n    assert userAllocationBefore == userAllocationAfter, \"tokenReserve was changed\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_user_alloc_unchanging",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "currentPhase",
                "depositAVAX",
                "token",
                "tokenReserve",
                "getUserAllocation"
            ],
            "start_line": 599,
            "end_line": 610,
            "block_hash": "766e4fe7e562e005c71708e6e3efe691"
        }
    },
    {
        "id": "LaunchEvent_cl_avax_alloc_fixed_4745c99e",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "rule cl_avax_alloc_fixed(method f, env e) {\n    require pair() != 0;\n    requireInvariant pairAndGetPairCorrelation(e);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    uint256 wavaxAllocatedBefore = avaxAllocated();\n    calldataarg args;\n    f(e, args);\n    uint256 wavaxAllocatedAfter = avaxAllocated();\n    assert wavaxAllocatedBefore == wavaxAllocatedAfter, \"not yet implemented\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_avax_alloc_fixed",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "avaxAllocated",
                "pair"
            ],
            "start_line": 622,
            "end_line": 634,
            "block_hash": "4745c99e07e0c2385772e24b5f0431b5"
        }
    },
    {
        "id": "LaunchEvent_cl_lp_supply_fixed_b18365ef",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "rule cl_lp_supply_fixed(method f, env e) {\n    require pair() != 0;\n    requireInvariant pairAndGetPairCorrelation(e);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    uint256 lpSupplyBefore = lpSupply();\n    calldataarg args;\n    f(e, args);\n    uint256 lpSupplyAfter = lpSupply();\n    assert lpSupplyBefore == lpSupplyAfter, \"not yet implemented\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_lp_supply_fixed",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "pair",
                "lpSupply"
            ],
            "start_line": 639,
            "end_line": 651,
            "block_hash": "b18365ef1be68837b3be2d7116662e04"
        }
    },
    {
        "id": "LaunchEvent_al_userAllocationNonDecreasing_d2adb9b1",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "rule al_userAllocationNonDecreasing(method f, env e){     \n    address user;\n\n    uint256 allocationBefore = getUserAllocation(user);\n    calldataarg args;\n    f(e, args);\n    uint256 allocationAfter = getUserAllocation(user);\n    assert allocationBefore <= allocationAfter, \"allocation was decreased\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "al_userAllocationNonDecreasing",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "getUserAllocation"
            ],
            "start_line": 664,
            "end_line": 675,
            "block_hash": "d2adb9b1da2a968637cdbcbda6178491"
        }
    },
    {
        "id": "LaunchEvent_al_stoppedOnlyByOwner_38da33cb",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "owner",
        "text_chunk": "    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "rule al_stoppedOnlyByOwner(method f, env e){\n    bool isStoppedBefore = stopped();\n\n    calldataarg args;\n    f(e, args);\n    bool isStoppedAfter = stopped();\n    assert isStoppedBefore != isStoppedAfter => (e.msg.sender == getOwner() && isStoppedBefore == false), \"pair was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "al_stoppedOnlyByOwner",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "stopped",
                "pair",
                "getOwner"
            ],
            "start_line": 680,
            "end_line": 689,
            "block_hash": "38da33cb3b374b07b1e93b228bce97a2"
        }
    },
    {
        "id": "LaunchEvent_op_balanceChangeByDepositOrWithdraw_75f80f11",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "depositAVAX/withdrawAVAX",
        "text_chunk": "    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n",
        "formal_property": "rule op_balanceChangeByDepositOrWithdraw(method f, env e){     \n    address user;\n\n    uint256 balanceBefore = getUserBalance(user);\n    calldataarg args;\n    f(e, args);\n    uint256 balanceAfter = getUserBalance(user);\n    assert balanceBefore != balanceAfter <=> (e.msg.sender == user && (f.selector == depositAVAX().selector || f.selector == withdrawAVAX(uint256).selector)), \"pair was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_balanceChangeByDepositOrWithdraw",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "depositAVAX",
                "withdrawAVAX",
                "pair",
                "getUserBalance"
            ],
            "start_line": 697,
            "end_line": 708,
            "block_hash": "75f80f11cce8e5f1f3ab3ce491e3532a"
        }
    },
    {
        "id": "LaunchEvent_op_allocationChangeByDeposit_2cb6427b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "depositAVAX",
        "text_chunk": "    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n",
        "formal_property": "rule op_allocationChangeByDeposit(method f, env e){\n    address user;\n\n    uint256 allocationBefore = getUserAllocation(user);\n    calldataarg args;\n    f(e, args);\n    uint256 allocationAfter = getUserAllocation(user);\n    assert allocationBefore != allocationAfter => (f.selector == depositAVAX().selector && e.msg.sender == user), \"allocation was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_allocationChangeByDeposit",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "depositAVAX",
                "getUserAllocation"
            ],
            "start_line": 713,
            "end_line": 724,
            "block_hash": "2cb6427b77a4cd472f292f6bdd426ebc"
        }
    },
    {
        "id": "LaunchEvent_op_tokenReserveUnchange_a5c9b7c5",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/emergencyWithdraw/withdrawLiquidity",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n",
        "formal_property": "rule op_tokenReserveUnchange(method f, env e){\n    require pair() == 0;                    // createPair() and withdrawLiquidity()\n    requireInvariant pairAndGetPairCorrelation(e);   // createPair()\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    requireInvariant opPairAndTotalSupplyCorrelation();     // createPair()\ninvariant opPairAndTotalSupplyCorrelation()\n    pair() == 0 => getPairTotalSupply() == 0\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);\n            requireInvariant factoryGetPairCorrelationCurrentVals(e2);\n    requireInvariant op_not_stopped();      // emergencyWithdraw()\ninvariant op_not_stopped()\n    pair() == 0 => !stopped()\n        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug\n    requireInvariant isInitialized();       // initialize()\n    uint256 tokenReserveBefore = tokenReserve();\n    calldataarg args;\n    f(e, args);\n    uint256 tokenReserveAfter = tokenReserve();\n    assert tokenReserveBefore == tokenReserveAfter, \"tokenReserve was changed\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_tokenReserveUnchange",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "createPair",
                "withdrawLiquidity",
                "emergencyWithdraw",
                "stopped",
                "token",
                "pair",
                "tokenReserve"
            ],
            "start_line": 730,
            "end_line": 745,
            "block_hash": "a5c9b7c59c6e6cfbcf43aa7866e5248f"
        }
    },
    {
        "id": "LaunchEvent_op_tokenIncentivesBalanceUnchange_c120e2b5",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw/withdrawIncentives",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n",
        "formal_property": "rule op_tokenIncentivesBalanceUnchange(method f, env e){\n    require pair() == 0;                    // withdrawIncentives()\n    requireInvariant op_not_stopped();      // emergencyWithdraw()\ninvariant op_not_stopped()\n    pair() == 0 => !stopped()\n        // filtered { f -> f.selector != allowEmergencyWithdraw().selector }  // possible bug\n    requireInvariant isInitialized();       // initialize()\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n    {\n        preserved{\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n    uint256 tokenIncentivesBalanceBefore = tokenIncentivesBalance();\n    calldataarg args;\n    f(e, args);\n    uint256 tokenIncentivesBalanceAfter = tokenIncentivesBalance();\n    assert tokenIncentivesBalanceBefore == tokenIncentivesBalanceAfter, \"tokenIncentivesBalance was changed\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_tokenIncentivesBalanceUnchange",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "withdrawIncentives",
                "emergencyWithdraw",
                "stopped",
                "token",
                "pair",
                "tokenIncentivesBalance"
            ],
            "start_line": 751,
            "end_line": 764,
            "block_hash": "c120e2b5db9edd6856fb1bb950a66d85"
        }
    },
    {
        "id": "LaunchEvent_op_tokenIncentivesForUsersUnchange_2035289a",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "rule op_tokenIncentivesForUsersUnchange(method f, env e){\n    require pair() == 0;                    // createPair()\n    requireInvariant pairAndGetPairCorrelation(e);   // createPair()\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    requireInvariant opPairAndTotalSupplyCorrelation();     // createPair()\ninvariant opPairAndTotalSupplyCorrelation()\n    pair() == 0 => getPairTotalSupply() == 0\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);\n            requireInvariant factoryGetPairCorrelationCurrentVals(e2);\n    requireInvariant isInitialized();       // initialize()\n    uint256 tokenIncentivesForUsersBefore = tokenIncentivesForUsers();\n    calldataarg args;\n    f(e, args);\n    uint256 tokenIncentivesForUsersAfter = tokenIncentivesForUsers();\n    assert tokenIncentivesForUsersBefore == tokenIncentivesForUsersAfter, \"tokenRestokenIncentivesForUserserve was changed\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_tokenIncentivesForUsersUnchange",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "createPair",
                "token",
                "pair",
                "tokenIncentivesForUsers"
            ],
            "start_line": 770,
            "end_line": 784,
            "block_hash": "2035289afbd4b179cc9e72433d5cbe52"
        }
    },
    {
        "id": "LaunchEvent_op_tokenIncentiveIssuerRefundUnchange_012a0fbe",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "rule op_tokenIncentiveIssuerRefundUnchange(method f, env e){\n    require pair() == 0;                                    // createPair()\n    requireInvariant pairAndGetPairCorrelation(e);          // createPair()\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    requireInvariant opPairAndTotalSupplyCorrelation();     // createPair()\ninvariant opPairAndTotalSupplyCorrelation()\n    pair() == 0 => getPairTotalSupply() == 0\n        preserved with (env e2){\n            requireInvariant pairAndGetPairCorrelation(e2);\n            requireInvariant factoryGetPairCorrelationCurrentVals(e2);\n    uint256 tokenIncentiveIssuerRefundBefore = tokenIncentiveIssuerRefund();\n    calldataarg args;\n    f(e, args);\n    uint256 tokenIncentiveIssuerRefundAfter = tokenIncentiveIssuerRefund();\n    assert tokenIncentiveIssuerRefundBefore == tokenIncentiveIssuerRefundAfter, \"tokenIncentiveIssuerRefund was changed\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "op_tokenIncentiveIssuerRefundUnchange",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "createPair",
                "token",
                "pair",
                "tokenIncentiveIssuerRefund"
            ],
            "start_line": 790,
            "end_line": 803,
            "block_hash": "012a0fbee7bfa14f5cbe3e08d3aa3f7d"
        }
    },
    {
        "id": "LaunchEvent_tr_pairOnlyChange_df1224b1",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "rule tr_pairOnlyChange(method f, env e){     \n    requireInvariant pairAndGetPairCorrelation(e);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    address pairBefore = pair();\n    calldataarg args;\n    f(e, args);\n    address pairAfter = pair();\n    assert pairBefore != pairAfter <=> f.selector == createPair().selector, \"pair was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "tr_pairOnlyChange",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "createPair",
                "pair"
            ],
            "start_line": 820,
            "end_line": 831,
            "block_hash": "df1224b18909228ea33d00a9ea90802b"
        }
    },
    {
        "id": "LaunchEvent_tr_initializedOnlyChange_cc04200a",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "rule tr_initializedOnlyChange(method f){     \n    bool initBefore = initialized();\n\n    env e;\n    calldataarg args;\n    f(e, args);\n    bool initAfter = initialized();\n    assert initBefore != initAfter <=> f.selector == initialize(address, uint256, address, uint256, uint256, uint256, uint256, uint256, uint256, uint256).selector, \"initialized was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "tr_initializedOnlyChange",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "initialize",
                "initialized"
            ],
            "start_line": 835,
            "end_line": 845,
            "block_hash": "cc04200ac77d4c86c47c637c8d147b57"
        }
    },
    {
        "id": "LaunchEvent_tr_incentivesForUsersChanges_6edf9b0f",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "createPair",
        "text_chunk": "    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n",
        "formal_property": "rule tr_incentivesForUsersChanges(method f){     \n    uint256 incentivesBefore = tokenIncentivesForUsers();\n\n    env e;\n    calldataarg args;\n    f(e, args);\n    uint256 incentivesAfter = tokenIncentivesForUsers();\n    assert incentivesBefore != incentivesAfter \n                => f.selector == initialize(address, uint256, address, uint256, uint256, uint256, uint256, uint256, uint256, uint256).selector\n                || f.selector == createPair().selector, \"tokenIncentivesForUsers was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "tr_incentivesForUsersChanges",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "createPair",
                "token",
                "tokenIncentivesForUsers"
            ],
            "start_line": 849,
            "end_line": 861,
            "block_hash": "6edf9b0f209465dadfc69e936beb916e"
        }
    },
    {
        "id": "LaunchEvent_tr_incentiveIssuerRefundChanges_9dfd5655",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "createPair",
        "text_chunk": "    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n",
        "formal_property": "rule tr_incentiveIssuerRefundChanges(method f){     \n    uint256 incentivesBefore = tokenIncentiveIssuerRefund();\n\n    env e;\n    calldataarg args;\n    f(e, args);\n    uint256 incentivesAfter = tokenIncentiveIssuerRefund();\n    assert incentivesBefore != incentivesAfter => f.selector == createPair().selector, \"tokenIncentiveIssuerRefund was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "tr_incentiveIssuerRefundChanges",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "createPair",
                "token",
                "tokenIncentiveIssuerRefund"
            ],
            "start_line": 865,
            "end_line": 875,
            "block_hash": "9dfd5655868c14d1068a3b550b42994c"
        }
    },
    {
        "id": "LaunchEvent_cl_unchangingPair_4a1e2e99",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/emergencyWithdraw",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "rule cl_unchangingPair(method f, env e){\n    require pair() != 0;\n    requireInvariant pairAndGetPairCorrelation(e);\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    address pairBefore = pair();\n    calldataarg args;\n    f(e, args);\n    address pairAfter = pair();\n    assert pairBefore == pairAfter, \"pair was changed in close stage\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_unchangingPair",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "pair"
            ],
            "start_line": 887,
            "end_line": 899,
            "block_hash": "4a1e2e994154cce111a5f85c225405ff"
        }
    },
    {
        "id": "LaunchEvent_cl_hasWithdrawnPair_pairBalance_OnlyChangeUser_1df066e2",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "pairBalance/withdrawLiquidity",
        "text_chunk": "    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n",
        "formal_property": "rule cl_hasWithdrawnPair_pairBalance_OnlyChangeUser(method f, env e){\n    address user;\n    require user != currentContract;\n    require user == e.msg.sender;\n    require user != issuer();\n\n    bool hasWPairBefore = userHasWithdrawnPair(user);\n    uint256 userPairBalanceBefore = getPairBalance(user);\n    uint256 possiblePairBalance = pairBalance(e, user);\n    helperFunctionsForWithdrawLiquidity(f, e);\n    \n    bool hasWPairAfter = userHasWithdrawnPair(user);\n    uint256 userPairBalanceAfter = getPairBalance(user);\n    assert (hasWPairBefore != hasWPairAfter && userPairBalanceAfter == userPairBalanceBefore + possiblePairBalance) <=> f.selector == withdrawLiquidity().selector, \"hasWithdrawnPair was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_hasWithdrawnPair_pairBalance_OnlyChangeUser",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "withdrawLiquidity",
                "pairBalance",
                "issuer",
                "pair",
                "userHasWithdrawnPair",
                "getPairBalance"
            ],
            "start_line": 923,
            "end_line": 939,
            "block_hash": "1df066e2722c3945aa84481034c71a00"
        }
    },
    {
        "id": "LaunchEvent_cl_hasWithdrawnPair_pairBalance_OnlyChangeIssuer_4b3ad46e",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "pairBalance/withdrawLiquidity",
        "text_chunk": "    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n",
        "formal_property": "rule cl_hasWithdrawnPair_pairBalance_OnlyChangeIssuer(method f, env e){\n    address user;\n    require user != currentContract;\n    require user == e.msg.sender;\n    require user == issuer();\n    require token() == SymbERC20A || token() == SymbERC20B;\n\n    bool hasWPairBefore = userHasWithdrawnPair(user);\n    uint256 userPairBalanceBefore = getPairBalance(user);\n    helperFunctionsForWithdrawLiquidity(f, e);\n    \n    bool hasWPairAfter = userHasWithdrawnPair(user);\n    uint256 userPairBalanceAfter = getPairBalance(user);\n    assert (hasWPairBefore != hasWPairAfter && userPairBalanceAfter == userPairBalanceBefore + (lpSupply() / 2)) <=> f.selector == withdrawLiquidity().selector, \"hasWithdrawnPair was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_hasWithdrawnPair_pairBalance_OnlyChangeIssuer",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "withdrawLiquidity",
                "pairBalance",
                "issuer",
                "token",
                "pair",
                "lpSupply",
                "userHasWithdrawnPair",
                "getPairBalance"
            ],
            "start_line": 942,
            "end_line": 958,
            "block_hash": "4b3ad46e7d838c7c88990d08b2af5376"
        }
    },
    {
        "id": "LaunchEvent_cl_pairAndTokenBalancesNonIncreasing_35be1fc6",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "allowEmergencyWithdraw/createPair/currentPhase/depositAVAX/emergencyWithdraw/is/pairBalance",
        "text_chunk": "    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n",
        "formal_property": "rule cl_pairAndTokenBalancesNonIncreasing(method f, env e){\n    require pair() != 0;                                // createPair()\n    requireInvariant pairAndGetPairCorrelation(e);      // createPair()\ninvariant pairAndGetPairCorrelation(env e)\n    pair() == Factory.getPair(e, WAVAX(), token())\n    {\n        preserved{\n            requireInvariant isInitialized();\ninvariant isInitialized()\n    initialized()\n\n// STATUS - in progress. allowEmergencyWithdraw() fails: https://vaas-stg.certora.com/output/3106/c7acf44ab915c9ca241d/?anonymousKey=bf56f5336ce3678bd11250d225cc80089662a446\n// - stopped == false\ninvariant initNotStopped()\n    initialized() => !stopped()\n            requireInvariant notStoppedIfNonInitialized();\n        }\n    }\n            requireInvariant factoryGetPairCorrelationCurrentVals(e);\ninvariant factoryGetPairCorrelationCurrentVals(env e)\n    Factory.getPair(e, token(), WAVAX()) == Factory.getPair(e, WAVAX(), token())\n        preserved initialize(address _issuer, uint256 _auctionStart, address _token, uint256 _tokenIncentivesPercent, uint256 _floorPrice, uint256 _maxWithdrawPenalty,\n                uint256 _fixedWithdrawPenalty, uint256 _maxAllocation, uint256 _userTimelock, uint256 _issuerTimelock) with (env e2){\n            requireInvariant factoryGetPairCorrelationNewVals(e, _token);\ninvariant factoryGetPairCorrelationNewVals(env e, address token)\n    Factory.getPair(e, token, getNewWAVAX()) == Factory.getPair(e, getNewWAVAX(), token)\n            require token == _token;\n    requireInvariant isInitialized();                   // initialize()\n    require currentPhase(e) == PhaseThree();            // depositAVAX() \n    uint256 tokenBalanceBefore = getTokenBalanceOfThis();\n    uint256 pairBalanceBefore = getPairBalanceOfThis();\n    calldataarg args;\n    f(e, args);\n    uint256 tokenBalanceAfter = getTokenBalanceOfThis();\n    uint256 pairBalanceAfter = getPairBalanceOfThis();\n    assert tokenBalanceBefore >= tokenBalanceAfter, \"token balance was increased\";\n    assert pairBalanceBefore >= pairBalanceAfter, \"pair balance was increased\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_pairAndTokenBalancesNonIncreasing",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "currentPhase",
                "depositAVAX",
                "createPair",
                "pairBalance",
                "token",
                "pair",
                "getTokenBalanceOfThis",
                "getPairBalanceOfThis",
                "getPairBalance",
                "getTokenBalance"
            ],
            "start_line": 966,
            "end_line": 984,
            "block_hash": "35be1fc67fdcd311849c3f2402b54805"
        }
    },
    {
        "id": "LaunchEvent_cl_hasWithdrawnIncentivesOnlyChange_901acb5d",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "withdrawIncentives",
        "text_chunk": "    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n",
        "formal_property": "rule cl_hasWithdrawnIncentivesOnlyChange(method f, env e){\n    bool hasWIncenBefore = userHasWithdrawnIncentives(e.msg.sender);\n\n    calldataarg args;\n    f(e, args);\n    bool hasWIncenAfter = userHasWithdrawnIncentives(e.msg.sender);\n    assert hasWIncenBefore != hasWIncenAfter => f.selector == withdrawIncentives().selector, \"hasWithdrawnIncentives was changed by wrong method\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_hasWithdrawnIncentivesOnlyChange",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "withdrawIncentives",
                "userHasWithdrawnIncentives"
            ],
            "start_line": 989,
            "end_line": 998,
            "block_hash": "901acb5db53842b4701d5b2852ef3969"
        }
    },
    {
        "id": "LaunchEvent_cl_tokenIncentivesBalancesNonIncreasing_782c4268",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IJoeFactory.sol\";\nimport \"./interfaces/IJoePair.sol\";\nimport \"./interfaces/IJoeRouter02.sol\";\nimport \"./interfaces/IRocketJoeFactory.sol\";\nimport \"./interfaces/IRocketJoeToken.sol\";\nimport \"./interfaces/IWAVAX.sol\";\n\ninterface Ownable {\n    function owner() external view returns (address);\n}\n\n/// @title Rocket Joe Launch Event\n/// @author Trader Joe\n/// @notice A liquidity launch contract enabling price discovery and token distribution at secondary market listing price\ncontract LaunchEvent {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n    /// @notice The phases the launch event can be in\n    /// @dev Should these have more semantic names: Bid, Cancel, Withdraw\n    enum Phase {\n        NotStarted,\n        PhaseOne,\n        PhaseTwo,\n        PhaseThree\n    }\n\n    struct UserInfo {\n        /// @notice How much AVAX user can deposit for this launch event\n        /// @dev Can be increased by burning more rJOE, but will always be\n        /// smaller than or equal to `maxAllocation`\n        uint256 allocation;\n        /// @notice How much AVAX user has deposited for this launch event\n        uint256 balance;\n        /// @notice Whether user has withdrawn the LP\n        bool hasWithdrawnPair;\n        /// @notice Whether user has withdrawn the issuing token incentives\n        bool hasWithdrawnIncentives;\n    }\n\n    /// @notice Issuer of sale tokens\n    address public issuer;\n\n    /// @notice The start time of phase 1\n    uint256 public auctionStart;\n\n    uint256 public phaseOneDuration;\n    uint256 public phaseOneNoFeeDuration;\n    uint256 public phaseTwoDuration;\n\n    /// @dev Amount of tokens used as incentives for locking up LPs during phase 3,\n    /// in parts per 1e18 and expressed as an additional percentage to the tokens for auction.\n    /// E.g. if tokenIncentivesPercent = 5e16 (5%), and issuer sends 105 000 tokens,\n    /// then 105 000 * 5e16 / (1e18 + 5e16) = 5 000 tokens are used for incentives\n    uint256 public tokenIncentivesPercent;\n\n    /// @notice Floor price in AVAX per token (can be 0)\n    /// @dev floorPrice is scaled to 1e18\n    uint256 public floorPrice;\n\n    /// @notice Timelock duration post phase 3 when can user withdraw their LP tokens\n    uint256 public userTimelock;\n\n    /// @notice Timelock duration post phase 3 When can issuer withdraw their LP tokens\n    uint256 public issuerTimelock;\n\n    /// @notice The max withdraw penalty during phase 1, in parts per 1e18\n    /// e.g. max penalty of 50% `maxWithdrawPenalty`= 5e17\n    uint256 public maxWithdrawPenalty;\n\n    /// @notice The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// e.g. fixed penalty of 20% `fixedWithdrawPenalty = 2e17`\n    uint256 public fixedWithdrawPenalty;\n\n    IRocketJoeToken public rJoe;\n    uint256 public rJoePerAvax;\n    IWAVAX private WAVAX;\n    IERC20MetadataUpgradeable public token;\n\n    IJoeRouter02 private router;\n    IJoeFactory private factory;\n    IRocketJoeFactory public rocketJoeFactory;\n\n    bool public stopped;\n\n    uint256 public maxAllocation;\n\n    mapping(address => UserInfo) public getUserInfo;\n\n    /// @dev The address of the JoePair, set after createLiquidityPool is called\n    IJoePair public pair;\n\n    /// @dev The total amount of avax that was sent to the router to create the initial liquidity pair.\n    /// Used to calculate the amount of LP to send based on the user's participation in the launch event\n    uint256 public avaxAllocated;\n\n    /// @dev The total amount of tokens that was sent to the router to create the initial liquidity pair.\n    uint256 public tokenAllocated;\n\n    /// @dev The exact supply of LP minted when creating the initial liquidity pair.\n    uint256 private lpSupply;\n\n    /// @dev Used to know how many issuing tokens will be sent to JoeRouter to create the initial\n    /// liquidity pair. If floor price is not met, we will send fewer issuing tokens and `tokenReserve`\n    /// will keep track of the leftover amount. It's then used to calculate the number of tokens needed\n    /// to be sent to both issuer and users (if there are leftovers and every token is sent to the pair,\n    /// tokenReserve will be equal to 0)\n    uint256 private tokenReserve;\n\n    /// @dev Keeps track of amount of token incentives that needs to be kept by contract in order to send the right\n    /// amounts to issuer and users\n    uint256 private tokenIncentivesBalance;\n    /// @dev Total incentives for users for locking their LPs for an additional period of time after the pair is created\n    uint256 private tokenIncentivesForUsers;\n    /// @dev The share refunded to the issuer. Users receive 5% of the token that were sent to the Router.\n    /// If the floor price is not met, the incentives still needs to be 5% of the value sent to the Router, so there\n    /// will be an excess of tokens returned to the issuer if he calls `withdrawIncentives()`\n    uint256 private tokenIncentiveIssuerRefund;\n\n    /// @dev avaxReserve is the exact amount of AVAX that needs to be kept inside the contract in order to send everyone's\n    /// AVAX. If there is some excess (because someone sent token directly to the contract), the\n    /// penaltyCollector can collect the excess using `skim()`\n    uint256 private avaxReserve;\n\n    event LaunchEventInitialized(\n        uint256 tokenIncentivesPercent,\n        uint256 floorPrice,\n        uint256 maxWithdrawPenalty,\n        uint256 fixedWithdrawPenalty,\n        uint256 maxAllocation,\n        uint256 userTimelock,\n        uint256 issuerTimelock,\n        uint256 tokenReserve,\n        uint256 tokenIncentives\n    );\n\n    event UserParticipated(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 rJoeAmount\n    );\n\n    event UserWithdrawn(\n        address indexed user,\n        uint256 avaxAmount,\n        uint256 penaltyAmount\n    );\n\n    event IncentiveTokenWithdraw(\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    event LiquidityPoolCreated(\n        address indexed pair,\n        address indexed token0,\n        address indexed token1,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event UserLiquidityWithdrawn(\n        address indexed user,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event IssuerLiquidityWithdrawn(\n        address indexed issuer,\n        address indexed pair,\n        uint256 amount\n    );\n\n    event Stopped();\n\n    event AvaxEmergencyWithdraw(address indexed user, uint256 amount);\n\n    event TokenEmergencyWithdraw(address indexed user, uint256 amount);\n\n    /// @notice Modifier which ensures contract is in a defined phase\n    modifier atPhase(Phase _phase) {\n        _atPhase(_phase);\n        _;\n    }\n\n    /// @notice Modifier which ensures the caller's timelock to withdraw has elapsed\n    modifier timelockElapsed() {\n        _timelockElapsed();\n        _;\n    }\n\n    /// @notice Ensures launch event is stopped/running\n    modifier isStopped(bool _stopped) {\n        _isStopped(_stopped);\n        _;\n    }\n\n    /// @notice Initialize the launch event with needed parameters\n    /// @param _issuer Address of the token issuer\n    /// @param _auctionStart The start time of the auction\n    /// @param _token The contract address of auctioned token\n    /// @param _tokenIncentivesPercent The token incentives percent, in part per 1e18, e.g 5e16 is 5% of incentives\n    /// @param _floorPrice The minimum price the token is sold at\n    /// @param _maxWithdrawPenalty The max withdraw penalty during phase 1, in parts per 1e18\n    /// @param _fixedWithdrawPenalty The fixed withdraw penalty during phase 2, in parts per 1e18\n    /// @param _maxAllocation The maximum amount of AVAX depositable per user\n    /// @param _userTimelock The time a user must wait after auction ends to withdraw liquidity\n    /// @param _issuerTimelock The time the issuer must wait after auction ends to withdraw liquidity\n    /// @dev This function is called by the factory immediately after it creates the contract instance\n    function initialize(\n        address _issuer,\n        uint256 _auctionStart,\n        address _token,\n        uint256 _tokenIncentivesPercent,\n        uint256 _floorPrice,\n        uint256 _maxWithdrawPenalty,\n        uint256 _fixedWithdrawPenalty,\n        uint256 _maxAllocation,\n        uint256 _userTimelock,\n        uint256 _issuerTimelock\n    ) external atPhase(Phase.NotStarted) {\n        require(auctionStart == 0, \"LaunchEvent: already initialized\");\n        rocketJoeFactory = IRocketJoeFactory(msg.sender);\n        require(\n            _token != rocketJoeFactory.wavax(),\n            \"LaunchEvent: token is wavax\"\n        );\n\n        WAVAX = IWAVAX(rocketJoeFactory.wavax());\n        router = IJoeRouter02(rocketJoeFactory.router());\n        factory = IJoeFactory(rocketJoeFactory.factory());\n        rJoe = IRocketJoeToken(rocketJoeFactory.rJoe());\n        rJoePerAvax = rocketJoeFactory.rJoePerAvax();\n\n        require(\n            _maxWithdrawPenalty <= 5e17,\n            \"LaunchEvent: maxWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _fixedWithdrawPenalty <= 5e17,\n            \"LaunchEvent: fixedWithdrawPenalty too big\"\n        ); // 50%\n        require(\n            _userTimelock <= 7 days,\n            \"LaunchEvent: can't lock user LP for more than 7 days\"\n        );\n        require(\n            _issuerTimelock > _userTimelock,\n            \"LaunchEvent: issuer can't withdraw before users\"\n        );\n        require(\n            _auctionStart > block.timestamp,\n            \"LaunchEvent: start of phase 1 cannot be in the past\"\n        );\n        require(\n            _issuer != address(0),\n            \"LaunchEvent: issuer must be address zero\"\n        );\n        require(\n            _maxAllocation > 0,\n            \"LaunchEvent: max allocation must not be zero\"\n        );\n        require(\n            _tokenIncentivesPercent < 1 ether,\n            \"LaunchEvent: token incentives too high\"\n        );\n\n        issuer = _issuer;\n\n        auctionStart = _auctionStart;\n        phaseOneDuration = rocketJoeFactory.phaseOneDuration();\n        phaseOneNoFeeDuration = rocketJoeFactory.phaseOneNoFeeDuration();\n        phaseTwoDuration = rocketJoeFactory.phaseTwoDuration();\n\n        token = IERC20MetadataUpgradeable(_token);\n        uint256 balance = token.balanceOf(address(this));\n\n        tokenIncentivesPercent = _tokenIncentivesPercent;\n\n        /// We do this math because `tokenIncentivesForUsers + tokenReserve = tokenSent`\n        /// and `tokenIncentivesForUsers = tokenReserve * 0.05` (i.e. incentives are 5% of reserves for issuing).\n        /// E.g. if issuer sends 105e18 tokens, `tokenReserve = 100e18` and `tokenIncentives = 5e18`\n        tokenReserve = (balance * 1e18) / (1e18 + _tokenIncentivesPercent);\n        require(tokenReserve > 0, \"LaunchEvent: no token balance\");\n        tokenIncentivesForUsers = balance - tokenReserve;\n        tokenIncentivesBalance = tokenIncentivesForUsers;\n\n        floorPrice = _floorPrice;\n\n        maxWithdrawPenalty = _maxWithdrawPenalty;\n        fixedWithdrawPenalty = _fixedWithdrawPenalty;\n\n        maxAllocation = _maxAllocation;\n\n        userTimelock = _userTimelock;\n        issuerTimelock = _issuerTimelock;\n\n        emit LaunchEventInitialized(\n            tokenIncentivesPercent,\n            floorPrice,\n            maxWithdrawPenalty,\n            fixedWithdrawPenalty,\n            maxAllocation,\n            userTimelock,\n            issuerTimelock,\n            tokenReserve,\n            tokenIncentivesBalance\n        );\n    }\n\n    /// @notice The current phase the auction is in\n    function currentPhase() public view returns (Phase) {\n        if (auctionStart == 0 || block.timestamp < auctionStart) {\n            return Phase.NotStarted;\n        } else if (block.timestamp < auctionStart + phaseOneDuration) {\n            return Phase.PhaseOne;\n        } else if (\n            block.timestamp < auctionStart + phaseOneDuration + phaseTwoDuration\n        ) {\n            return Phase.PhaseTwo;\n        }\n        return Phase.PhaseThree;\n    }\n\n    /// @notice Deposits AVAX and burns rJoe\n    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n    /// @notice Withdraw AVAX, only permitted during phase 1 and 2\n    /// @param _amount The amount of AVAX to withdraw\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n\n    /// @notice Create the JoePair\n    /// @dev Can only be called once after phase 3 has started\n    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n\n    /// @notice Withdraw liquidity pool tokens\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n\n    /// @notice Withdraw incentives tokens\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n    /// @notice Withdraw AVAX if launch has been cancelled\n    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n\n    /// @notice Stops the launch event and allows participants to withdraw deposits\n    function allowEmergencyWithdraw() external {\n        require(\n            msg.sender == Ownable(address(rocketJoeFactory)).owner(),\n            \"LaunchEvent: caller is not RocketJoeFactory owner\"\n        );\n        stopped = true;\n        emit Stopped();\n    }\n\n    /// @notice Force balances to match tokens that were deposited, but not sent directly to the contract.\n    /// Any excess tokens are sent to the penaltyCollector\n    function skim() external {\n        require(msg.sender == tx.origin, \"LaunchEvent: EOA only\");\n        address penaltyCollector = rocketJoeFactory.penaltyCollector();\n\n        uint256 excessToken = token.balanceOf(address(this)) -\n            tokenReserve -\n            tokenIncentivesBalance;\n        if (excessToken > 0) {\n            token.safeTransfer(penaltyCollector, excessToken);\n        }\n\n        uint256 excessAvax = address(this).balance - avaxReserve;\n        if (excessAvax > 0) {\n            _safeTransferAVAX(penaltyCollector, excessAvax);\n        }\n    }\n\n    /// @notice Returns the current penalty for early withdrawal\n    /// @return The penalty to apply to a withdrawal amount\n    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n\n    /// @notice Returns the incentives for a given user\n    /// @param _user The user to look up\n    /// @return The amount of incentives `_user` can withdraw\n    function getIncentives(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n\n        if (user.hasWithdrawnIncentives) {\n            return 0;\n        }\n\n        if (_user == issuer) {\n            if (address(pair) == address(0)) return 0;\n            return tokenIncentiveIssuerRefund + tokenReserve;\n        } else {\n            if (avaxAllocated == 0) return 0;\n            return (user.balance * tokenIncentivesForUsers) / avaxAllocated;\n        }\n    }\n\n    /// @notice Returns the outstanding balance of the launch event contract\n    /// @return The balances of AVAX and issued token held by the launch contract\n    function getReserves() external view returns (uint256, uint256) {\n        return (avaxReserve, tokenReserve + tokenIncentivesBalance);\n    }\n\n    /// @notice Get the rJOE amount needed to deposit AVAX\n    /// @param _avaxAmount The amount of AVAX to deposit\n    /// @return The amount of rJOE needed\n    function getRJoeAmount(uint256 _avaxAmount) public view returns (uint256) {\n        return (_avaxAmount * rJoePerAvax) / 1e18;\n    }\n\n    /// @notice The total amount of liquidity pool tokens the user can withdraw\n    /// @param _user The address of the user to check\n    /// @return The user's balance of liquidity pool token\n    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n    /// @dev Bytecode size optimization for the `atPhase` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _atPhase(Phase _phase) internal view {\n        require(currentPhase() == _phase, \"LaunchEvent: wrong phase\");\n    }\n\n    /// @dev Bytecode size optimization for the `timelockElapsed` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _timelockElapsed() internal view {\n        uint256 phase3Start = auctionStart +\n            phaseOneDuration +\n            phaseTwoDuration;\n        if (msg.sender == issuer) {\n            require(\n                block.timestamp > phase3Start + issuerTimelock,\n                \"LaunchEvent: can't withdraw before issuer's timelock\"\n            );\n        } else {\n            require(\n                block.timestamp > phase3Start + userTimelock,\n                \"LaunchEvent: can't withdraw before user's timelock\"\n            );\n        }\n    }\n\n    /// @dev Bytecode size optimization for the `isStopped` modifier\n    /// This works becuase internal functions are not in-lined in modifiers\n    function _isStopped(bool _stopped) internal view {\n        if (_stopped) {\n            require(stopped, \"LaunchEvent: is still running\");\n        } else {\n            require(!stopped, \"LaunchEvent: stopped\");\n        }\n    }\n\n    /// @notice Send AVAX\n    /// @param _to The receiving address\n    /// @param _value The amount of AVAX to send\n    /// @dev Will revert on failure\n    function _safeTransferAVAX(address _to, uint256 _value) internal {\n        require(\n            address(this).balance - _value >= avaxReserve,\n            \"LaunchEvent: not enough avax\"\n        );\n        (bool success, ) = _to.call{value: _value}(new bytes(0));\n        require(success, \"LaunchEvent: avax transfer failed\");\n    }\n}\n",
        "formal_property": "rule cl_tokenIncentivesBalancesNonIncreasing(method f, env e){\n    require initialized();\n    // require pair() != 0;\n    // require pair() == Factory.getPair(e, WAVAX(), token());\n\n    uint256 tokenIncentivesBalanceBefore = tokenIncentivesBalance();\n    calldataarg args;\n    f(e, args);\n    uint256 tokenIncentivesBalanceAfter = tokenIncentivesBalance();\n    assert tokenIncentivesBalanceBefore >= tokenIncentivesBalanceAfter, \"token incentives balance was increased\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_tokenIncentivesBalancesNonIncreasing",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "initialize",
                "initialized",
                "WAVAX",
                "token",
                "pair",
                "tokenIncentivesBalance"
            ],
            "start_line": 1005,
            "end_line": 1018,
            "block_hash": "782c42687dc54b18e1159733122c80b3"
        }
    },
    {
        "id": "LaunchEvent_cl_tokenIncentivesBalanceCanBeZero_20bf34c1",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "emergencyWithdraw",
        "text_chunk": "    function emergencyWithdraw() external isStopped(true) {\n        if (address(pair) == address(0)) {\n            if (msg.sender != issuer) {\n                UserInfo storage user = getUserInfo[msg.sender];\n                require(\n                    user.balance > 0,\n                    \"LaunchEvent: expected user to have non-zero balance to perform emergency withdraw\"\n                );\n\n                uint256 balance = user.balance;\n                user.balance = 0;\n                avaxReserve -= balance;\n\n                _safeTransferAVAX(msg.sender, balance);\n\n                emit AvaxEmergencyWithdraw(msg.sender, balance);\n            } else {\n                uint256 balance = tokenReserve + tokenIncentivesBalance;\n                tokenReserve = 0;\n                tokenIncentivesBalance = 0;\n                token.safeTransfer(issuer, balance);\n                emit TokenEmergencyWithdraw(msg.sender, balance);\n            }\n        } else {\n            UserInfo storage user = getUserInfo[msg.sender];\n\n            uint256 balance = pairBalance(msg.sender);\n            require(\n                balance > 0,\n                \"LaunchEvent: caller has no liquidity to claim\"\n            );\n\n            user.hasWithdrawnPair = true;\n\n            if (msg.sender == issuer) {\n                emit IssuerLiquidityWithdrawn(\n                    msg.sender,\n                    address(pair),\n                    balance\n                );\n            } else {\n                emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n            }\n\n            pair.transfer(msg.sender, balance);\n        }\n    }\n",
        "formal_property": "rule cl_tokenIncentivesBalanceCanBeZero(method f, env e){\n    require initialized();          // initialize()\n\n    uint256 tokenIncentivesBalanceBefore = tokenIncentivesBalance();\n    require tokenIncentivesBalanceBefore > 0;\n    calldataarg args;\n    f(e, args);\n    uint256 tokenIncentivesBalanceAfter = tokenIncentivesBalance();\n    assert tokenIncentivesBalanceAfter == 0 <=> f.selector == emergencyWithdraw().selector, \"tokenIncentivesBalance is 0 unintentionally\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "cl_tokenIncentivesBalanceCanBeZero",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "initialize",
                "emergencyWithdraw",
                "initialized",
                "token",
                "tokenIncentivesBalance"
            ],
            "start_line": 1025,
            "end_line": 1038,
            "block_hash": "20bf34c13094f7e4595b254ef062e0a2"
        }
    },
    {
        "id": "LaunchEvent_hl_depositAdditivity_167b3f15",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "depositAVAX",
        "text_chunk": "    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n",
        "formal_property": "rule hl_depositAdditivity(env e, env e2){\n    require e.msg.value > 0;\n    require e.msg.value == 2 * e2.msg.value;\n    require e.msg.sender != e2.msg.sender;\n\n    uint256 userOneBalanceBefore = getUserBalance(e.msg.sender);\n    depositAVAX(e);\n    uint256 userOneBalanceAfter = getUserBalance(e.msg.sender);\n    \n    uint256 userTwoBalanceBefore = getUserBalance(e2.msg.sender);\n    require userOneBalanceBefore == userTwoBalanceBefore;\n    depositAVAX(e2);\n    uint256 userTwoBalanceAfter = getUserBalance(e2.msg.sender);\n    assert userOneBalanceAfter == userTwoBalanceAfter, \"deposit is not additive\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_depositAdditivity",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "depositAVAX",
                "getUserBalance"
            ],
            "start_line": 1097,
            "end_line": 1113,
            "block_hash": "167b3f1523dfc2de1f777beb8fdafd03"
        }
    },
    {
        "id": "LaunchEvent_hl_withdrawAdditivity_d369e83e",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "withdrawAVAX",
        "text_chunk": "    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n",
        "formal_property": "rule hl_withdrawAdditivity(env e){\n    uint256 single; uint256 doubleOne; uint256 doubleTwo;\n    require single > 0 && doubleOne > 0 && doubleTwo > 0;\n    require single == doubleOne + doubleTwo;\n\n    uint256 userBalanceAtStart = getUserBalance(e.msg.sender);\n    storage initialStorage = lastStorage;\n    withdrawAVAX(e, single);\n    uint256 userBalanceAfterSingle = getUserBalance(e.msg.sender);\n    withdrawAVAX(e, doubleOne) at initialStorage;\n    withdrawAVAX(e, doubleTwo);\n    uint256 userBalanceAfterDouble = getUserBalance(e.msg.sender);\n    assert userBalanceAfterSingle == userBalanceAfterDouble, \"withdraw is not additive\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_withdrawAdditivity",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "withdrawAVAX",
                "getUserBalance"
            ],
            "start_line": 1117,
            "end_line": 1135,
            "block_hash": "d369e83e42bd8c8daadbe8cb5843c834"
        }
    },
    {
        "id": "LaunchEvent_hl_moreDepositMoreGet_790a5a70",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "pairBalance/withdrawIncentives/withdrawLiquidity",
        "text_chunk": "    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n\n    function withdrawIncentives() external {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        uint256 amount = getIncentives(msg.sender);\n        require(amount > 0, \"LaunchEvent: caller has no incentive to claim\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        user.hasWithdrawnIncentives = true;\n\n        if (msg.sender == issuer) {\n            tokenIncentivesBalance -= tokenIncentiveIssuerRefund;\n            tokenReserve = 0;\n        } else {\n            tokenIncentivesBalance -= amount;\n        }\n\n        token.safeTransfer(msg.sender, amount);\n        emit IncentiveTokenWithdraw(msg.sender, address(token), amount);\n    }\n\n\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n",
        "formal_property": "rule hl_moreDepositMoreGet(method f, env e, env e2){\n    require e.msg.sender != e2.msg.sender;\n    require e.msg.sender != issuer();\n    require e2.msg.sender != issuer();\n    require e.msg.sender != currentContract;\n    require e2.msg.sender != currentContract;\n    require lpSupply() >= avaxAllocated(); // assumption, need to double check\n    require token() == SymbERC20A || token() == SymbERC20B;\n\n    uint256 balanceOfuser1 = getUserBalance(e.msg.sender);\n    uint256 balanceOfuser2 = getUserBalance(e2.msg.sender);\n    require balanceOfuser2 > balanceOfuser1;\n    require avaxAllocated() >= balanceOfuser2 + balanceOfuser1;\n    uint256 pairOfuser1Before = getPairBalance(e.msg.sender);\n    uint256 tokenOfuser1Before = getTokenBalance(e.msg.sender);\n    uint256 pairOfuser2Before = getPairBalance(e2.msg.sender);\n    uint256 tokenOfuser2Before = getTokenBalance(e2.msg.sender);\n    require pairOfuser1Before == pairOfuser2Before;\n    require tokenOfuser1Before == tokenOfuser2Before;\n    withdrawLiquidity(e);\n    withdrawIncentives(e);\n    // check how much can I withdrawLiquidity or how much I withdrawn\n    uint256 pairOfuser1After = getPairBalance(e.msg.sender);\n    // check how much can I withdrawIncentives or how much I withdrawn\n    uint256 tokenOfuser1After = getTokenBalance(e.msg.sender);\n    withdrawLiquidity(e2);\n    withdrawIncentives(e2);\n    uint256 pairOfuser2After = getPairBalance(e2.msg.sender);\n    uint256 tokenOfuser2After = getTokenBalance(e2.msg.sender);\n    //assert\n    assert pairOfuser1After < pairOfuser2After && tokenOfuser1After < tokenOfuser2After, \"more deposit doesn't guarantee more rewards\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_moreDepositMoreGet",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "withdrawLiquidity",
                "withdrawIncentives",
                "issuer",
                "token",
                "avaxAllocated",
                "pair",
                "lpSupply",
                "getUserBalance",
                "getPairBalance",
                "getTokenBalance"
            ],
            "start_line": 1149,
            "end_line": 1188,
            "block_hash": "790a5a7064f3bce7ae6490fdd3ce19d7"
        }
    },
    {
        "id": "LaunchEvent_hl_withdrawLateMorePenalty_8a17898a",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "getPenalty",
        "text_chunk": "    function getPenalty() public view returns (uint256) {\n        if (block.timestamp < auctionStart) {\n            return 0;\n        }\n        uint256 timeElapsed = block.timestamp - auctionStart;\n        if (timeElapsed < phaseOneNoFeeDuration) {\n            return 0;\n        } else if (timeElapsed < phaseOneDuration) {\n            return\n                ((timeElapsed - phaseOneNoFeeDuration) * maxWithdrawPenalty) /\n                (phaseOneDuration - phaseOneNoFeeDuration);\n        }\n        return fixedWithdrawPenalty;\n    }\n",
        "formal_property": "rule hl_withdrawLateMorePenalty(method f, env e, env e2){\n    // define phase 1, the second half\n\n    require auctionStart() < e.block.timestamp;\n    require e.block.timestamp < e2.block.timestamp;\n    require e.block.timestamp > oneDay() && e.block.timestamp < twoDays();\n    require e2.block.timestamp < twoDays();\n    require e.msg.sender == e2.msg.sender;\n    require e.msg.sender != issuer();\n    require e.msg.sender != currentContract;\n    uint256 earlyPenalty = getPenalty(e);\n    uint256 latePenalty = getPenalty(e2);\n    assert earlyPenalty < latePenalty, \"penalty isn't greater\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_withdrawLateMorePenalty",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "getPenalty",
                "issuer",
                "auctionStart"
            ],
            "start_line": 1194,
            "end_line": 1210,
            "block_hash": "8a17898abf9c102a2d8a65de6adc9035"
        }
    },
    {
        "id": "LaunchEvent_hl_twoSideInverse_80aa2045",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "depositAVAX/withdrawAVAX",
        "text_chunk": "    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n\n\n    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n",
        "formal_property": "rule hl_twoSideInverse(env e){\n    uint256 amount;\n\n    storage initialStorage = lastStorage;\n    depositAVAX(e);\n    withdrawAVAX(e, amount);\n    uint256 balanceOfUser1 = getUserBalance(e.msg.sender);\n    withdrawAVAX(e, amount) at initialStorage;\n    uint256 balanceOfUser2 = getUserBalance(e.msg.sender);\n    assert balanceOfUser1 == balanceOfUser2, \"balances are different\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_twoSideInverse",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "depositAVAX",
                "withdrawAVAX",
                "getUserBalance"
            ],
            "start_line": 1218,
            "end_line": 1232,
            "block_hash": "80aa2045947e3f82b3abeee6dd244908"
        }
    },
    {
        "id": "LaunchEvent_hl_noDepositFrontRun_151f3736",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "depositAVAX",
        "text_chunk": "    function depositAVAX()\n        external\n        payable\n        isStopped(false)\n        atPhase(Phase.PhaseOne)\n    {\n        require(msg.sender != issuer, \"LaunchEvent: issuer cannot participate\");\n        require(\n            msg.value > 0,\n            \"LaunchEvent: expected non-zero AVAX to deposit\"\n        );\n\n        UserInfo storage user = getUserInfo[msg.sender];\n        uint256 newAllocation = user.balance + msg.value;\n        require(\n            newAllocation <= maxAllocation,\n            \"LaunchEvent: amount exceeds max allocation\"\n        );\n\n        uint256 rJoeNeeded;\n        // check if additional allocation is required.\n        if (newAllocation > user.allocation) {\n            // Get amount of rJOE tokens needed to burn and update allocation\n            rJoeNeeded = getRJoeAmount(newAllocation - user.allocation);\n            // Set allocation to the current balance as it's impossible\n            // to buy more allocation without sending AVAX too\n            user.allocation = newAllocation;\n        }\n\n        user.balance = newAllocation;\n        avaxReserve += msg.value;\n\n        if (rJoeNeeded > 0) {\n            rJoe.burnFrom(msg.sender, rJoeNeeded);\n        }\n\n        emit UserParticipated(msg.sender, msg.value, rJoeNeeded);\n    }\n",
        "formal_property": "rule hl_noDepositFrontRun(method f, env e, env e2){\n    require e.msg.sender != e2.msg.sender;\n\n    calldataarg args;\n    storage initialStorage = lastStorage;\n    uint256 userBalanceBefore = getUserBalance(e.msg.sender);\n    depositAVAX(e);\n    uint256 userBalanceAfter1 = getUserBalance(e.msg.sender);\n    f(e2, args) at initialStorage;\n    uint256 userBalanceAfter2 = getUserBalance(e.msg.sender);\n    assert userBalanceBefore + e.msg.value == userBalanceAfter1 && userBalanceBefore + e.msg.value == userBalanceAfter2, \"frontrun on Deposit\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_noDepositFrontRun",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "depositAVAX",
                "getUserBalance"
            ],
            "start_line": 1237,
            "end_line": 1254,
            "block_hash": "151f37363be90758a3940799841d3321"
        }
    },
    {
        "id": "LaunchEvent_hl_noWithdrawFrontRun_cca8d8ad",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "withdrawAVAX",
        "text_chunk": "    function withdrawAVAX(uint256 _amount) external isStopped(false) {\n        Phase _currentPhase = currentPhase();\n        require(\n            _currentPhase == Phase.PhaseOne || _currentPhase == Phase.PhaseTwo,\n            \"LaunchEvent: unable to withdraw\"\n        );\n        require(_amount > 0, \"LaunchEvent: invalid withdraw amount\");\n        UserInfo storage user = getUserInfo[msg.sender];\n        require(\n            user.balance >= _amount,\n            \"LaunchEvent: withdrawn amount exceeds balance\"\n        );\n        user.balance -= _amount;\n\n        uint256 feeAmount = (_amount * getPenalty()) / 1e18;\n        uint256 amountMinusFee = _amount - feeAmount;\n\n        avaxReserve -= _amount;\n\n        if (feeAmount > 0) {\n            _safeTransferAVAX(rocketJoeFactory.penaltyCollector(), feeAmount);\n        }\n        _safeTransferAVAX(msg.sender, amountMinusFee);\n        emit UserWithdrawn(msg.sender, _amount, feeAmount);\n    }\n",
        "formal_property": "rule hl_noWithdrawFrontRun(method f, env e, env e2){\n    require e.msg.sender != e2.msg.sender;\n    uint256 amount;\n\n    calldataarg args;\n    storage initialStorage = lastStorage;\n    uint256 userBalanceBefore = getUserBalance(e.msg.sender);\n    withdrawAVAX(e, amount);\n    uint256 userBalanceAfter1 = getUserBalance(e.msg.sender);\n    f(e2, args) at initialStorage;\n    uint256 userBalanceAfter2 = getUserBalance(e.msg.sender);\n    assert userBalanceBefore - amount == userBalanceAfter1 && userBalanceBefore - amount == userBalanceAfter2, \"frontrun on Withdraw\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_noWithdrawFrontRun",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "withdrawAVAX",
                "getUserBalance"
            ],
            "start_line": 1259,
            "end_line": 1277,
            "block_hash": "cca8d8adfb14ae7fc0f98fe62f8c6066"
        }
    },
    {
        "id": "LaunchEvent_hl_noWithdrawLiquidityFrontRun_b7cb43d2",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "pairBalance/withdrawLiquidity",
        "text_chunk": "    function pairBalance(address _user) public view returns (uint256) {\n        UserInfo memory user = getUserInfo[_user];\n        if (avaxAllocated == 0 || user.hasWithdrawnPair) {\n            return 0;\n        }\n        if (msg.sender == issuer) {\n            return lpSupply / 2;\n        }\n        return (user.balance * lpSupply) / avaxAllocated / 2;\n    }\n\n\n    function withdrawLiquidity() external isStopped(false) timelockElapsed {\n        require(address(pair) != address(0), \"LaunchEvent: pair not created\");\n\n        UserInfo storage user = getUserInfo[msg.sender];\n\n        uint256 balance = pairBalance(msg.sender);\n        require(balance > 0, \"LaunchEvent: caller has no liquidity to claim\");\n\n        user.hasWithdrawnPair = true;\n\n        if (msg.sender == issuer) {\n            emit IssuerLiquidityWithdrawn(msg.sender, address(pair), balance);\n        } else {\n            emit UserLiquidityWithdrawn(msg.sender, address(pair), balance);\n        }\n\n        pair.transfer(msg.sender, balance);\n    }\n",
        "formal_property": "rule hl_noWithdrawLiquidityFrontRun(method f, env e, env e2){\n    require e.msg.sender != e2.msg.sender;\n    require e.msg.sender != currentContract;\n    require e2.msg.sender != currentContract;\n\n    calldataarg args;\n    storage initialStorage = lastStorage;\n    uint256 userBalanceBefore = getPairBalance(e.msg.sender);\n    uint256 whatShouldGet1 = pairBalance(e, e.msg.sender);\n    withdrawLiquidity(e);\n    uint256 userBalanceAfter1 = getPairBalance(e.msg.sender);\n    f(e2, args) at initialStorage;\n    uint256 whatShouldGet2 = pairBalance(e, e.msg.sender);\n    uint256 userBalanceAfter2 = getPairBalance(e.msg.sender);\n    assert whatShouldGet1 == whatShouldGet2, \"should get differs\";\n    assert userBalanceBefore + whatShouldGet1 == userBalanceAfter1 && userBalanceBefore + whatShouldGet2 == userBalanceAfter2, \"frontrun on WithdrawLiquidity\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_noWithdrawLiquidityFrontRun",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "withdrawLiquidity",
                "pairBalance",
                "pair",
                "getPairBalance"
            ],
            "start_line": 1283,
            "end_line": 1304,
            "block_hash": "b7cb43d2fc2073ea37275c84a49fbb21"
        }
    },
    {
        "id": "LaunchEvent_hl_createPairAtLeastOnce_0544e780",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LaunchEvent.sol",
        "target_function": "createPair",
        "text_chunk": "    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        address _pair = factory.getPair(wavaxAddress, tokenAddress);\n        require(\n            _pair == address(0) || IJoePair(_pair).totalSupply() == 0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(avaxReserve > 0, \"LaunchEvent: no avax balance\");\n\n        uint256 tokenDecimals = token.decimals();\n        tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (floorPrice > (avaxReserve * 10**tokenDecimals) / tokenAllocated) {\n            tokenAllocated = (avaxReserve * 10**tokenDecimals) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        avaxAllocated = avaxReserve;\n        avaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        WAVAX.deposit{value: avaxAllocated}();\n        if (_pair == address(0)) {\n            pair = IJoePair(factory.createPair(wavaxAddress, tokenAddress));\n        } else {\n            pair = IJoePair(_pair);\n        }\n        WAVAX.transfer(address(pair), avaxAllocated);\n        token.safeTransfer(address(pair), tokenAllocated);\n        lpSupply = pair.mint(address(this));\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            avaxAllocated\n        );\n    }\n",
        "formal_property": "rule hl_createPairAtLeastOnce(env e){\n    require !stopped();\n\n    // storage\n    createPair(e);\n    assert !lastReverted, \"createPair DoS\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hl_createPairAtLeastOnce",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "createPair",
                "stopped"
            ],
            "start_line": 1309,
            "end_line": 1320,
            "block_hash": "0544e780e07279cd32029365b1446898"
        }
    }
]