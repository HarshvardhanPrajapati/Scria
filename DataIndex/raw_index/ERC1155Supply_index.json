[
    {
        "id": "ERC1155Supply_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC1155Supply.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                _totalSupply[ids[i]] += amounts[i];\n            }\n        }\n\n        if (to == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 id = ids[i];\n                uint256 amount = amounts[i];\n                uint256 supply = _totalSupply[id];\n                require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");\n                unchecked {\n                    _totalSupply[id] = supply - amount;\n                }\n            }\n        }\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "totalSupply",
                "exists",
                "_beforeTokenTransfer"
            ],
            "state_variables": [
                "_totalSupply"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC1155Supply_total_supply_is_sum_of_balances_625f2010",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC1155Supply.sol",
        "target_function": "totalSupply",
        "text_chunk": "    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n",
        "formal_property": "invariant total_supply_is_sum_of_balances(uint256 token)\n    sumOfBalances[token] == totalSupply(token)\n    {\n        preserved {\n            requireInvariant balanceOfZeroAddressIsZero(token);\ninvariant balanceOfZeroAddressIsZero(uint256 token)\n    balanceOf(0, token) == 0\n\n/// If a user has a token, then the token should exist.\nrule held_tokens_should_exist {\n    address user; uint256 token;\n    requireInvariant balanceOfZeroAddressIsZero(token);\n    // This assumption is safe because of total_supply_is_sum_of_balances\n    require balanceOf(user, token) <= totalSupply(token);\n    // note: `exists_wrapper` just calls `exists`\n    assert balanceOf(user, token) > 0 => exists_wrapper(token),\n        \"if a user's balance for a token is positive, the token must exist\";\n}\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "total_supply_is_sum_of_balances",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "totalSupply",
                "balanceOf"
            ],
            "start_line": 45,
            "end_line": 51,
            "block_hash": "625f2010ecc0a6d2780b83ade6d7ed6b"
        }
    },
    {
        "id": "ERC1155Supply_balanceOfZeroAddressIsZero_835be1fa",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC1155Supply.sol",
        "target_function": "totalSupply",
        "text_chunk": "    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n",
        "formal_property": "invariant balanceOfZeroAddressIsZero(uint256 token)\n    balanceOf(0, token) == 0\n\n/// If a user has a token, then the token should exist.\nrule held_tokens_should_exist {\n    address user; uint256 token;\n    requireInvariant balanceOfZeroAddressIsZero(token);\n    // This assumption is safe because of total_supply_is_sum_of_balances\ninvariant total_supply_is_sum_of_balances(uint256 token)\n    sumOfBalances[token] == totalSupply(token)\n    {\n        preserved {\n            requireInvariant balanceOfZeroAddressIsZero(token);\n    require balanceOf(user, token) <= totalSupply(token);\n    // note: `exists_wrapper` just calls `exists`\n    assert balanceOf(user, token) > 0 => exists_wrapper(token),\n        \"if a user's balance for a token is positive, the token must exist\";\n}\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "balanceOfZeroAddressIsZero",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "totalSupply",
                "balanceOf",
                "exists_wrapper"
            ],
            "start_line": 56,
            "end_line": 71,
            "block_hash": "835be1fae97f8e9ebcc4092140b49551"
        }
    },
    {
        "id": "ERC1155Supply_token_totalSupply_independence_dc6e140a",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Supply.sol",
        "target_function": "totalSupply",
        "text_chunk": "    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n",
        "formal_property": "rule token_totalSupply_independence(method f)\nfiltered {\n    f -> f.selector != safeBatchTransferFrom(address,address,uint256[],uint256[],bytes).selector\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "token_totalSupply_independence",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "totalSupply"
            ],
            "start_line": 11,
            "end_line": 14,
            "block_hash": "dc6e140a7e616b86053cb791183477df"
        }
    },
    {
        "id": "ERC1155Supply_held_tokens_should_exist_2aa87e4b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Supply.sol",
        "target_function": "totalSupply",
        "text_chunk": "    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n",
        "formal_property": "rule held_tokens_should_exist {\n    address user; uint256 token;\n\n    requireInvariant balanceOfZeroAddressIsZero(token);\ninvariant balanceOfZeroAddressIsZero(uint256 token)\n    balanceOf(0, token) == 0\n/// If a user has a token, then the token should exist.\n    // This assumption is safe because of total_supply_is_sum_of_balances\ninvariant total_supply_is_sum_of_balances(uint256 token)\n    sumOfBalances[token] == totalSupply(token)\n    {\n        preserved {\n            requireInvariant balanceOfZeroAddressIsZero(token);\n    require balanceOf(user, token) <= totalSupply(token);\n    // note: `exists_wrapper` just calls `exists`\n    assert balanceOf(user, token) > 0 => exists_wrapper(token),\n        \"if a user's balance for a token is positive, the token must exist\";\n}\n        }\n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "held_tokens_should_exist",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "totalSupply",
                "balanceOf",
                "exists_wrapper"
            ],
            "start_line": 60,
            "end_line": 71,
            "block_hash": "2aa87e4b0c18f4de91d6d33843bef97e"
        }
    },
    {
        "id": "ERC1155Supply_sanity_8c5c3208",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Supply.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                _totalSupply[ids[i]] += amounts[i];\n            }\n        }\n\n        if (to == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 id = ids[i];\n                uint256 amount = amounts[i];\n                uint256 supply = _totalSupply[id];\n                require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");\n                unchecked {\n                    _totalSupply[id] = supply - amount;\n                }\n            }\n        }\n    }\n}\n",
        "formal_property": "rule sanity {\n    method f; env e; calldataarg args;\n\n    f(e, args);\n    assert false;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sanity",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 75,
            "end_line": 81,
            "block_hash": "8c5c3208b3ec20693ea4068611567512"
        }
    }
]