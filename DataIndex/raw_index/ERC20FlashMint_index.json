[
    {
        "id": "ERC20FlashMint_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC20FlashMint.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../../../interfaces/IERC3156FlashBorrower.sol\";\nimport \"../../../interfaces/IERC3156FlashLender.sol\";\nimport \"../ERC20.sol\";\n\nabstract contract ERC20FlashMint is ERC20, IERC3156FlashLender {\n    bytes32 private constant _RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    function maxFlashLoan(address token) public view virtual override returns (uint256) {\n        return token == address(this) ? type(uint256).max - ERC20.totalSupply() : 0;\n    }\n\n    function flashFee(address token, uint256 amount) public view virtual override returns (uint256) {\n        require(token == address(this), \"ERC20FlashMint: wrong token\");\n        amount;\n        return 0;\n    }\n\n    function _flashFeeReceiver() internal view virtual returns (address) {\n        return address(0);\n    }\n\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override returns (bool) {\n        require(amount <= maxFlashLoan(token), \"ERC20FlashMint: amount exceeds maxFlashLoan\");\n        uint256 fee = flashFee(token, amount);\n        _mint(address(receiver), amount);\n        require(\n            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == _RETURN_VALUE,\n            \"ERC20FlashMint: invalid return value\"\n        );\n        address flashFeeReceiver = _flashFeeReceiver();\n        _spendAllowance(address(receiver), address(this), amount + fee);\n        if (fee == 0 || flashFeeReceiver == address(0)) {\n            _burn(address(receiver), amount + fee);\n        } else {\n            _burn(address(receiver), amount);\n            _transfer(address(receiver), flashFeeReceiver, fee);\n        }\n        return true;\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "maxFlashLoan",
                "flashFee",
                "_flashFeeReceiver",
                "flashLoan"
            ],
            "state_variables": [],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC20FlashMint_letsWatchItBurns_9cf58e59",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC20FlashMint.sol",
        "target_function": "flashFee/flashLoan",
        "text_chunk": "    function flashFee(address token, uint256 amount) public view virtual override returns (uint256) {\n        require(token == address(this), \"ERC20FlashMint: wrong token\");\n        amount;\n        return 0;\n    }\n\n\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override returns (bool) {\n        require(amount <= maxFlashLoan(token), \"ERC20FlashMint: amount exceeds maxFlashLoan\");\n        uint256 fee = flashFee(token, amount);\n        _mint(address(receiver), amount);\n        require(\n            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == _RETURN_VALUE,\n            \"ERC20FlashMint: invalid return value\"\n        );\n        address flashFeeReceiver = _flashFeeReceiver();\n        _spendAllowance(address(receiver), address(this), amount + fee);\n        if (fee == 0 || flashFeeReceiver == address(0)) {\n            _burn(address(receiver), amount + fee);\n        } else {\n            _burn(address(receiver), amount);\n            _transfer(address(receiver), flashFeeReceiver, fee);\n        }\n        return true;\n    }\n",
        "formal_property": "rule letsWatchItBurns(env e){\n    address receiver; address token; uint256 amount; bytes data;\n\n    uint256 feeBefore = flashFee(e, token, amount);\n    flashLoan(e, receiver, token, amount, data);\n    uint256 burned = trackedBurnAmount[receiver];\n    assert to_mathint(amount + feeBefore) == burned, \"cheater\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "letsWatchItBurns",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [],
            "start_line": 18,
            "end_line": 28,
            "block_hash": "9cf58e5993110d423e5eecec35d3f37c"
        }
    }
]