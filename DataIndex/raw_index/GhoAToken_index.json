[
    {
        "id": "GhoAToken_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "GhoAToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IERC20} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol';\nimport {GPv2SafeERC20} from '@aave/core-v3/contracts/dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {VersionedInitializable} from '@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {Errors} from '@aave/core-v3/contracts/protocol/libraries/helpers/Errors.sol';\nimport {WadRayMath} from '@aave/core-v3/contracts/protocol/libraries/math/WadRayMath.sol';\nimport {IPool} from '@aave/core-v3/contracts/interfaces/IPool.sol';\nimport {IAToken} from '@aave/core-v3/contracts/interfaces/IAToken.sol';\nimport {IAaveIncentivesController} from '@aave/core-v3/contracts/interfaces/IAaveIncentivesController.sol';\nimport {IInitializableAToken} from '@aave/core-v3/contracts/interfaces/IInitializableAToken.sol';\nimport {ScaledBalanceTokenBase} from '@aave/core-v3/contracts/protocol/tokenization/base/ScaledBalanceTokenBase.sol';\nimport {IncentivizedERC20} from '@aave/core-v3/contracts/protocol/tokenization/base/IncentivizedERC20.sol';\nimport {EIP712Base} from '@aave/core-v3/contracts/protocol/tokenization/base/EIP712Base.sol';\n\n// Gho Imports\nimport {IGhoToken} from '../../../gho/interfaces/IGhoToken.sol';\nimport {IGhoFacilitator} from '../../../gho/interfaces/IGhoFacilitator.sol';\nimport {IGhoAToken} from './interfaces/IGhoAToken.sol';\nimport {GhoVariableDebtToken} from './GhoVariableDebtToken.sol';\n\n/**\n * @title GhoAToken\n * @author Aave\n * @notice Implementation of the interest bearing token for the Aave protocol\n */\ncontract GhoAToken is VersionedInitializable, ScaledBalanceTokenBase, EIP712Base, IGhoAToken {\n  using WadRayMath for uint256;\n  using GPv2SafeERC20 for IERC20;\n\n  bytes32 public constant PERMIT_TYPEHASH =\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\n\n  uint256 public constant ATOKEN_REVISION = 0x1;\n\n  address internal _treasury;\n  address internal _underlyingAsset;\n\n  // Gho Storage\n  GhoVariableDebtToken internal _ghoVariableDebtToken;\n  address internal _ghoTreasury;\n\n  /// @inheritdoc VersionedInitializable\n  function getRevision() internal pure virtual override returns (uint256) {\n    return ATOKEN_REVISION;\n  }\n\n  /**\n   * @dev Constructor.\n   * @param pool The address of the Pool contract\n   */\n  constructor(\n    IPool pool\n  ) ScaledBalanceTokenBase(pool, 'GHO_ATOKEN_IMPL', 'GHO_ATOKEN_IMPL', 0) EIP712Base() {\n    // Intentionally left blank\n  }\n\n  /// @inheritdoc IInitializableAToken\n  function initialize(\n    IPool initializingPool,\n    address treasury,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 aTokenDecimals,\n    string calldata aTokenName,\n    string calldata aTokenSymbol,\n    bytes calldata params\n  ) external override initializer {\n    require(initializingPool == POOL, Errors.POOL_ADDRESSES_DO_NOT_MATCH);\n    _setName(aTokenName);\n    _setSymbol(aTokenSymbol);\n    _setDecimals(aTokenDecimals);\n\n    _treasury = treasury;\n    _underlyingAsset = underlyingAsset;\n    _incentivesController = incentivesController;\n\n    _domainSeparator = _calculateDomainSeparator();\n\n    emit Initialized(\n      underlyingAsset,\n      address(POOL),\n      treasury,\n      address(incentivesController),\n      aTokenDecimals,\n      aTokenName,\n      aTokenSymbol,\n      params\n    );\n  }\n\n  /// @inheritdoc IAToken\n  function mint(\n    address caller,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external virtual override onlyPool returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IAToken\n  function burn(\n    address from,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external virtual override onlyPool {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IAToken\n  function mintToTreasury(uint256 amount, uint256 index) external virtual override onlyPool {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IAToken\n  function transferOnLiquidation(\n    address from,\n    address to,\n    uint256 value\n  ) external virtual override onlyPool {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IERC20\n  function balanceOf(\n    address user\n  ) public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IERC20\n  function totalSupply() public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IAToken\n  function RESERVE_TREASURY_ADDRESS() external view override returns (address) {\n    return _treasury;\n  }\n\n  /// @inheritdoc IAToken\n  function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @notice Transfers the underlying asset to `target`.\n   * @dev It performs a mint of GHO on behalf of the `target`\n   * @dev Used by the Pool to transfer assets in borrow(), withdraw() and flashLoan()\n   * @param target The recipient of the underlying\n   * @param amount The amount getting transferred\n   */\n  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {\n    IGhoToken(_underlyingAsset).mint(target, amount);\n  }\n\n  /// @inheritdoc IAToken\n  function handleRepayment(\n    address user,\n    address onBehalfOf,\n    uint256 amount\n  ) external virtual override onlyPool {\n    uint256 balanceFromInterest = _ghoVariableDebtToken.getBalanceFromInterest(onBehalfOf);\n    if (amount <= balanceFromInterest) {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, amount);\n    } else {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, balanceFromInterest);\n      IGhoToken(_underlyingAsset).burn(amount - balanceFromInterest);\n    }\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function distributeFeesToTreasury() external virtual override {\n    uint256 balance = IERC20(_underlyingAsset).balanceOf(address(this));\n    IERC20(_underlyingAsset).transfer(_ghoTreasury, balance);\n    emit FeesDistributedToTreasury(_ghoTreasury, _underlyingAsset, balance);\n  }\n\n  /// @inheritdoc IAToken\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /**\n   * @notice Overrides the parent _transfer to force validated transfer() and transferFrom()\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   */\n  function _transfer(address from, address to, uint128 amount) internal override {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /**\n   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.DOMAIN_SEPARATOR()` for more detailed documentation\n   */\n  function DOMAIN_SEPARATOR() public view override(IAToken, EIP712Base) returns (bytes32) {\n    return super.DOMAIN_SEPARATOR();\n  }\n\n  /**\n   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.nonces()` for more detailed documentation\n   */\n  function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256) {\n    return super.nonces(owner);\n  }\n\n  /// @inheritdoc EIP712Base\n  function _EIP712BaseId() internal view override returns (string memory) {\n    return name();\n  }\n\n  /// @inheritdoc IAToken\n  function rescueTokens(address token, address to, uint256 amount) external override onlyPoolAdmin {\n    require(token != _underlyingAsset, Errors.UNDERLYING_CANNOT_BE_RESCUED);\n    IERC20(token).safeTransfer(to, amount);\n  }\n\n  /// @inheritdoc IGhoAToken\n  function setVariableDebtToken(address ghoVariableDebtToken) external override onlyPoolAdmin {\n    require(address(_ghoVariableDebtToken) == address(0), 'VARIABLE_DEBT_TOKEN_ALREADY_SET');\n    require(ghoVariableDebtToken != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    _ghoVariableDebtToken = GhoVariableDebtToken(ghoVariableDebtToken);\n    emit VariableDebtTokenSet(ghoVariableDebtToken);\n  }\n\n  /// @inheritdoc IGhoAToken\n  function getVariableDebtToken() external view override returns (address) {\n    return address(_ghoVariableDebtToken);\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function updateGhoTreasury(address newGhoTreasury) external override onlyPoolAdmin {\n    require(newGhoTreasury != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    address oldGhoTreasury = _ghoTreasury;\n    _ghoTreasury = newGhoTreasury;\n    emit GhoTreasuryUpdated(oldGhoTreasury, newGhoTreasury);\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function getGhoTreasury() external view override returns (address) {\n    return _ghoTreasury;\n  }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "getRevision",
                "initialize",
                "mint",
                "burn",
                "mintToTreasury",
                "transferOnLiquidation",
                "balanceOf",
                "totalSupply",
                "RESERVE_TREASURY_ADDRESS",
                "UNDERLYING_ASSET_ADDRESS",
                "transferUnderlyingTo",
                "handleRepayment",
                "distributeFeesToTreasury",
                "permit",
                "_transfer",
                "to",
                "_EIP712BaseId",
                "rescueTokens",
                "setVariableDebtToken",
                "getVariableDebtToken",
                "updateGhoTreasury",
                "getGhoTreasury"
            ],
            "state_variables": [
                "_ghoVariableDebtToken",
                "_treasury",
                "_underlyingAsset",
                "_ghoTreasury"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "GhoAToken_userBalanceAlwaysZero_151889bb",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoAToken.sol",
        "target_function": "balanceOf/handleRepayment/to/transferUnderlyingTo",
        "text_chunk": "  function balanceOf(\n    address user\n  ) public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n    return 0;\n  }\n\n\n  function handleRepayment(\n    address user,\n    address onBehalfOf,\n    uint256 amount\n  ) external virtual override onlyPool {\n    uint256 balanceFromInterest = _ghoVariableDebtToken.getBalanceFromInterest(onBehalfOf);\n    if (amount <= balanceFromInterest) {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, amount);\n    } else {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, balanceFromInterest);\n      IGhoToken(_underlyingAsset).burn(amount - balanceFromInterest);\n    }\n  }\n\n\n   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.nonces()` for more detailed documentation\n   */\n  function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256) {\n    return super.nonces(owner);\n  }\n\n\n  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {\n    IGhoToken(_underlyingAsset).mint(target, amount);\n  }\n",
        "formal_property": "invariant userBalanceAlwaysZero(address user)\n\tscaledBalanceOf(user) == 0\n\n// /**\n// * @title first handleRepayment(amount) after transferUnderlyingTo(amount) succeeds.\n// * @dev assumption of sufficient balanceOf(msg.sender) is justified because BorrowLogic.executeRepay()\n// * @dev executes: IERC20(params.asset).safeTransferFrom(msg.sender, reserveCache.aTokenAddress, paybackAmount);\n// * @dev before invocation of handleRepayment()\n// * OBSOLETE - GhoToken has other rules to validate the behavior of the facilitator level maintenance\n// */\n// rule handleRepayment_after_transferUnderlyingTo()\n// {\n// \tenv e;\n// \tcalldataarg arg;\n// \tuint256 amount;\n// \taddress target;\n// \taddress user;\n//     address onBehalfOf;\n// \ttransferUnderlyingTo(e, target, amount);\n// \trequire _ghoTokenHarness.balanceOf(e.msg.sender) >= amount; //underlying asset\n// \trequire e.msg.sender == currentContract;\n// \thandleRepayment@withrevert(e, user, onBehalfOf, amount);\n// \tassert !lastReverted, \"handleRepayment failed\";\n// }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "userBalanceAlwaysZero",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "transferUnderlyingTo",
                "handleRepayment",
                "_ghoTokenHarness.balanceOf",
                "scaledBalanceOf"
            ],
            "start_line": 97,
            "end_line": 126,
            "block_hash": "151889bb58a3b7cd37599e3f13e9d9fb"
        }
    },
    {
        "id": "GhoAToken_noMint_24a12bad",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoAToken.sol",
        "target_function": "mint",
        "text_chunk": "  function mint(\n    address caller,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external virtual override onlyPool returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n",
        "formal_property": "rule noMint() {\n\tenv e;\n\tcalldataarg args;\n\tmint(e, args);\n\tassert(false);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "noMint",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 45,
            "end_line": 50,
            "block_hash": "24a12badfb5761b515215eaeb059ec4c"
        }
    },
    {
        "id": "GhoAToken_noBurn_08a408e7",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoAToken.sol",
        "target_function": "burn",
        "text_chunk": "  function burn(\n    address from,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external virtual override onlyPool {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n",
        "formal_property": "rule noBurn() {\n\tenv e;\n\tcalldataarg args;\n\tburn(e, args);\n\tassert(false);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "noBurn",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 55,
            "end_line": 60,
            "block_hash": "08a408e7ab84233f43f4288e5ae04ce5"
        }
    },
    {
        "id": "GhoAToken_noTransfer_fa785b0e",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoAToken.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IERC20} from '@aave/core-v3/contracts/dependencies/openzeppelin/contracts/IERC20.sol';\nimport {GPv2SafeERC20} from '@aave/core-v3/contracts/dependencies/gnosis/contracts/GPv2SafeERC20.sol';\nimport {VersionedInitializable} from '@aave/core-v3/contracts/protocol/libraries/aave-upgradeability/VersionedInitializable.sol';\nimport {Errors} from '@aave/core-v3/contracts/protocol/libraries/helpers/Errors.sol';\nimport {WadRayMath} from '@aave/core-v3/contracts/protocol/libraries/math/WadRayMath.sol';\nimport {IPool} from '@aave/core-v3/contracts/interfaces/IPool.sol';\nimport {IAToken} from '@aave/core-v3/contracts/interfaces/IAToken.sol';\nimport {IAaveIncentivesController} from '@aave/core-v3/contracts/interfaces/IAaveIncentivesController.sol';\nimport {IInitializableAToken} from '@aave/core-v3/contracts/interfaces/IInitializableAToken.sol';\nimport {ScaledBalanceTokenBase} from '@aave/core-v3/contracts/protocol/tokenization/base/ScaledBalanceTokenBase.sol';\nimport {IncentivizedERC20} from '@aave/core-v3/contracts/protocol/tokenization/base/IncentivizedERC20.sol';\nimport {EIP712Base} from '@aave/core-v3/contracts/protocol/tokenization/base/EIP712Base.sol';\n\n// Gho Imports\nimport {IGhoToken} from '../../../gho/interfaces/IGhoToken.sol';\nimport {IGhoFacilitator} from '../../../gho/interfaces/IGhoFacilitator.sol';\nimport {IGhoAToken} from './interfaces/IGhoAToken.sol';\nimport {GhoVariableDebtToken} from './GhoVariableDebtToken.sol';\n\n/**\n * @title GhoAToken\n * @author Aave\n * @notice Implementation of the interest bearing token for the Aave protocol\n */\ncontract GhoAToken is VersionedInitializable, ScaledBalanceTokenBase, EIP712Base, IGhoAToken {\n  using WadRayMath for uint256;\n  using GPv2SafeERC20 for IERC20;\n\n  bytes32 public constant PERMIT_TYPEHASH =\n    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\n\n  uint256 public constant ATOKEN_REVISION = 0x1;\n\n  address internal _treasury;\n  address internal _underlyingAsset;\n\n  // Gho Storage\n  GhoVariableDebtToken internal _ghoVariableDebtToken;\n  address internal _ghoTreasury;\n\n  /// @inheritdoc VersionedInitializable\n  function getRevision() internal pure virtual override returns (uint256) {\n    return ATOKEN_REVISION;\n  }\n\n  /**\n   * @dev Constructor.\n   * @param pool The address of the Pool contract\n   */\n  constructor(\n    IPool pool\n  ) ScaledBalanceTokenBase(pool, 'GHO_ATOKEN_IMPL', 'GHO_ATOKEN_IMPL', 0) EIP712Base() {\n    // Intentionally left blank\n  }\n\n  /// @inheritdoc IInitializableAToken\n  function initialize(\n    IPool initializingPool,\n    address treasury,\n    address underlyingAsset,\n    IAaveIncentivesController incentivesController,\n    uint8 aTokenDecimals,\n    string calldata aTokenName,\n    string calldata aTokenSymbol,\n    bytes calldata params\n  ) external override initializer {\n    require(initializingPool == POOL, Errors.POOL_ADDRESSES_DO_NOT_MATCH);\n    _setName(aTokenName);\n    _setSymbol(aTokenSymbol);\n    _setDecimals(aTokenDecimals);\n\n    _treasury = treasury;\n    _underlyingAsset = underlyingAsset;\n    _incentivesController = incentivesController;\n\n    _domainSeparator = _calculateDomainSeparator();\n\n    emit Initialized(\n      underlyingAsset,\n      address(POOL),\n      treasury,\n      address(incentivesController),\n      aTokenDecimals,\n      aTokenName,\n      aTokenSymbol,\n      params\n    );\n  }\n\n  /// @inheritdoc IAToken\n  function mint(\n    address caller,\n    address onBehalfOf,\n    uint256 amount,\n    uint256 index\n  ) external virtual override onlyPool returns (bool) {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IAToken\n  function burn(\n    address from,\n    address receiverOfUnderlying,\n    uint256 amount,\n    uint256 index\n  ) external virtual override onlyPool {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IAToken\n  function mintToTreasury(uint256 amount, uint256 index) external virtual override onlyPool {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IAToken\n  function transferOnLiquidation(\n    address from,\n    address to,\n    uint256 value\n  ) external virtual override onlyPool {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /// @inheritdoc IERC20\n  function balanceOf(\n    address user\n  ) public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IERC20\n  function totalSupply() public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n    return 0;\n  }\n\n  /// @inheritdoc IAToken\n  function RESERVE_TREASURY_ADDRESS() external view override returns (address) {\n    return _treasury;\n  }\n\n  /// @inheritdoc IAToken\n  function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {\n    return _underlyingAsset;\n  }\n\n  /**\n   * @notice Transfers the underlying asset to `target`.\n   * @dev It performs a mint of GHO on behalf of the `target`\n   * @dev Used by the Pool to transfer assets in borrow(), withdraw() and flashLoan()\n   * @param target The recipient of the underlying\n   * @param amount The amount getting transferred\n   */\n  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {\n    IGhoToken(_underlyingAsset).mint(target, amount);\n  }\n\n  /// @inheritdoc IAToken\n  function handleRepayment(\n    address user,\n    address onBehalfOf,\n    uint256 amount\n  ) external virtual override onlyPool {\n    uint256 balanceFromInterest = _ghoVariableDebtToken.getBalanceFromInterest(onBehalfOf);\n    if (amount <= balanceFromInterest) {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, amount);\n    } else {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, balanceFromInterest);\n      IGhoToken(_underlyingAsset).burn(amount - balanceFromInterest);\n    }\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function distributeFeesToTreasury() external virtual override {\n    uint256 balance = IERC20(_underlyingAsset).balanceOf(address(this));\n    IERC20(_underlyingAsset).transfer(_ghoTreasury, balance);\n    emit FeesDistributedToTreasury(_ghoTreasury, _underlyingAsset, balance);\n  }\n\n  /// @inheritdoc IAToken\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external override {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /**\n   * @notice Overrides the parent _transfer to force validated transfer() and transferFrom()\n   * @param from The source address\n   * @param to The destination address\n   * @param amount The amount getting transferred\n   */\n  function _transfer(address from, address to, uint128 amount) internal override {\n    revert(Errors.OPERATION_NOT_SUPPORTED);\n  }\n\n  /**\n   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.DOMAIN_SEPARATOR()` for more detailed documentation\n   */\n  function DOMAIN_SEPARATOR() public view override(IAToken, EIP712Base) returns (bytes32) {\n    return super.DOMAIN_SEPARATOR();\n  }\n\n  /**\n   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.nonces()` for more detailed documentation\n   */\n  function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256) {\n    return super.nonces(owner);\n  }\n\n  /// @inheritdoc EIP712Base\n  function _EIP712BaseId() internal view override returns (string memory) {\n    return name();\n  }\n\n  /// @inheritdoc IAToken\n  function rescueTokens(address token, address to, uint256 amount) external override onlyPoolAdmin {\n    require(token != _underlyingAsset, Errors.UNDERLYING_CANNOT_BE_RESCUED);\n    IERC20(token).safeTransfer(to, amount);\n  }\n\n  /// @inheritdoc IGhoAToken\n  function setVariableDebtToken(address ghoVariableDebtToken) external override onlyPoolAdmin {\n    require(address(_ghoVariableDebtToken) == address(0), 'VARIABLE_DEBT_TOKEN_ALREADY_SET');\n    require(ghoVariableDebtToken != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    _ghoVariableDebtToken = GhoVariableDebtToken(ghoVariableDebtToken);\n    emit VariableDebtTokenSet(ghoVariableDebtToken);\n  }\n\n  /// @inheritdoc IGhoAToken\n  function getVariableDebtToken() external view override returns (address) {\n    return address(_ghoVariableDebtToken);\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function updateGhoTreasury(address newGhoTreasury) external override onlyPoolAdmin {\n    require(newGhoTreasury != address(0), 'ZERO_ADDRESS_NOT_VALID');\n    address oldGhoTreasury = _ghoTreasury;\n    _ghoTreasury = newGhoTreasury;\n    emit GhoTreasuryUpdated(oldGhoTreasury, newGhoTreasury);\n  }\n\n  /// @inheritdoc IGhoFacilitator\n  function getGhoTreasury() external view override returns (address) {\n    return _ghoTreasury;\n  }\n}\n",
        "formal_property": "rule noTransfer() {\n\tenv e;\n\tcalldataarg args;\n\ttransfer(e, args);\n\tassert(false);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "noTransfer",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 65,
            "end_line": 70,
            "block_hash": "fa785b0e30ce23c60d5ff87ce195cd90"
        }
    },
    {
        "id": "GhoAToken_transferUnderlyingToCantExceedCapacity_fc35b61b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoAToken.sol",
        "target_function": "to/transferUnderlyingTo",
        "text_chunk": "   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.nonces()` for more detailed documentation\n   */\n  function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256) {\n    return super.nonces(owner);\n  }\n\n\n  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {\n    IGhoToken(_underlyingAsset).mint(target, amount);\n  }\n",
        "formal_property": "rule transferUnderlyingToCantExceedCapacity() {\n\taddress target;\n\tuint256 amount;\n\tenv e;\n\tuint256 facilitatorLevel = _ghoTokenHarness.getFacilitatorBucketLevel(currentContract);\n\tuint256 facilitatorCapacity = _ghoTokenHarness.getFacilitatorBucketCapacity(currentContract);\n\ttransferUnderlyingTo@withrevert(e, target, amount);\n\tassert(amount > (facilitatorCapacity - facilitatorLevel) => lastReverted);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "transferUnderlyingToCantExceedCapacity",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "transferUnderlyingTo",
                "_ghoTokenHarness.getFacilitatorBucketCapacity",
                "_ghoTokenHarness.getFacilitatorBucketLevel"
            ],
            "start_line": 76,
            "end_line": 84,
            "block_hash": "fc35b61b7882e310d407d473a482b6ca"
        }
    },
    {
        "id": "GhoAToken_totalSupplyAlwaysZero_736c995a",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoAToken.sol",
        "target_function": "totalSupply",
        "text_chunk": "  function totalSupply() public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n    return 0;\n  }\n",
        "formal_property": "rule totalSupplyAlwaysZero() {\n\tassert(totalSupply() == 0);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "totalSupplyAlwaysZero",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "totalSupply"
            ],
            "start_line": 90,
            "end_line": 92,
            "block_hash": "736c995ad3c88b2dd01f1c929aa751ef"
        }
    },
    {
        "id": "GhoAToken_handleRepayment_after_transferUnderlyingTo_a7e57735",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoAToken.sol",
        "target_function": "balanceOf/handleRepayment/to/transferUnderlyingTo",
        "text_chunk": "  function balanceOf(\n    address user\n  ) public view virtual override(IncentivizedERC20, IERC20) returns (uint256) {\n    return 0;\n  }\n\n\n  function handleRepayment(\n    address user,\n    address onBehalfOf,\n    uint256 amount\n  ) external virtual override onlyPool {\n    uint256 balanceFromInterest = _ghoVariableDebtToken.getBalanceFromInterest(onBehalfOf);\n    if (amount <= balanceFromInterest) {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, amount);\n    } else {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, balanceFromInterest);\n      IGhoToken(_underlyingAsset).burn(amount - balanceFromInterest);\n    }\n  }\n\n\n   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.nonces()` for more detailed documentation\n   */\n  function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256) {\n    return super.nonces(owner);\n  }\n\n\n  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {\n    IGhoToken(_underlyingAsset).mint(target, amount);\n  }\n",
        "formal_property": "// rule handleRepayment_after_transferUnderlyingTo()\n// {\n// \tenv e;\n// \tcalldataarg arg;\n// \tuint256 amount;\n// \taddress target;\n// \taddress user;\n//     address onBehalfOf;\n\n// \ttransferUnderlyingTo(e, target, amount);\n// \trequire _ghoTokenHarness.balanceOf(e.msg.sender) >= amount; //underlying asset\n// \trequire e.msg.sender == currentContract;\n// \thandleRepayment@withrevert(e, user, onBehalfOf, amount);\n// \tassert !lastReverted, \"handleRepayment failed\";\n// }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "handleRepayment_after_transferUnderlyingTo",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "transferUnderlyingTo",
                "handleRepayment",
                "_ghoTokenHarness.balanceOf"
            ],
            "start_line": 109,
            "end_line": 126,
            "block_hash": "a7e5773556a4a749076c82be20b65613"
        }
    },
    {
        "id": "GhoAToken_level_does_not_decrease_after_transferUnderlyingTo_followed_by_handleRepayment_0fd157cc",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoAToken.sol",
        "target_function": "handleRepayment/to/transferUnderlyingTo",
        "text_chunk": "  function handleRepayment(\n    address user,\n    address onBehalfOf,\n    uint256 amount\n  ) external virtual override onlyPool {\n    uint256 balanceFromInterest = _ghoVariableDebtToken.getBalanceFromInterest(onBehalfOf);\n    if (amount <= balanceFromInterest) {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, amount);\n    } else {\n      _ghoVariableDebtToken.decreaseBalanceFromInterest(onBehalfOf, balanceFromInterest);\n      IGhoToken(_underlyingAsset).burn(amount - balanceFromInterest);\n    }\n  }\n\n\n   * @dev Overrides the base function to fully implement IAToken\n   * @dev see `EIP712Base.nonces()` for more detailed documentation\n   */\n  function nonces(address owner) public view override(IAToken, EIP712Base) returns (uint256) {\n    return super.nonces(owner);\n  }\n\n\n  function transferUnderlyingTo(address target, uint256 amount) external virtual override onlyPool {\n    IGhoToken(_underlyingAsset).mint(target, amount);\n  }\n",
        "formal_property": "rule level_does_not_decrease_after_transferUnderlyingTo_followed_by_handleRepayment()\n{\n\tenv e;\n\tcalldataarg arg;\n\tuint256 amount;\n\taddress target;\n\taddress user;\n    address onBehalfOf;\n\n\tuint256 levelBefore = _ghoTokenHarness.getFacilitatorBucketLevel(currentContract);\n\ttransferUnderlyingTo(e, target, amount);\n\thandleRepayment(e, user, onBehalfOf, amount);\n\tuint256 levelAfter = _ghoTokenHarness.getFacilitatorBucketLevel(currentContract);\n\tassert levelBefore <= levelAfter;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "level_does_not_decrease_after_transferUnderlyingTo_followed_by_handleRepayment",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "transferUnderlyingTo",
                "handleRepayment",
                "_ghoTokenHarness.getFacilitatorBucketLevel"
            ],
            "start_line": 133,
            "end_line": 148,
            "block_hash": "0fd157cc7970ac1c49888bb69cb53937"
        }
    }
]