[
    {
        "id": "LockedGold_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "LockedGold.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/utils/Address.sol\";\nimport \"openzeppelin-solidity/contracts/utils/EnumerableSet.sol\";\n\nimport \"./interfaces/ILockedGold.sol\";\n\nimport \"../common/FixidityLib.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/Signatures.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\ncontract LockedGold is\n  ILockedGold,\n  ICeloVersionedContract,\n  ReentrancyGuard,\n  Initializable,\n  UsingRegistry\n{\n  using SafeMath for uint256;\n  using Address for address payable; // prettier-ignore\n  using FixidityLib for FixidityLib.Fraction;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  struct PendingWithdrawal {\n    // The value of the pending withdrawal.\n    uint256 value;\n    // The timestamp at which the pending withdrawal becomes available.\n    uint256 timestamp;\n  }\n\n  // NOTE: This contract does not store an account's locked gold that is being used in electing\n  // validators.\n  struct Balances {\n    // The amount of locked gold that this account has that is not currently participating in\n    // validator elections.\n    uint256 nonvoting;\n    // Gold that has been unlocked and will become available for withdrawal.\n    PendingWithdrawal[] pendingWithdrawals;\n  }\n\n  struct DelegatedInfo {\n    FixidityLib.Fraction percentage;\n    uint256 currentAmount;\n  }\n\n  struct Delegated {\n    EnumerableSet.AddressSet delegatees;\n    // delegatees with how much percent delegatees are getting\n    // Celo at the time of delegation/latest update\n    mapping(address => DelegatedInfo) delegateesWithPercentagesAndAmount;\n    FixidityLib.Fraction totalDelegatedCeloFraction;\n  }\n\n  mapping(address => Balances) internal balances;\n\n  // Iterable map to store whitelisted identifiers.\n  // Necessary to allow iterating over whitelisted IDs to check ID's address at runtime.\n  mapping(bytes32 => bool) internal slashingMap;\n  bytes32[] public slashingWhitelist;\n\n  modifier onlySlasher {\n    require(\n      registry.isOneOf(slashingWhitelist, msg.sender),\n      \"Caller is not a whitelisted slasher.\"\n    );\n    _;\n  }\n\n  function isSlasher(address slasher) external view returns (bool) {\n    return (registry.isOneOf(slashingWhitelist, slasher));\n  }\n\n  uint256 public totalNonvoting;\n  uint256 public unlockingPeriod;\n\n  // Info about delegator\n  mapping(address => Delegated) delegatorInfo;\n  // Celo that was delegated to this particular address\n  mapping(address => uint256) public totalDelegatedCelo;\n\n  // maximum amount of allowed delegatees\n  uint256 maxDelegateesCount;\n\n  event UnlockingPeriodSet(uint256 period);\n  event GoldLocked(address indexed account, uint256 value);\n  event GoldUnlocked(address indexed account, uint256 value, uint256 available);\n  event GoldRelocked(address indexed account, uint256 value);\n  event GoldWithdrawn(address indexed account, uint256 value);\n  event SlasherWhitelistAdded(string indexed slasherIdentifier);\n  event SlasherWhitelistRemoved(string indexed slasherIdentifier);\n  event AccountSlashed(\n    address indexed slashed,\n    uint256 penalty,\n    address indexed reporter,\n    uint256 reward\n  );\n  event CeloDelegated(\n    address indexed delegator,\n    address indexed delegatee,\n    uint256 percent,\n    uint256 amount\n  );\n  event DelegatedCeloRevoked(\n    address indexed delegator,\n    address indexed delegatee,\n    uint256 percent,\n    uint256 amount\n  );\n  event MaxDelegateesCountSet(uint256 value);\n\n  /**\n  * @notice Returns the storage, major, minor, and patch version of the contract.\n  * @return Storage version of the contract.\n  * @return Major version of the contract.\n  * @return Minor version of the contract.\n  * @return Patch version of the contract.\n  */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 1, 4, 0);\n  }\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry core smart contract.\n   * @param _unlockingPeriod The unlocking period in seconds.\n   */\n  function initialize(address registryAddress, uint256 _unlockingPeriod) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setUnlockingPeriod(_unlockingPeriod);\n    maxDelegateesCount = 10;\n  }\n\n  /**\n   * @notice Sets the duration in seconds users must wait before withdrawing gold after unlocking.\n   * @param value The unlocking period in seconds.\n   */\n  function setUnlockingPeriod(uint256 value) public onlyOwner {\n    require(value != unlockingPeriod, \"Unlocking period not changed\");\n    unlockingPeriod = value;\n    emit UnlockingPeriodSet(value);\n  }\n\n  /**\n   * @notice Sets max delegatees count.\n   * @param value The max delegatees count.\n   */\n  function setMaxDelegateesCount(uint256 value) public onlyOwner {\n    maxDelegateesCount = value;\n    emit MaxDelegateesCountSet(value);\n  }\n\n  /**\n   * @notice Locks gold to be used for voting.\n   */\n  function lock() external payable nonReentrant {\n    require(\n      getAccounts().isAccount(msg.sender),\n      \"Must first register address with Account.createAccount\"\n    );\n    _incrementNonvotingAccountBalance(msg.sender, msg.value);\n    _updateDelegatedAmount(msg.sender);\n    emit GoldLocked(msg.sender, msg.value);\n  }\n\n  /**\n   * @notice Increments the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be incremented.\n   * @param value The amount by which to increment.\n   * @dev Can only be called by the registered Election smart contract.\n   */\n  function incrementNonvotingAccountBalance(address account, uint256 value)\n    external\n    onlyRegisteredContract(ELECTION_REGISTRY_ID)\n  {\n    _incrementNonvotingAccountBalance(account, value);\n  }\n\n  /**\n   * @notice Decrements the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be decremented.\n   * @param value The amount by which to decrement.\n   * @dev Can only be called by the registered \"Election\" smart contract.\n   */\n  function decrementNonvotingAccountBalance(address account, uint256 value)\n    external\n    onlyRegisteredContract(ELECTION_REGISTRY_ID)\n  {\n    _decrementNonvotingAccountBalance(account, value);\n  }\n\n  /**\n   * @notice Increments the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be incremented.\n   * @param value The amount by which to increment.\n   */\n  function _incrementNonvotingAccountBalance(address account, uint256 value) private {\n    balances[account].nonvoting = balances[account].nonvoting.add(value);\n    totalNonvoting = totalNonvoting.add(value);\n  }\n\n  /**\n   * @notice Decrements the non-voting balance for an account.\n   * @param account The account whose non-voting balance should be decremented.\n   * @param value The amount by which to decrement.\n   */\n  function _decrementNonvotingAccountBalance(address account, uint256 value) private {\n    balances[account].nonvoting = balances[account].nonvoting.sub(value);\n    totalNonvoting = totalNonvoting.sub(value);\n  }\n\n  /**\n   * @notice Unlocks gold that becomes withdrawable after the unlocking period.\n   * @param value The amount of gold to unlock.\n   */\n  function unlock(uint256 value) external nonReentrant {\n    require(\n      getAccounts().isAccount(msg.sender),\n      \"Sender must be registered with Account.createAccount to lock or unlock\"\n    );\n    Balances storage account = balances[msg.sender];\n\n    uint256 totalLockedGold = getAccountTotalLockedGold(msg.sender);\n    // Prevent unlocking gold when voting on governance proposals so that the gold cannot be\n    // used to vote more than once.\n    uint256 remainingLockedGold = totalLockedGold.sub(value);\n\n    uint256 totalReferendumVotes = getGovernance().getAmountOfGoldUsedForVoting(msg.sender);\n    require(\n      remainingLockedGold >= totalReferendumVotes,\n      \"Not enough unlockable celo. Celo is locked in voting.\"\n    );\n\n    FixidityLib.Fraction memory delegatedPercentage = delegatorInfo[msg.sender]\n      .totalDelegatedCeloFraction;\n\n    if (FixidityLib.gt(delegatedPercentage, FixidityLib.newFixed(0))) {\n      revokeFromDelegatedWhenUnlocking(msg.sender, value);\n    }\n\n    uint256 balanceRequirement = getValidators().getAccountLockedGoldRequirement(msg.sender);\n    require(\n      balanceRequirement == 0 || balanceRequirement <= remainingLockedGold,\n      \"Either account doesn't have enough locked Celo or locked Celo is being used for voting.\"\n    );\n    _decrementNonvotingAccountBalance(msg.sender, value);\n    uint256 available = now.add(unlockingPeriod);\n    // CERTORA: the slot containing the length could be MAX_UINT\n    account.pendingWithdrawals.push(PendingWithdrawal(value, available));\n    emit GoldUnlocked(msg.sender, value, available);\n  }\n\n  /**\n   * @notice Relocks gold that has been unlocked but not withdrawn.\n   * @param index The index of the pending withdrawal to relock from.\n   * @param value The value to relock from the specified pending withdrawal.\n   */\n  function relock(uint256 index, uint256 value) external nonReentrant {\n    require(\n      getAccounts().isAccount(msg.sender),\n      \"Sender must be registered with Account.createAccount to lock or relock\"\n    );\n    Balances storage account = balances[msg.sender];\n    require(index < account.pendingWithdrawals.length, \"Bad pending withdrawal index\");\n    PendingWithdrawal storage pendingWithdrawal = account.pendingWithdrawals[index];\n    require(value <= pendingWithdrawal.value, \"Requested value larger than pending value\");\n    if (value == pendingWithdrawal.value) {\n      deletePendingWithdrawal(account.pendingWithdrawals, index);\n    } else {\n      pendingWithdrawal.value = pendingWithdrawal.value.sub(value);\n    }\n    _incrementNonvotingAccountBalance(msg.sender, value);\n    _updateDelegatedAmount(msg.sender);\n    emit GoldRelocked(msg.sender, value);\n  }\n\n  /**\n   * @notice Withdraws gold that has been unlocked after the unlocking period has passed.\n   * @param index The index of the pending withdrawal to withdraw.\n   */\n  function withdraw(uint256 index) external nonReentrant {\n    require(\n      getAccounts().isAccount(msg.sender),\n      \"Sender must be registered with Account.createAccount to withdraw\"\n    );\n    Balances storage account = balances[msg.sender];\n    require(index < account.pendingWithdrawals.length, \"Bad pending withdrawal index\");\n    PendingWithdrawal storage pendingWithdrawal = account.pendingWithdrawals[index];\n    require(now >= pendingWithdrawal.timestamp, \"Pending withdrawal not available\");\n    uint256 value = pendingWithdrawal.value;\n    deletePendingWithdrawal(account.pendingWithdrawals, index);\n    require(value <= address(this).balance, \"Inconsistent balance\");\n    msg.sender.sendValue(value);\n    emit GoldWithdrawn(msg.sender, value);\n  }\n\n  /**\n   * @notice Returns the total amount of locked gold in the system. Note that this does not include\n   *   gold that has been unlocked but not yet withdrawn.\n   * @return The total amount of locked gold in the system.\n   */\n  function getTotalLockedGold() external view returns (uint256) {\n    return totalNonvoting.add(getElection().getTotalVotes());\n  }\n\n  /**\n   * @notice Returns the total amount of locked gold not being used to vote in elections.\n   * @return The total amount of locked gold not being used to vote in elections.\n   */\n  function getNonvotingLockedGold() external view returns (uint256) {\n    return totalNonvoting;\n  }\n\n  /**\n   * Delegates CELO to delegatee.\n   * @param delegatee The delegatee account.\n   * @param delegateFraction Fraction of total CELO that will be delegated from delegatee. Fixidity fraction\n   */\n  function delegateGovernanceVotes(address delegatee, uint256 delegateFraction) external {\n    FixidityLib.Fraction memory percentageToDelegate = FixidityLib.wrap(delegateFraction);\n    require(\n      FixidityLib.lte(percentageToDelegate, FixidityLib.fixed1()),\n      \"Delegate fraction must be less than or equal to 1\"\n    );\n    address delegatorAccount = getAccounts().voteSignerToAccount(msg.sender);\n    address delegateeAccount = getAccounts().voteSignerToAccount(delegatee);\n\n    IValidators validators = getValidators();\n    require(!validators.isValidator(delegatorAccount), \"Validators cannot delegate votes.\");\n    require(\n      !validators.isValidatorGroup(delegatorAccount),\n      \"Validator groups cannot delegate votes.\"\n    );\n\n    Delegated storage delegated = delegatorInfo[delegatorAccount];\n    delegated.delegatees.add(delegateeAccount);\n    require(delegated.delegatees.length() <= maxDelegateesCount, \"Too many delegatees\");\n\n    DelegatedInfo storage currentDelegateeInfo = delegated\n      .delegateesWithPercentagesAndAmount[delegateeAccount];\n\n    require(\n      FixidityLib.gte(percentageToDelegate, currentDelegateeInfo.percentage),\n      \"Cannot decrease delegated amount - use revokeDelegatedGovernanceVotes.\"\n    );\n\n    FixidityLib.Fraction memory requestedToDelegate = delegated\n      .totalDelegatedCeloFraction\n      .subtract(currentDelegateeInfo.percentage)\n      .add(percentageToDelegate);\n\n    require(\n      FixidityLib.lte(requestedToDelegate, FixidityLib.fixed1()),\n      \"Cannot delegate more than 100%\"\n    );\n\n    uint256 totalLockedGold = getAccountTotalLockedGold(delegatorAccount);\n    if (totalLockedGold == 0) {\n      delegated.totalDelegatedCeloFraction = delegated\n        .totalDelegatedCeloFraction\n        .subtract(currentDelegateeInfo.percentage)\n        .add(percentageToDelegate);\n      currentDelegateeInfo.percentage = percentageToDelegate;\n\n      emit CeloDelegated(\n        delegatorAccount,\n        delegateeAccount,\n        FixidityLib.unwrap(percentageToDelegate),\n        currentDelegateeInfo.currentAmount\n      );\n      return;\n    }\n\n    uint256 totalReferendumVotes = getGovernance().getAmountOfGoldUsedForVoting(delegatorAccount);\n\n    if (totalReferendumVotes != 0) {\n      FixidityLib.Fraction memory referendumVotesInPercents = FixidityLib.newFixedFraction(\n        totalReferendumVotes,\n        totalLockedGold\n      );\n      require(\n        FixidityLib.lte(referendumVotesInPercents.add(requestedToDelegate), FixidityLib.fixed1()),\n        \"Cannot delegate votes that are voting in referendum\"\n      );\n    }\n\n    // amount that will really be delegated - whatever is already\n    // delegated to this particular delagatee is already subracted from this\n    uint256 amountToDelegate = FixidityLib\n      .newFixed(totalLockedGold)\n      .multiply(percentageToDelegate)\n      .subtract(FixidityLib.newFixed(currentDelegateeInfo.currentAmount))\n      .fromFixed();\n\n    delegated.totalDelegatedCeloFraction = delegated\n      .totalDelegatedCeloFraction\n      .subtract(currentDelegateeInfo.percentage)\n      .add(percentageToDelegate);\n    currentDelegateeInfo.percentage = percentageToDelegate;\n\n    currentDelegateeInfo.currentAmount = currentDelegateeInfo.currentAmount.add(amountToDelegate);\n    totalDelegatedCelo[delegateeAccount] = totalDelegatedCelo[delegateeAccount].add(\n      amountToDelegate\n    );\n\n    emit CeloDelegated(\n      delegatorAccount,\n      delegateeAccount,\n      FixidityLib.unwrap(percentageToDelegate),\n      currentDelegateeInfo.currentAmount\n    );\n  }\n\n  /**\n   * Revokes delegated CELO.\n   * @param delegatee The delegatee acount.\n   * @param revokeFraction Fraction of total CELO that will be revoked from delegatee. Fixidity fraction\n   */\n  function revokeDelegatedGovernanceVotes(address delegatee, uint256 revokeFraction) external {\n    FixidityLib.Fraction memory percentageToRevoke = FixidityLib.wrap(revokeFraction);\n\n    require(\n      FixidityLib.lte(percentageToRevoke, FixidityLib.fixed1()),\n      \"Revoke fraction must be less than or equal to 1\"\n    );\n\n    address delegatorAccount = getAccounts().voteSignerToAccount(msg.sender);\n    Delegated storage delegated = delegatorInfo[delegatorAccount];\n    require(\n      FixidityLib.gte(delegated.totalDelegatedCeloFraction, percentageToRevoke),\n      \"Not enough total delegated percents\"\n    );\n\n    address delegateeAccount = getAccounts().voteSignerToAccount(delegatee);\n    _updateDelegatedAmount(delegatorAccount, delegateeAccount);\n\n    DelegatedInfo storage currentDelegateeInfo = delegated\n      .delegateesWithPercentagesAndAmount[delegateeAccount];\n\n    require(\n      FixidityLib.gte(currentDelegateeInfo.percentage, percentageToRevoke),\n      \"Not enough delegated percents\"\n    );\n\n    currentDelegateeInfo.percentage = currentDelegateeInfo.percentage.subtract(percentageToRevoke);\n\n    uint256 totalLockedGold = getAccountTotalLockedGold(delegatorAccount);\n\n    uint256 amountToRevoke = FixidityLib.unwrap(currentDelegateeInfo.percentage) == 0\n      ? currentDelegateeInfo.currentAmount\n      : Math.min(\n        FixidityLib.newFixed(totalLockedGold).multiply(percentageToRevoke).fromFixed(),\n        currentDelegateeInfo.currentAmount\n      );\n\n    _decreaseDelegateeVotingPower(delegateeAccount, amountToRevoke, currentDelegateeInfo);\n\n    delegated.totalDelegatedCeloFraction = delegated.totalDelegatedCeloFraction.subtract(\n      percentageToRevoke\n    );\n\n    if (FixidityLib.unwrap(currentDelegateeInfo.percentage) == 0) {\n      delegated.delegatees.remove(delegateeAccount);\n    }\n\n    emit DelegatedCeloRevoked(\n      delegatorAccount,\n      delegateeAccount,\n      FixidityLib.unwrap(percentageToRevoke),\n      amountToRevoke\n    );\n  }\n\n  /**\n   * Revokes amount during unlocking. It will revoke votes from voted proposals if necessary.\n   * @param delegator The delegator account.\n   * @param amountToRevoke The amount to revoke.\n   */\n  function revokeFromDelegatedWhenUnlocking(address delegator, uint256 amountToRevoke) private {\n    address[] memory delegatees = getDelegateesOfDelegator(delegator);\n\n    Delegated storage delegated = delegatorInfo[delegator];\n\n    for (uint256 i = 0; i < delegatees.length; i = i.add(1)) {\n      DelegatedInfo storage currentDelegateeInfo = delegated\n        .delegateesWithPercentagesAndAmount[delegatees[i]];\n      (uint256 expected, uint256 real) = _getDelegatorDelegateeExpectedAndRealAmount(\n        delegator,\n        delegatees[i]\n      );\n      uint256 delegateeAmountToRevoke = FixidityLib\n        .newFixed(amountToRevoke)\n        .multiply(currentDelegateeInfo.percentage)\n        .fromFixed();\n      delegateeAmountToRevoke = delegateeAmountToRevoke.sub(expected.sub(real));\n      _decreaseDelegateeVotingPower(delegatees[i], delegateeAmountToRevoke, currentDelegateeInfo);\n      emit DelegatedCeloRevoked(delegator, delegatees[i], 0, delegateeAmountToRevoke);\n    }\n  }\n\n  /**\n   * Decreases delegatee voting power when removing or unlocking delegated votes.\n   * @param delegatee The delegatee.\n   * @param amountToRevoke Amount to revoke.\n   * @param delegateeInfo Delegatee info.\n   */\n  function _decreaseDelegateeVotingPower(\n    address delegatee,\n    uint256 amountToRevoke,\n    DelegatedInfo storage delegateeInfo\n  ) private {\n    uint256 delegateeTotalVotingPower = getAccountTotalGovernanceVotingPower(delegatee);\n    uint256 totalReferendumVotes = getGovernance().getAmountOfGoldUsedForVoting(delegatee);\n    uint256 unusedReferendumVotes = delegateeTotalVotingPower.sub(totalReferendumVotes);\n    if (unusedReferendumVotes < amountToRevoke) {\n      getGovernance().removeVotesWhenRevokingDelegatedVotes(\n        delegatee,\n        delegateeTotalVotingPower.sub(amountToRevoke)\n      );\n    }\n    delegateeInfo.currentAmount = delegateeInfo.currentAmount.sub(amountToRevoke);\n    totalDelegatedCelo[delegatee] = totalDelegatedCelo[delegatee].sub(amountToRevoke);\n  }\n\n  /**\n   * Updates real delegated amount to all delegator's delegatees.\n   * There might be discrepancy because of validator rewards or extra locked gold.\n   * @param delegator The delegator address.\n   */\n  function updateDelegatedAmount(address delegator) public {\n    address delegatorAccount = getAccounts().voteSignerToAccount(delegator);\n    _updateDelegatedAmount(delegatorAccount);\n  }\n\n  function _updateDelegatedAmount(address delegator) private {\n    address delegatorAccount = getAccounts().voteSignerToAccount(delegator);\n    EnumerableSet.AddressSet storage delegatees = delegatorInfo[delegatorAccount].delegatees;\n    for (uint256 i = 0; i < delegatees.length(); i = i.add(1)) {\n      _updateDelegatedAmount(delegatorAccount, delegatees.get(i));\n    }\n  }\n\n  /**\n   * Updates real delegated amount to delegatee.\n   * There might be discrepancy because of validator rewards or extra locked gold.\n   * Voting power will always be smaller or equal to what it is supposed to be.\n   * @param delegator The delegator address.\n   * @param delegatee The delegatee address.\n   */\n  function updateDelegatedAmount(address delegator, address delegatee) public returns (uint256) {\n    address delegatorAccount = getAccounts().voteSignerToAccount(delegator);\n    address delegateeAccount = getAccounts().voteSignerToAccount(delegatee);\n\n    return _updateDelegatedAmount(delegatorAccount, delegateeAccount);\n  }\n\n  /**\n   * Updates real delegated amount to delegatee.\n   * There might be discrepancy because of validator rewards or extra locked gold.\n   * Voting power will always be smaller or equal to what it is supposed to be.\n   * @param delegator The delegator address.\n   * @param delegatee The delegatee address.\n   */\n  function _updateDelegatedAmount(address delegator, address delegatee) internal returns (uint256) {\n    Delegated storage delegated = delegatorInfo[delegator];\n    require(\n      FixidityLib.unwrap(delegated.totalDelegatedCeloFraction) != 0,\n      \"delegator is not delegating\"\n    );\n    DelegatedInfo storage currentDelegateeInfo = delegated\n      .delegateesWithPercentagesAndAmount[delegatee];\n    require(\n      FixidityLib.unwrap(currentDelegateeInfo.percentage) != 0,\n      \"delegator is not delegating for delegatee\"\n    );\n\n    (uint256 expected, uint256 real) = getDelegatorDelegateeExpectedAndRealAmount(\n      delegator,\n      delegatee\n    );\n\n    currentDelegateeInfo.currentAmount = expected;\n    totalDelegatedCelo[delegatee] = totalDelegatedCelo[delegatee].sub(real).add(expected);\n\n    return expected;\n  }\n\n  /**\n   * Returns how many percents of CELO is account delegating.\n   * @param account The account address.\n   */\n  function getAccountTotalDelegatedFraction(address account) public view returns (uint256) {\n    Delegated storage delegated = delegatorInfo[account];\n    return FixidityLib.unwrap(delegated.totalDelegatedCeloFraction);\n  }\n\n  /**\n   * @notice Returns the total amount of locked gold for an account.\n   * @param account The account.\n   * @return The total amount of locked gold for an account.\n   */\n  function getAccountTotalLockedGold(address account) public view returns (uint256) {\n    uint256 total = balances[account].nonvoting;\n    return total.add(getElection().getTotalVotesByAccount(account));\n  }\n\n  /**\n   * @notice Returns the total amount of locked gold + delegated gold for an account.\n   * @param account The account.\n   * @return The total amount of locked gold + delegated gold for an account.\n   */\n  function getAccountTotalGovernanceVotingPower(address account) public view returns (uint256) {\n    FixidityLib.Fraction memory availableUndelegatedPercents = FixidityLib.fixed1().subtract(\n      FixidityLib.wrap(getAccountTotalDelegatedFraction(account))\n    );\n    uint256 totalLockedGold = getAccountTotalLockedGold(account);\n\n    uint256 availableForVoting = FixidityLib\n      .newFixed(totalLockedGold)\n      .multiply(availableUndelegatedPercents)\n      .fromFixed();\n\n    return availableForVoting.add(totalDelegatedCelo[account]);\n  }\n\n  /**\n * Return percentage and amount that delegator assigned to delegateee.\n * Please note that amount doesn't have to be up to date. \n * In such case please use `updateDelegatedBalance`.\n * @param delegator The delegator address.\n * @param delegatee The delegatee address.\n * @return fraction The fraction that is delegator asigning to delegatee.\n * @return currentAmount The current actual Celo amount that is assigned to delegatee.\n */\n  function getDelegatorDelegateeInfo(address delegator, address delegatee)\n    external\n    view\n    returns (uint256 fraction, uint256 currentAmount)\n  {\n    DelegatedInfo storage currentDelegateeInfo = delegatorInfo[delegator]\n      .delegateesWithPercentagesAndAmount[delegatee];\n\n    fraction = FixidityLib.unwrap(currentDelegateeInfo.percentage);\n    currentAmount = currentDelegateeInfo.currentAmount;\n  }\n\n  /**\n   * Returns expected vs real delegated amount. \n   * If there is a discrepancy it can be fixed by calling `updateDelegatedAmount` function.\n   * @param delegator The delegator address.\n   * @param delegatee The delegatee address.\n   * @return expected The expected amount.\n   * @return real The real amount. \n   */\n  function getDelegatorDelegateeExpectedAndRealAmount(address delegator, address delegatee)\n    public\n    view\n    returns (uint256 expected, uint256 real)\n  {\n    address delegatorAccount = getAccounts().voteSignerToAccount(delegator);\n    address delegateeAccount = getAccounts().voteSignerToAccount(delegatee);\n\n    (expected, real) = _getDelegatorDelegateeExpectedAndRealAmount(\n      delegatorAccount,\n      delegateeAccount\n    );\n  }\n\n  /**\n   * Returns expected vs real delegated amount. \n   * If there is a discrepancy it can be fixed by calling `updateDelegatedAmount` function.\n   * @param delegator The delegator address.\n   * @param delegatee The delegatee address.\n   * @return expected The expected amount.\n   * @return real The real amount. \n   */\n  function _getDelegatorDelegateeExpectedAndRealAmount(address delegator, address delegatee)\n    private\n    view\n    returns (uint256 expected, uint256 real)\n  {\n    DelegatedInfo storage currentDelegateeInfo = delegatorInfo[delegator]\n      .delegateesWithPercentagesAndAmount[delegatee];\n\n    uint256 amountToDelegate = FixidityLib\n      .newFixed(getAccountTotalLockedGold(delegator))\n      .multiply(currentDelegateeInfo.percentage)\n      .fromFixed();\n\n    expected = amountToDelegate;\n    real = currentDelegateeInfo.currentAmount;\n  }\n\n  /**\n   * Retuns all delegatees of delegator\n   * @param delegator The delegator address.\n   */\n  function getDelegateesOfDelegator(address delegator) public view returns (address[] memory) {\n    address[] memory values = delegatorInfo[delegator].delegatees.enumerate();\n    return values;\n  }\n\n  /**\n   * @notice Returns the total amount of non-voting locked gold for an account.\n   * @param account The account.\n   * @return The total amount of non-voting locked gold for an account.\n   */\n  function getAccountNonvotingLockedGold(address account) external view returns (uint256) {\n    return balances[account].nonvoting;\n  }\n\n  /**\n   * @notice Returns the pending withdrawals from unlocked gold for an account.\n   * @param account The address of the account.\n   * @return The value for each pending withdrawal.\n   * @return The timestamp for each pending withdrawal.\n   */\n  function getPendingWithdrawals(address account)\n    external\n    view\n    returns (uint256[] memory, uint256[] memory)\n  {\n    require(\n      getAccounts().isAccount(account),\n      \"Unknown account: only registered accounts have pending withdrawals\"\n    );\n    uint256 length = balances[account].pendingWithdrawals.length;\n    uint256[] memory values = new uint256[](length);\n    uint256[] memory timestamps = new uint256[](length);\n    for (uint256 i = 0; i < length; i = i.add(1)) {\n      PendingWithdrawal memory pendingWithdrawal = (balances[account].pendingWithdrawals[i]);\n      values[i] = pendingWithdrawal.value;\n      timestamps[i] = pendingWithdrawal.timestamp;\n    }\n    return (values, timestamps);\n  }\n\n  /**\n   * @notice Returns the pending withdrawal at a given index for a given account.\n   * @param account The address of the account.\n   * @param index The index of the pending withdrawal.\n   * @return The value of the pending withdrawal.\n   * @return The timestamp of the pending withdrawal.\n   */\n  function getPendingWithdrawal(address account, uint256 index)\n    external\n    view\n    returns (uint256, uint256)\n  {\n    require(\n      getAccounts().isAccount(account),\n      \"Unknown account: only registered accounts have pending withdrawals\"\n    );\n    require(index < balances[account].pendingWithdrawals.length, \"Bad pending withdrawal index\");\n    PendingWithdrawal memory pendingWithdrawal = (balances[account].pendingWithdrawals[index]);\n\n    return (pendingWithdrawal.value, pendingWithdrawal.timestamp);\n  }\n\n  /**\n    * @notice Returns the number of pending withdrawals for the specified account.\n    * @param account The address of the account.\n    * @return The count of pending withdrawals.\n    */\n  function getTotalPendingWithdrawalsCount(address account) external view returns (uint256) {\n    return balances[account].pendingWithdrawals.length;\n  }\n\n  /**\n   * @notice Returns the total amount to withdraw from unlocked gold for an account.\n   * @param account The address of the account.\n   * @return Total amount to withdraw.\n   */\n  function getTotalPendingWithdrawals(address account) external view returns (uint256) {\n    uint256 pendingWithdrawalSum = 0;\n    PendingWithdrawal[] memory withdrawals = balances[account].pendingWithdrawals;\n    for (uint256 i = 0; i < withdrawals.length; i = i.add(1)) {\n      pendingWithdrawalSum = pendingWithdrawalSum.add(withdrawals[i].value);\n    }\n    return pendingWithdrawalSum;\n  }\n\n  function getSlashingWhitelist() external view returns (bytes32[] memory) {\n    return slashingWhitelist;\n  }\n\n  /**\n   * @notice Deletes a pending withdrawal.\n   * @param list The list of pending withdrawals from which to delete.\n   * @param index The index of the pending withdrawal to delete.\n   */\n  function deletePendingWithdrawal(PendingWithdrawal[] storage list, uint256 index) private {\n    uint256 lastIndex = list.length.sub(1);\n    list[index] = list[lastIndex];\n    list.length = lastIndex;\n  }\n\n  /**\n   * @notice Adds `slasher` to whitelist of approved slashing addresses.\n   * @param slasherIdentifier Identifier to whitelist.\n   */\n  function addSlasher(string calldata slasherIdentifier) external onlyOwner {\n    bytes32 keyBytes = keccak256(abi.encodePacked(slasherIdentifier));\n    require(registry.getAddressFor(keyBytes) != address(0), \"Identifier is not registered\");\n    require(!slashingMap[keyBytes], \"Cannot add slasher ID twice.\");\n    slashingWhitelist.push(keyBytes);\n    slashingMap[keyBytes] = true;\n    emit SlasherWhitelistAdded(slasherIdentifier);\n  }\n\n  /**\n   * @notice Removes `slasher` from whitelist of approved slashing addresses.\n   * @param slasherIdentifier Identifier to remove from whitelist.\n   * @param index Index of the provided identifier in slashingWhiteList array.\n   */\n  function removeSlasher(string calldata slasherIdentifier, uint256 index) external onlyOwner {\n    bytes32 keyBytes = keccak256(abi.encodePacked(slasherIdentifier));\n    require(slashingMap[keyBytes], \"Cannot remove slasher ID not yet added.\");\n    require(index < slashingWhitelist.length, \"Provided index exceeds whitelist bounds.\");\n    require(slashingWhitelist[index] == keyBytes, \"Index doesn't match identifier\");\n    slashingWhitelist[index] = slashingWhitelist[slashingWhitelist.length - 1];\n    slashingWhitelist.pop();\n    slashingMap[keyBytes] = false;\n    emit SlasherWhitelistRemoved(slasherIdentifier);\n  }\n\n  /**\n   * @notice Slashes `account` by reducing its nonvoting locked gold by `penalty`.\n   *         If there is not enough nonvoting locked gold to slash, calls into\n   *         `Election.slashVotes` to slash the remaining gold. If `account` does not have\n   *         `penalty` worth of locked gold, slashes `account`'s total locked gold.\n   *         Also sends `reward` gold to the reporter, and penalty-reward to the Community Fund.\n   * @param account Address of account being slashed.\n   * @param penalty Amount to slash account.\n   * @param reporter Address of account reporting the slasher.\n   * @param reward Reward to give reporter.\n   * @param lessers The groups receiving fewer votes than i'th group, or 0 if the i'th group has\n   *                the fewest votes of any validator group.\n   * @param greaters The groups receiving more votes than the i'th group, or 0 if the i'th group\n   *                 has the most votes of any validator group.\n   * @param indices The indices of the i'th group in `account`'s voting list.\n   * @dev Fails if `reward` is greater than `account`'s total locked gold.\n   */\n  function slash(\n    address account,\n    uint256 penalty,\n    address reporter,\n    uint256 reward,\n    address[] calldata lessers,\n    address[] calldata greaters,\n    uint256[] calldata indices\n  ) external onlySlasher {\n    uint256 maxSlash = Math.min(penalty, getAccountTotalLockedGold(account));\n    require(maxSlash >= reward, \"reward cannot exceed penalty.\");\n    // `reporter` receives the reward in locked CELO, so it must be given to an account\n    // There is no reward for slashing via the GovernanceSlasher, and `reporter`\n    // is set to 0x0.\n    if (reporter != address(0)) {\n      reporter = getAccounts().signerToAccount(reporter);\n    }\n    // Local scoping is required to avoid Solc \"stack too deep\" error from too many locals.\n    {\n      uint256 nonvotingBalance = balances[account].nonvoting;\n      uint256 difference = 0;\n      // If not enough nonvoting, revoke the difference\n      if (nonvotingBalance < maxSlash) {\n        difference = maxSlash.sub(nonvotingBalance);\n        require(\n          getElection().forceDecrementVotes(account, difference, lessers, greaters, indices) ==\n            difference,\n          \"Cannot revoke enough voting gold.\"\n        );\n      }\n      // forceDecrementVotes does not increment nonvoting account balance, so we can't double count\n      _decrementNonvotingAccountBalance(account, maxSlash.sub(difference));\n      _incrementNonvotingAccountBalance(reporter, reward);\n    }\n    address communityFund = registry.getAddressForOrDie(GOVERNANCE_REGISTRY_ID);\n    address payable communityFundPayable = address(uint160(communityFund));\n    require(maxSlash.sub(reward) <= address(this).balance, \"Inconsistent balance\");\n    communityFundPayable.sendValue(maxSlash.sub(reward));\n    emit AccountSlashed(account, maxSlash, reporter, reward);\n  }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "isSlasher",
                "getVersionNumber",
                "initialize",
                "setUnlockingPeriod",
                "setMaxDelegateesCount",
                "lock",
                "incrementNonvotingAccountBalance",
                "decrementNonvotingAccountBalance",
                "_incrementNonvotingAccountBalance",
                "_decrementNonvotingAccountBalance",
                "unlock",
                "relock",
                "withdraw",
                "getTotalLockedGold",
                "getNonvotingLockedGold",
                "delegateGovernanceVotes",
                "revokeDelegatedGovernanceVotes",
                "revokeFromDelegatedWhenUnlocking",
                "_decreaseDelegateeVotingPower",
                "updateDelegatedAmount",
                "_updateDelegatedAmount",
                "getAccountTotalDelegatedFraction",
                "getAccountTotalLockedGold",
                "getAccountTotalGovernanceVotingPower",
                "getDelegatorDelegateeInfo",
                "getDelegatorDelegateeExpectedAndRealAmount",
                "_getDelegatorDelegateeExpectedAndRealAmount",
                "getDelegateesOfDelegator",
                "getAccountNonvotingLockedGold",
                "getPendingWithdrawals",
                "getPendingWithdrawal",
                "getTotalPendingWithdrawalsCount",
                "getTotalPendingWithdrawals",
                "getSlashingWhitelist",
                "deletePendingWithdrawal",
                "addSlasher",
                "removeSlasher",
                "slash"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "LockedGold_check_initializer",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "LockedGold.sol",
        "target_function": "initialize",
        "text_chunk": "function initialize(address registryAddress, uint256 _unlockingPeriod) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setUnlockingPeriod(_unlockingPeriod);\n    maxDelegateesCount = 10;\n  }",
        "formal_property": "rule check_initializer {\n\tenv _e;\n\tenv eF;\n\tenv e_;\n\t\n\tbool _isInitialized = sinvoke initialized(_e);\n\tcalldataarg arg;\n\tinvoke initialize(eF,arg);\n\tbool successInit = !lastReverted;\n\tbool isInitialized_ = sinvoke initialized(e_);\n\tassert(\n    _isInitialized => !successInit,\n    \"Initialize() must revert if already initialized\"\n  );\n\tassert(\n    successInit => isInitialized_,\n    \"When initialize() succeeds, must set initialization field to true\"\n  );\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "check_initializer",
            "rule_type": "RULE"
        }
    }
]