[
    {
        "id": "ERC20Votes_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC20Votes.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"./draft-ERC20Permit.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../governance/utils/IVotes.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\nabstract contract ERC20Votes is IVotes, ERC20Permit {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n    bytes32 private constant _DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));\n        }\n    }\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "checkpoints",
                "numCheckpoints",
                "delegates",
                "getVotes",
                "getPastVotes",
                "getPastTotalSupply",
                "_checkpointsLookup",
                "delegate",
                "delegateBySig",
                "_maxSupply",
                "_mint",
                "_burn",
                "_afterTokenTransfer",
                "_delegate",
                "_moveVotingPower",
                "_writeCheckpoint",
                "_add",
                "_subtract"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC20Votes_votes_solvency",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Votes.sol",
        "target_function": "_burn/checkpoints/numcheckpoints",
        "text_chunk": "function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }",
        "formal_property": "invariant votes_solvency()\n    totalSupply() >= to_uint256(totalVotes())\nfiltered { f -> f.selector != _burn(address, uint256).selector}\n{ preserved with(env e) {\n    require forall address account. numCheckpoints(account) < 1000000;",
        "nl_summary": "",
        "metadata": {
            "rule_name": "votes_solvency",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "ERC20Votes_blockNum_constrains_fromBlock",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Votes.sol",
        "target_function": "checkpoints/numcheckpoints",
        "text_chunk": "function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }",
        "formal_property": "invariant blockNum_constrains_fromBlock(address account, uint32 index, env e)\n    ckptFromBlock(account, index) < e.block.number\n    filtered { f -> !f.isView }\n{\n    preserved {\n        require index < numCheckpoints(account);",
        "nl_summary": "",
        "metadata": {
            "rule_name": "blockNum_constrains_fromBlock",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "ERC20Votes_maxInt_constrains_numBlocks",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Votes.sol",
        "target_function": "checkpoints/numcheckpoints",
        "text_chunk": "function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }",
        "formal_property": "invariant maxInt_constrains_numBlocks(address account)\n//     numCheckpoints(account) < 4294967295 // 2^32\n\n// can't have more checkpoints for a given account than the last from block\n// passes\ninvariant fromBlock_constrains_numBlocks(address account)\n    numCheckpoints(account) <= ckptFromBlock(account, numCheckpoints(account) - 1)\n    filtered { f -> !f.isView }\n{ preserved with(env e) {\n    require e.block.number >= ckptFromBlock(account, numCheckpoints(account) - 1);",
        "nl_summary": "",
        "metadata": {
            "rule_name": "maxInt_constrains_numBlocks",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "ERC20Votes_fromBlock_greaterThanEq_pos",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "ERC20Votes.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"./draft-ERC20Permit.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../governance/utils/IVotes.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\nabstract contract ERC20Votes is IVotes, ERC20Permit {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n    bytes32 private constant _DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));\n        }\n    }\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n}",
        "formal_property": "invariant fromBlock_greaterThanEq_pos(address account, uint32 pos)\n    ckptFromBlock(account, pos) >= pos\n    filtered { f -> !f.isView }\n\n// a larger index must have a larger fromBlock\n// passes + rule sanity\ninvariant fromBlock_increasing(address account, uint32 pos, uint32 pos2)\n    pos > pos2 => ckptFromBlock(account, pos) > ckptFromBlock(account, pos2)\n    filtered { f -> !f.isView }\n\n\n// converted from an invariant to a rule to slightly change the logic\n// if the fromBlock is the same as before, then the number of checkpoints stays the same\n// however if the fromBlock is new than the number of checkpoints increases\n// passes, fails rule sanity because tautology check seems to be bugged\nrule unique_checkpoints_rule(method f) {\n    env e;",
        "nl_summary": "",
        "metadata": {
            "rule_name": "fromBlock_greaterThanEq_pos",
            "rule_type": "INVARIANT"
        }
    }
]