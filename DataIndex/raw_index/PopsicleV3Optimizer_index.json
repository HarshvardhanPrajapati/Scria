[
    {
        "id": "PopsicleV3Optimizer_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"./interfaces/external/IWETH9.sol\";\nimport \"./utils/ReentrancyGuard.sol\";\nimport './libraries/TransferHelper.sol';\nimport \"./libraries/SqrtPriceMath.sol\";\nimport \"./base/ERC20Permit.sol\";\nimport \"./libraries/PoolActions.sol\";\nimport \"./interfaces/IOptimizerStrategy.sol\";\nimport \"./interfaces/IPopsicleV3Optimizer.sol\";\n\n/// @title PopsicleV3 Optimizer is a yield enchancement v3 contract\n/// @dev PopsicleV3 Optimizer is a Uniswap V3 yield enchancement contract which acts as\n/// intermediary between the user who wants to provide liquidity to specific pools\n/// and earn fees from such actions. The contract ensures that user position is in \n/// range and earns maximum amount of fees available at current liquidity utilization\n/// rate. \ncontract PopsicleV3Optimizer is ERC20Permit, ReentrancyGuard, IPopsicleV3Optimizer {\n    using LowGasSafeMath for uint256;\n    using LowGasSafeMath for uint160;\n    using LowGasSafeMath for uint128;\n    using UnsafeMath for uint256;\n    using SafeCast for uint256;\n    using PoolVariables for IUniswapV3Pool;\n    using PoolActions for IUniswapV3Pool;\n    \n    //Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n    struct MintCallbackData {\n        address payer;\n    }\n    //Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    struct SwapCallbackData {\n        bool zeroForOne;\n    }\n\n    /// @notice Emitted when user adds liquidity\n    /// @param sender The address that minted the liquidity\n    /// @param recipient The address that get shares\n    /// @param share The amount of share of liquidity added by the user to position\n    /// @param amount0 How much token0 was required for the added liquidity\n    /// @param amount1 How much token1 was required for the added liquidity\n    event Deposit(\n        address indexed sender,\n        address indexed recipient,\n        uint256 share,\n        uint256 amount0,\n        uint256 amount1\n    );\n    \n    /// @notice Emitted when user withdraws liquidity\n    /// @param sender The address that minted the liquidity\n    /// @param recipient The address that get amounts\n    /// @param shares of liquidity withdrawn by the user from the position\n    /// @param amount0 How much token0 was required for the added liquidity\n    /// @param amount1 How much token1 was required for the added liquidity\n    event Withdraw(\n        address indexed sender,\n        address indexed recipient,\n        uint256 shares,\n        uint256 amount0,\n        uint256 amount1\n    );\n    \n    /// @notice Emitted when fees was collected from the pool\n    /// @param feesFromPool0 Total amount of fees collected in terms of token 0\n    /// @param feesFromPool1 Total amount of fees collected in terms of token 1\n    /// @param usersFees0 Total amount of fees collected by users in terms of token 0\n    /// @param usersFees1 Total amount of fees collected by users in terms of token 1\n    event CollectFees(\n        uint256 feesFromPool0,\n        uint256 feesFromPool1,\n        uint256 usersFees0,\n        uint256 usersFees1\n    );\n\n    /// @notice Emitted when fees was compuonded to the pool\n    /// @param amount0 Total amount of fees compounded in terms of token 0\n    /// @param amount1 Total amount of fees compounded in terms of token 1\n    event CompoundFees(\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when PopsicleV3 Optimizer changes the position in the pool\n    /// @param tickLower Lower price tick of the positon\n    /// @param tickUpper Upper price tick of the position\n    /// @param amount0 Amount of token 0 deposited to the position\n    /// @param amount1 Amount of token 1 deposited to the position\n    event Rerange(\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 amount0,\n        uint256 amount1\n    );\n    \n    /// @notice Emitted when user collects his fee share\n    /// @param sender User address\n    /// @param fees0 Exact amount of fees claimed by the users in terms of token 0 \n    /// @param fees1 Exact amount of fees claimed by the users in terms of token 1\n    event RewardPaid(\n        address indexed sender,\n        uint256 fees0,\n        uint256 fees1\n    );\n    \n    /// @notice Shows current Optimizer's balances\n    /// @param totalAmount0 Current token0 Optimizer's balance\n    /// @param totalAmount1 Current token1 Optimizer's balance\n    event Snapshot(uint256 totalAmount0, uint256 totalAmount1);\n\n    event TransferGovernance(address indexed previousGovernance, address indexed newGovernance);\n    \n    /// @notice Prevents calls from users\n    modifier onlyGovernance {\n        require(msg.sender == governance, \"OG\");\n        _;\n    }\n\n    /// @inheritdoc IPopsicleV3Optimizer\n    address public immutable override token0;\n    /// @inheritdoc IPopsicleV3Optimizer\n    address public immutable override token1;\n    // WETH address\n    address public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    // @inheritdoc IPopsicleV3Optimizer\n    int24 public immutable override tickSpacing;\n\n    uint24 constant GLOBAL_DIVISIONER = 1e6; // for basis point (0.0001%)\n    //The protocol's fee in hundredths of a bip, i.e. 1e-6\n    uint24 constant protocolFee = 2 * 1e5; //20%\n\n    mapping (address => bool) private _operatorApproved;\n\n    // @inheritdoc IPopsicleV3Optimizer\n    IUniswapV3Pool public override pool;\n    // Accrued protocol fees in terms of token0\n    uint256 public protocolFees0;\n    // Accrued protocol fees in terms of token1\n    uint256 public protocolFees1;\n    // Total lifetime accrued fees in terms of token0\n    uint256 public totalFees0;\n    // Total lifetime accrued fees in terms of token1\n    uint256 public totalFees1;\n    \n    // Address of the Optimizer's owner\n    address public governance;\n    // Pending to claim ownership address\n    address public pendingGovernance;\n    //PopsicleV3 Optimizer settings address\n    address public strategy;\n    // Current tick lower of Optimizer pool position\n    int24 public override tickLower;\n    // Current tick higher of Optimizer pool position\n    int24 public override tickUpper;\n    // Checks if Optimizer is initialized\n    bool public initialized;\n\n    bool private _paused = false;\n    \n    /**\n     * @dev After deploying, strategy can be set via `setStrategy()`\n     * @param _pool Underlying Uniswap V3 pool with fee = 3000\n     * @param _strategy Underlying Optimizer Strategy for Optimizer settings\n     */\n     constructor(\n        address _pool,\n        address _strategy\n    ) ERC20(\"Popsicle LP V3 USDT/WETH\", \"PLP\") ERC20Permit(\"Popsicle LP V3 USDT/WETH\") {\n        pool = IUniswapV3Pool(_pool);\n        strategy = _strategy;\n        token0 = pool.token0();\n        token1 = pool.token1();\n        tickSpacing = pool.tickSpacing();\n        governance = msg.sender;\n        _operatorApproved[msg.sender] = true;\n    }\n    //initialize strategy\n    function init() external onlyGovernance {\n        require(!initialized, \"F\");\n        initialized = true;\n        int24 baseThreshold = tickSpacing * IOptimizerStrategy(strategy).tickRangeMultiplier();\n        ( , int24 currentTick, , , , , ) = pool.slot0();\n        int24 tickFloor = PoolVariables.floor(currentTick, tickSpacing);\n        \n        tickLower = tickFloor - baseThreshold;\n        tickUpper = tickFloor + baseThreshold;\n        PoolVariables.checkRange(tickLower, tickUpper); //check ticks also for overflow/underflow\n    }\n    \n    /// @inheritdoc IPopsicleV3Optimizer\n     function deposit(\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        checkDeviation\n        whenNotPaused\n        returns (\n            uint256 shares,\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        _earnFees();\n        _compoundFees(); // prevent user drains others\n        (uint256 usersAmount0, uint256 usersAmount1) = pool.usersAmounts(tickLower, tickUpper);\n        usersAmount0 = usersAmount0.add(_balance0().unsafeDiv(2)); // prevent draining\n        usersAmount1 = usersAmount1.add(_balance1().unsafeDiv(2));\n        \n        // compute the liquidity amount\n        uint128 liquidity = pool.liquidityForAmounts(amount0Desired, amount1Desired, tickLower, tickUpper);\n        \n        (amount0, amount1) = pool.mint(\n            address(this),\n            tickLower,\n            tickUpper,\n            liquidity,\n            abi.encode(MintCallbackData({payer: msg.sender})));\n        \n        require(amount0 > 0 && amount1 > 0, \"ANV\");\n        uint256 shares0 = \n            totalSupply() == 0 \n            ? liquidity\n            : FullMath.mulDiv(amount0, totalSupply(), usersAmount0);\n        \n        uint256 shares1 = \n            totalSupply() == 0 \n            ? liquidity\n            : FullMath.mulDiv(amount1, totalSupply(), usersAmount1);\n        shares =  shares0 < shares1 ? shares0 : shares1;\n\n        _mint(to, shares);\n        require(IOptimizerStrategy(strategy).maxTotalSupply() >= totalSupply(), \"MTS\");\n        emit Deposit(msg.sender, to, shares, amount0, amount1);\n    }\n    \n    /// @inheritdoc IPopsicleV3Optimizer\n    // function withdraw(\n    //     uint256 shares,\n    //     address to\n    // ) \n    //     external\n    //     override\n    //     nonReentrant\n    //     checkDeviation\n    //     whenNotPaused\n    //     returns (\n    //         uint256 amount0,\n    //         uint256 amount1\n    //     )\n    // {\n    //     require(shares > 0, \"S\");\n    //     require(to != address(0), \"WZA\");\n    //     _earnFees();\n    //     _compoundFees();\n    //     uint128 balance0Liquidity = LiquidityAmounts.getLiquidityForAmount0(\n    //             TickMath.getSqrtRatioAtTick(tickLower),\n    //             TickMath.getSqrtRatioAtTick(tickUpper),\n    //             _balance0()\n    //         );\n    //     uint128 balance1Liquidity = LiquidityAmounts.getLiquidityForAmount1(\n    //             TickMath.getSqrtRatioAtTick(tickLower),\n    //             TickMath.getSqrtRatioAtTick(tickUpper),\n    //             _balance1()\n    //         );\n    //     uint128 totalLiquidity = pool.positionLiquidity(tickLower, tickUpper).add128(balance0Liquidity).add128(balance1Liquidity) ;\n    //     (amount0, amount1) = pool.burnLiquidityShare( tickLower, tickUpper, totalSupply(), shares,  to,  totalLiquidity);\n    //     require(amount0 > 0 || amount1 > 0, \"EA\");\n    //     //certora \n    //     // require(!(shares == totalSupply()) || ((amount0 == IERC20(token0).balanceOf(address(pool)) && amount1 == IERC20(token1).balanceOf(address(pool))) ));\n    //     // require(shares == totalSupply() || ((amount0 < IERC20(token0).balanceOf(address(pool)) || amount1 < IERC20(token1).balanceOf(address(pool))) ));\n    //     // Burn shares\n    //     _burn(msg.sender, shares);\n        \n    //     emit Withdraw(msg.sender, shares, amount0, amount1);\n    // }\n    \n    function withdraw(\n        uint256 shares,\n        address to\n    ) \n        external\n        override\n        nonReentrant\n        checkDeviation\n        whenNotPaused\n        returns (\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        require(shares > 0, \"S\");\n        require(to != address(0), \"WZA\");\n        _earnFees();\n        _compoundFees();\n        (amount0, amount1) = pool.burnLiquidityShare(tickLower, tickUpper, totalSupply(), shares,  to);\n        require(amount0 > 0 || amount1 > 0, \"EA\");\n        uint256 imbalancedAmount0 = FullMath.mulDiv(_balance0(), shares, totalSupply());\n        uint256 imbalancedAmount1 = FullMath.mulDiv(_balance1(), shares, totalSupply());\n        if (imbalancedAmount0 > 0) pay(token0, address(this), to, imbalancedAmount0);\n        if (imbalancedAmount1 > 0) pay(token1, address(this), to, imbalancedAmount1);\n        // Burn shares\n        _burn(msg.sender, shares);\n        \n        emit Withdraw(msg.sender, to, shares, amount0, amount1);\n    }\n\n    /// @inheritdoc IPopsicleV3Optimizer\n    function rerange() external override nonReentrant checkDeviation {\n        require(_operatorApproved[msg.sender], \"ONA\");\n        _earnFees();\n        //Burn all liquidity from pool to rerange for Optimizer's balances.\n        pool.burnAllLiquidity(tickLower, tickUpper);\n        \n\n        // Emit snapshot to record balances\n        uint256 balance0 = _balance0();\n        uint256 balance1 = _balance1();\n        emit Snapshot(balance0, balance1);\n\n        int24 baseThreshold = tickSpacing * IOptimizerStrategy(strategy).tickRangeMultiplier();\n\n        //Get exact ticks depending on Optimizer's balances\n        (tickLower, tickUpper) = pool.getPositionTicks(balance0, balance1, baseThreshold, tickSpacing);\n\n        //Get Liquidity for Optimizer's balances\n        uint128 liquidity = pool.liquidityForAmounts(balance0, balance1, tickLower, tickUpper);\n        \n        // Add liquidity to the pool\n        (uint256 amount0, uint256 amount1) = pool.mint(\n            address(this),\n            tickLower,\n            tickUpper,\n            liquidity,\n            abi.encode(MintCallbackData({payer: address(this)})));\n\n        emit Rerange(tickLower, tickUpper, amount0, amount1);\n    }\n\n    /// @inheritdoc IPopsicleV3Optimizer\n    function rebalance() external override nonReentrant checkDeviation {\n        require(_operatorApproved[msg.sender], \"ONA\");\n    //    _earnFees();\n        //Burn all liquidity from pool to rerange for Optimizer's balances.\n        pool.burnAllLiquidity(tickLower, tickUpper);\n        \n        //Calc base ticks\n        (uint160 sqrtPriceX96, int24 currentTick, , , , , ) = pool.slot0();\n        PoolVariables.Info memory cache;\n        int24 baseThreshold = tickSpacing * IOptimizerStrategy(strategy).tickRangeMultiplier();\n        (cache.tickLower, cache.tickUpper) = PoolVariables.baseTicks(currentTick, baseThreshold, tickSpacing);\n        \n        cache.amount0Desired = _balance0();\n        cache.amount1Desired = _balance1();\n        emit Snapshot(cache.amount0Desired, cache.amount1Desired);\n        // Calc liquidity for base ticks\n        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, cache.tickLower, cache.tickUpper);\n\n        // Get exact amounts for base ticks\n        (cache.amount0, cache.amount1) = pool.amountsForLiquidity(cache.liquidity, cache.tickLower, cache.tickUpper);\n\n        // Get imbalanced token\n        bool zeroForOne = PoolVariables.amountsDirection(cache.amount0Desired, cache.amount1Desired, cache.amount0, cache.amount1);\n        // Calculate the amount of imbalanced token that should be swapped. Calculations strive to achieve one to one ratio\n        int256 amountSpecified = \n            zeroForOne\n                ? int256(cache.amount0Desired.sub(cache.amount0).unsafeDiv(2))\n                : int256(cache.amount1Desired.sub(cache.amount1).unsafeDiv(2)); // always positive. \"overflow\" safe convertion cuz we are dividing by 2\n\n        // Calculate Price limit depending on price impact\n        uint160 exactSqrtPriceImpact = sqrtPriceX96.mul160(IOptimizerStrategy(strategy).priceImpactPercentage() / 2) / GLOBAL_DIVISIONER;\n        uint160 sqrtPriceLimitX96 = zeroForOne ?  sqrtPriceX96.sub160(exactSqrtPriceImpact) : sqrtPriceX96.add160(exactSqrtPriceImpact);\n\n        //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit\n        pool.swap(\n            address(this),\n            zeroForOne,\n            amountSpecified,\n            sqrtPriceLimitX96,\n            abi.encode(SwapCallbackData({zeroForOne: zeroForOne}))\n        );\n\n\n        (sqrtPriceX96, currentTick, , , , , ) = pool.slot0();\n\n        // Emit snapshot to record balances\n        cache.amount0Desired = _balance0();\n        cache.amount1Desired = _balance1();\n        emit Snapshot(cache.amount0Desired, cache.amount1Desired);\n        //Get exact ticks depending on Optimizer's new balances\n        (tickLower, tickUpper) = pool.getPositionTicks(cache.amount0Desired, cache.amount1Desired, baseThreshold, tickSpacing);\n\n        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, tickLower, tickUpper);\n\n        // Add liquidity to the pool\n        (cache.amount0, cache.amount1) = pool.mint(\n            address(this),\n            tickLower,\n            tickUpper,\n            cache.liquidity,\n            abi.encode(MintCallbackData({payer: address(this)})));\n\n        emit Rerange(tickLower, tickUpper, cache.amount0, cache.amount1);\n    }\n    \n    /// @dev Amount of token0 held as unused balance.\n    function _balance0() internal view returns (uint256) {\n        return IERC20(token0).balanceOf(address(this)).sub(protocolFees0);\n    }\n\n    /// @dev Amount of token1 held as unused balance.\n    function _balance1() internal view returns (uint256) {\n        return IERC20(token1).balanceOf(address(this)).sub(protocolFees1);\n    }\n    \n    /// @dev collects fees from the pool\n    function _earnFees() internal {\n        uint liquidity = pool.positionLiquidity(tickLower, tickUpper);\n        if (liquidity == 0) return; // we can't poke when liquidity is zero\n         // Do zero-burns to poke the Uniswap pools so earned fees are updated\n        pool.burn(tickLower, tickUpper, 0);\n        \n        (uint256 collect0, uint256 collect1) =\n            pool.collect(\n                address(this),\n                tickLower,\n                tickUpper,\n                type(uint128).max,\n                type(uint128).max\n            );\n\n        // Calculate protocol's fees\n        uint256 earnedProtocolFees0 = collect0.mul(protocolFee).unsafeDiv(GLOBAL_DIVISIONER); //gadi ?\n        uint256 earnedProtocolFees1 = collect1.mul(protocolFee).unsafeDiv(GLOBAL_DIVISIONER); //gadi ?\n        protocolFees0 = protocolFees0.add(earnedProtocolFees0);\n        protocolFees1 = protocolFees1.add(earnedProtocolFees1);\n        totalFees0 = totalFees0.add(collect0);\n        totalFees1 = totalFees1.add(collect1);\n        emit CollectFees(collect0, collect1, totalFees0, totalFees1);\n    }\n\nuint256 public lastCompoundLiquidity;\n\n    function _compoundFees() internal returns (uint256 amount0, uint256 amount1){\n        uint256 balance0 = _balance0();\n        uint256 balance1 = _balance1();\n\n        emit Snapshot(balance0, balance1);\n\n        //Get Liquidity for Optimizer's balances\n        uint128 liquidity = pool.liquidityForAmounts(balance0, balance1, tickLower, tickUpper);\n        \n        // Add liquidity to the pool\n        if (liquidity > 0)\n        {\n            (amount0, amount1) = pool.mint(\n                address(this),\n                tickLower,\n                tickUpper,\n                liquidity,\n                abi.encode(MintCallbackData({payer: address(this)})));\n\n            lastCompoundLiquidity = liquidity; //Gadi, to differientiate between compound and deposit\n\n            emit CompoundFees(amount0, amount1);\n        }\n    }\n\n    /// @notice Returns current Optimizer's position in pool\n    function position() external view returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128, uint128 tokensOwed0, uint128 tokensOwed1) {\n        bytes32 positionKey = PositionKey.compute(address(this), tickLower, tickUpper);\n        (liquidity, feeGrowthInside0LastX128, feeGrowthInside1LastX128, tokensOwed0, tokensOwed1) = pool.positions(positionKey);\n    }\n\n    /// @notice Returns current Optimizer's users amounts in pool\n    function usersAmounts() public view returns (uint256 amount0, uint256 amount1) {\n        (amount0, amount1) = pool.usersAmounts(tickLower, tickUpper);\n        amount0 = amount0.add(_balance0());\n        amount1 = amount1.add(_balance1());\n    }\n    \n    /// @notice Pull in tokens from sender. Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.\n    /// @dev In the implementation you must pay to the pool for the minted liquidity.\n    /// @param amount0 The amount of token0 due to the pool for the minted liquidity\n    /// @param amount1 The amount of token1 due to the pool for the minted liquidity\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n\n    /// @notice Called to `msg.sender` after minting swaping from IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay to the pool for swap.\n    /// @param amount0 The amount of token0 due to the pool for the swap\n    /// @param amount1 The amount of token1 due to the pool for the swap\n    /// @param _data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0,\n        int256 amount1,\n        bytes calldata _data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        require(amount0 > 0 || amount1 > 0, \"LEZ\"); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        bool zeroForOne = data.zeroForOne;\n\n        if (zeroForOne) pay(token0, address(this), msg.sender, uint256(amount0)); \n        else pay(token1, address(this), msg.sender, uint256(amount1));\n    }\n\n    /// @param token The token to pay\n    /// @param payer The entity that must pay\n    /// @param recipient The entity that will receive payment\n    /// @param value The amount to pay\n    /*\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            TransferHelper.safeTransfer(token, recipient, value);\n        } else {\n            // pull payment\n            TransferHelper.safeTransferFrom(token, payer, recipient, value);\n        }\n    } */\n\n    function pay(\n        address token,\n        address payer,\n        address recipient,\n        uint256 value\n    ) internal {\n        if (token == weth && address(this).balance >= value) {\n            // pay with WETH9\n            IWETH9(weth).deposit{value: value}(); // wrap only what is needed to pay\n            IWETH9(weth).transfer(recipient, value);\n        } else if (payer == address(this)) {\n            // pay with tokens already in the contract (for the exact input multihop case)\n            //TransferHelper.safeTransfer(token, recipient, value);\n            //certora change\n            IERC20(token).transfer(recipient, value);\n\n        } else {\n            // pull payment\n            //TransferHelper.safeTransferFrom(token, payer, recipient, value);\n            //certora change\n            IERC20(token).transferFrom(payer, recipient, value);\n        }\n    }\n    \n    /**\n     * @notice Used to withdraw accumulated protocol fees.\n     */\n    function collectProtocolFees(\n        uint256 amount0,\n        uint256 amount1\n    ) external nonReentrant onlyGovernance {\n        _earnFees();\n        require(protocolFees0 >= amount0, \"A0F\");\n        require(protocolFees1 >= amount1, \"A1F\");\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);\n        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);\n        \n        protocolFees0 = protocolFees0.sub(amount0);\n        protocolFees1 = protocolFees1.sub(amount1);\n        _compoundFees();\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n    // Function modifier that checks if price has not moved a lot recently.\n    // This mitigates price manipulation during rebalance and also prevents placing orders\n    // when it's too volatile.\n    modifier checkDeviation() {\n    //    pool.checkDeviation(IOptimizerStrategy(strategy).maxTwapDeviation(), IOptimizerStrategy(strategy).twapDuration());\n        _;\n    }\n\n    /**\n     * @notice `setGovernance()` should be called by the existing governance\n     * address prior to calling this function.\n     */\n    function setGovernance(address _governance) external onlyGovernance {\n        pendingGovernance = _governance;\n    }\n\n    /**\n     * @notice Governance address is not updated until the new governance\n     * address has called `acceptGovernance()` to accept this responsibility.\n     */\n    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"PG\");\n        emit TransferGovernance(governance, pendingGovernance);\n        pendingGovernance = address(0);\n        governance = msg.sender;\n    }\n\n    // Sets new strategy contract address for new settings\n    function setStrategy(address _strategy) external onlyGovernance {\n        require(_strategy != address(0), \"NA\");\n        strategy = _strategy;\n    }\n\n    function approveOperator(address _operator) external onlyGovernance {\n        _operatorApproved[_operator] = true;\n    }\n    \n    function disableOperator(address _operator) external onlyGovernance {\n        _operatorApproved[_operator] = false;\n    }\n    \n    function isOperator(address _operator) external view returns (bool) {\n        return _operatorApproved[_operator];\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"P\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"NP\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function pause() external onlyGovernance whenNotPaused {\n        _paused = true;\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function unpause() external onlyGovernance whenPaused {\n        _paused = false;\n    }\n\n    // certora helpers\n    function amountInUniswapPerShare() public  returns (uint128){\n        uint128 protocolLiquidity = pool.liquidityForAmounts(protocolFees0, protocolFees1, tickLower, tickUpper);\n        uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);\n        uint128 usersLiquidity = liquidity - protocolLiquidity;\n        uint128 amountInUniswapPerShare = usersLiquidity / (uint128) (totalSupply());\n        return amountInUniswapPerShare;\n    }\n    function protocol_Liquidity() public returns (uint128){\n        uint128 protocolLiquidity = pool.liquidityForAmounts(protocolFees0, protocolFees1, tickLower, tickUpper);\n        return protocolLiquidity;\n    }\n    function position_Liquidity() public returns (uint128){\n        uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);\n        return liquidity;\n    }\n}\n\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "init",
                "deposit",
                "withdraw",
                "rerange",
                "rebalance",
                "_balance0",
                "_balance1",
                "_earnFees",
                "_compoundFees",
                "position",
                "usersAmounts",
                "uniswapV3MintCallback",
                "uniswapV3SwapCallback",
                "pay",
                "collectProtocolFees",
                "setGovernance",
                "acceptGovernance",
                "setStrategy",
                "approveOperator",
                "disableOperator",
                "isOperator",
                "callable",
                "pause",
                "unpause",
                "amountInUniswapPerShare",
                "protocol_Liquidity",
                "position_Liquidity"
            ],
            "state_variables": [
                "protocolFees1",
                "lastCompoundLiquidity",
                "payer",
                "protocolFees0",
                "_operatorApproved",
                "zeroForOne",
                "initialized",
                "pendingGovernance",
                "governance",
                "strategy",
                "totalFees0",
                "totalFees1"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "PopsicleV3Optimizer_balance_vs_protocol_Liquidity_0f7fcbc8",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "protocol_Liquidity/uniswapV3MintCallback/uniswapV3SwapCallback",
        "text_chunk": "    function protocol_Liquidity() public returns (uint128){\n        uint128 protocolLiquidity = pool.liquidityForAmounts(protocolFees0, protocolFees1, tickLower, tickUpper);\n        return protocolLiquidity;\n    }\n\n\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n\n\n    function uniswapV3SwapCallback(\n        int256 amount0,\n        int256 amount1,\n        bytes calldata _data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        require(amount0 > 0 || amount1 > 0, \"LEZ\"); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        bool zeroForOne = data.zeroForOne;\n\n        if (zeroForOne) pay(token0, address(this), msg.sender, uint256(amount0)); \n        else pay(token1, address(this), msg.sender, uint256(amount1));\n    }\n",
        "formal_property": "    ///// invariant balance_vs_protocol_Liquidity()\n    ////  verifies that if total supply is zero than all the assets of the system is the owned to governance \n    ////  uniswapV3SwapCallback() - meaningless outside of the swap context\n    ////  uniswapV3MintCallback() - meaningless outside of the mint context\n    invariant balance_vs_protocol_Liquidity()\n    (totalSupply() == 0) => token0.balanceOf(currentContract) == protocolFees0() //&&\n                            //token1.balanceOf(currentContract) == protocolFees1()\n    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "balance_vs_protocol_Liquidity",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "balanceOf",
                "totalSupply",
                "protocol_Liquidity",
                "governance",
                "protocolFees0",
                "protocolFees1",
                "token0.balanceOf",
                "token1.balanceOf",
                "uniswapV3MintCallback",
                "uniswapV3SwapCallback"
            ],
            "start_line": 92,
            "end_line": 99,
            "block_hash": "0f7fcbc8eb08f3d4d849fc24f8787993"
        }
    },
    {
        "id": "PopsicleV3Optimizer_balance_contract_GE_protocolFees_375befc6",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "uniswapV3MintCallback/uniswapV3SwapCallback",
        "text_chunk": "    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n\n\n    function uniswapV3SwapCallback(\n        int256 amount0,\n        int256 amount1,\n        bytes calldata _data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        require(amount0 > 0 || amount1 > 0, \"LEZ\"); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        bool zeroForOne = data.zeroForOne;\n\n        if (zeroForOne) pay(token0, address(this), msg.sender, uint256(amount0)); \n        else pay(token1, address(this), msg.sender, uint256(amount1));\n    }\n",
        "formal_property": "    ///// invariant balance_contract_GE_protocolFees()\n    ////  verifies that balance of the conttract is greater than protocol fees\n    ////  uniswapV3SwapCallback() - meaningles outside of the swap context\n    ////  uniswapV3MintCallback() - meaningles outside of the mint context\n    invariant balance_contract_GE_protocolFees()\n    token0.balanceOf(currentContract) >= protocolFees0()\n    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "balance_contract_GE_protocolFees",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "balanceOf",
                "protocolFees0",
                "token0.balanceOf",
                "uniswapV3MintCallback",
                "uniswapV3SwapCallback"
            ],
            "start_line": 120,
            "end_line": 126,
            "block_hash": "375befc61e45c970b59a864b5d12d7df"
        }
    },
    {
        "id": "PopsicleV3Optimizer_empty_pool_state_5e4716ed",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "collectProtocolFees/uniswapV3MintCallback",
        "text_chunk": "    function collectProtocolFees(\n        uint256 amount0,\n        uint256 amount1\n    ) external nonReentrant onlyGovernance {\n        _earnFees();\n        require(protocolFees0 >= amount0, \"A0F\");\n        require(protocolFees1 >= amount1, \"A1F\");\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);\n        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);\n        \n        protocolFees0 = protocolFees0.sub(amount0);\n        protocolFees1 = protocolFees1.sub(amount1);\n        _compoundFees();\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n",
        "formal_property": "    ///// invariant empty_pool_state()\n    ////  verifies that pool liquidity == 0 IFF totalSupply == 0\n    ////  collectProtocolFees() - it breakes the rule\n    ////  uniswapV3MintCallback() - meaningless outside of the mint context\n    invariant empty_pool_state()\n    pool.liquidity() == 0 <=> totalSupply() == 0\n    filtered { f -> excludeCallback(f) }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "empty_pool_state",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "totalSupply",
                "pool.liquidity",
                "uniswapV3MintCallback"
            ],
            "start_line": 150,
            "end_line": 156,
            "block_hash": "5e4716ed4ce994ac043dc76b45c9290b"
        }
    },
    {
        "id": "PopsicleV3Optimizer_empty_pool_state_reverse_2fda33f9",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "collectProtocolFees/uniswapV3MintCallback",
        "text_chunk": "    function collectProtocolFees(\n        uint256 amount0,\n        uint256 amount1\n    ) external nonReentrant onlyGovernance {\n        _earnFees();\n        require(protocolFees0 >= amount0, \"A0F\");\n        require(protocolFees1 >= amount1, \"A1F\");\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);\n        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);\n        \n        protocolFees0 = protocolFees0.sub(amount0);\n        protocolFees1 = protocolFees1.sub(amount1);\n        _compoundFees();\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n",
        "formal_property": "    ///// invariant empty_pool_state_reverse()\n    ///// invariant empty_pool_state()\n    ////  verifies that pool liquidity == 0 IFF totalSupply == 0\n    ////  collectProtocolFees() - it breakes the rule\n    ////  uniswapV3MintCallback() - meaningless outside of the mint context\n    invariant empty_pool_state()\n    pool.liquidity() == 0 <=> totalSupply() == 0\n    filtered { f -> excludeCallback(f) }\n    ////  verifies that pool liquidity == 0 IFF pool balance - pool owed == 0\n    ////  following function are excluded:\n    invariant empty_pool_state_reverse()\n    pool.liquidity() == 0 <=> (pool.balance0() - pool.owed0() == 0 && pool.balance1() - pool.owed1() == 0)\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "empty_pool_state_reverse",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "pool.liquidity",
                "pool.balance0",
                "pool.balance1",
                "pool.owed0",
                "pool.owed1",
                "uniswapV3MintCallback"
            ],
            "start_line": 176,
            "end_line": 183,
            "block_hash": "2fda33f914f4d15de64a32f9233815dd"
        }
    },
    {
        "id": "PopsicleV3Optimizer_zero_totalSupply_zero_owed_32ecbe8d",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "collectProtocolFees/uniswapV3MintCallback",
        "text_chunk": "    function collectProtocolFees(\n        uint256 amount0,\n        uint256 amount1\n    ) external nonReentrant onlyGovernance {\n        _earnFees();\n        require(protocolFees0 >= amount0, \"A0F\");\n        require(protocolFees1 >= amount1, \"A1F\");\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);\n        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);\n        \n        protocolFees0 = protocolFees0.sub(amount0);\n        protocolFees1 = protocolFees1.sub(amount1);\n        _compoundFees();\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n",
        "formal_property": "    ///// invariant zero_totalSupply_zero_owed()\n    ////  verifies that all assets withdrawn - totalSupply == 0 - no owed assets left in the pool\n    invariant zero_totalSupply_zero_owed()\n    totalSupply() == 0 => (pool.owed0() == 0 && pool.owed1() == 0){ \n    preserved {\n        requireInvariant empty_pool_state();\n    ///// invariant empty_pool_state()\n    ////  verifies that pool liquidity == 0 IFF totalSupply == 0\n    ////  collectProtocolFees() - it breakes the rule\n    ////  uniswapV3MintCallback() - meaningless outside of the mint context\n    invariant empty_pool_state()\n    pool.liquidity() == 0 <=> totalSupply() == 0\n    filtered { f -> excludeCallback(f) }\n    } \n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "zero_totalSupply_zero_owed",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "totalSupply",
                "pool.owed0",
                "pool.owed1"
            ],
            "start_line": 206,
            "end_line": 213,
            "block_hash": "32ecbe8d970954aa0d16db52e28b0277"
        }
    },
    {
        "id": "PopsicleV3Optimizer_pool_balance_vs_owed_b677a432",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "uniswapV3MintCallback",
        "text_chunk": "    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n",
        "formal_property": "    ///// invariant pool_balance_vs_owed()\n    ////  verifies that pool balance greater equal to pool owed\n    ////  uniswapV3MintCallback() - meaningless outside of the mint context\n    invariant pool_balance_vs_owed()\n    pool.balance0() >= pool.owed0() && pool.balance1() >= pool.owed1()\n    filtered { f -> excludeCallback(f) }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "pool_balance_vs_owed",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "pool.balance0",
                "pool.balance1",
                "pool.owed0",
                "pool.owed1",
                "uniswapV3MintCallback"
            ],
            "start_line": 216,
            "end_line": 221,
            "block_hash": "b677a432004da1355b5dc315da16f0b7"
        }
    },
    {
        "id": "PopsicleV3Optimizer_zero_pool_balance_zero_owed_64c82186",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "uniswapV3MintCallback",
        "text_chunk": "    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n",
        "formal_property": "    ///// invariant zero_pool_balance_zero_owed()\n    ////  verifies that pool balance == 0 implies pool owed == 0\n    ////  uniswapV3MintCallback() - meaningless outside of the mint context\n    invariant zero_pool_balance_zero_owed()\n    (pool.balance0() == 0 => pool.owed0() == 0) && \n    (pool.balance1() == 0 => pool.owed1() == 0)\n    filtered { f -> excludeCallback(f) }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "zero_pool_balance_zero_owed",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "pool.balance0",
                "pool.balance1",
                "pool.owed0",
                "pool.owed1",
                "uniswapV3MintCallback"
            ],
            "start_line": 224,
            "end_line": 230,
            "block_hash": "64c82186857d9ed4adf834371cbc6ac1"
        }
    },
    {
        "id": "PopsicleV3Optimizer_total_vs_protocol_Fees_cde78566",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "deposit",
        "text_chunk": "     function deposit(\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        checkDeviation\n        whenNotPaused\n        returns (\n            uint256 shares,\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        _earnFees();\n        _compoundFees(); // prevent user drains others\n        (uint256 usersAmount0, uint256 usersAmount1) = pool.usersAmounts(tickLower, tickUpper);\n        usersAmount0 = usersAmount0.add(_balance0().unsafeDiv(2)); // prevent draining\n        usersAmount1 = usersAmount1.add(_balance1().unsafeDiv(2));\n        \n        // compute the liquidity amount\n        uint128 liquidity = pool.liquidityForAmounts(amount0Desired, amount1Desired, tickLower, tickUpper);\n        \n        (amount0, amount1) = pool.mint(\n            address(this),\n            tickLower,\n            tickUpper,\n            liquidity,\n            abi.encode(MintCallbackData({payer: msg.sender})));\n        \n        require(amount0 > 0 && amount1 > 0, \"ANV\");\n        uint256 shares0 = \n            totalSupply() == 0 \n            ? liquidity\n            : FullMath.mulDiv(amount0, totalSupply(), usersAmount0);\n        \n        uint256 shares1 = \n            totalSupply() == 0 \n            ? liquidity\n            : FullMath.mulDiv(amount1, totalSupply(), usersAmount1);\n        shares =  shares0 < shares1 ? shares0 : shares1;\n\n        _mint(to, shares);\n        require(IOptimizerStrategy(strategy).maxTotalSupply() >= totalSupply(), \"MTS\");\n        emit Deposit(msg.sender, to, shares, amount0, amount1);\n    }\n",
        "formal_property": "    ///// invariant total_vs_protocol_Fees()\n    ////  verifies that total fees greater than protocol fees\n    invariant total_vs_protocol_Fees()\n    totalFees0() > protocolFees0() ||\n    totalFees0() == 0 &&  protocolFees0() == 0\n    {\n        preserved deposit(uint256 amount0Desired,uint256 amount1Desired, address to) with (env e){\n             require to != currentContract && to != pool && to != governance();\n             require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();\n         } \n    }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "total_vs_protocol_Fees",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "governance",
                "protocolFees0",
                "totalFees0"
            ],
            "start_line": 233,
            "end_line": 243,
            "block_hash": "cde7856669d83eee392da7201f5046aa"
        }
    },
    {
        "id": "PopsicleV3Optimizer_liquidity_GE_poolBalance0_c3957456",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "collectProtocolFees/uniswapV3MintCallback",
        "text_chunk": "    function collectProtocolFees(\n        uint256 amount0,\n        uint256 amount1\n    ) external nonReentrant onlyGovernance {\n        _earnFees();\n        require(protocolFees0 >= amount0, \"A0F\");\n        require(protocolFees1 >= amount1, \"A1F\");\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);\n        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);\n        \n        protocolFees0 = protocolFees0.sub(amount0);\n        protocolFees1 = protocolFees1.sub(amount1);\n        _compoundFees();\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n",
        "formal_property": "    ///// invariant liquidity_GE_poolBalance0()\n    ////  verifies that pool liquidity == pool balance - pool owed\n    ////  collectProtocolFees() - breaks the rule\n    ////  uniswapV3MintCallback() - meaningless outside of the mint context\n    invariant liquidity_GE_poolBalance0()\n    pool.liquidity() == pool.balance0() - pool.owed0()\n    filtered { f -> excludeCallback(f) }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "liquidity_GE_poolBalance0",
            "rule_type": "invariant",
            "modifies_state": true,
            "methods_in_block": [
                "pool.liquidity",
                "pool.balance0",
                "pool.owed0",
                "uniswapV3MintCallback"
            ],
            "start_line": 246,
            "end_line": 252,
            "block_hash": "c395745641b0ecfd5e6733072ad90c02"
        }
    },
    {
        "id": "PopsicleV3Optimizer_zeroCharacteristicOfWithdraw_43b4c95a",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "withdraw",
        "text_chunk": "    function withdraw(\n        uint256 shares,\n        address to\n    ) \n        external\n        override\n        nonReentrant\n        checkDeviation\n        whenNotPaused\n        returns (\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        require(shares > 0, \"S\");\n        require(to != address(0), \"WZA\");\n        _earnFees();\n        _compoundFees();\n        (amount0, amount1) = pool.burnLiquidityShare(tickLower, tickUpper, totalSupply(), shares,  to);\n        require(amount0 > 0 || amount1 > 0, \"EA\");\n        uint256 imbalancedAmount0 = FullMath.mulDiv(_balance0(), shares, totalSupply());\n        uint256 imbalancedAmount1 = FullMath.mulDiv(_balance1(), shares, totalSupply());\n        if (imbalancedAmount0 > 0) pay(token0, address(this), to, imbalancedAmount0);\n        if (imbalancedAmount1 > 0) pay(token1, address(this), to, imbalancedAmount1);\n        // Burn shares\n        _burn(msg.sender, shares);\n        \n        emit Withdraw(msg.sender, to, shares, amount0, amount1);\n    }\n",
        "formal_property": "///// rule zeroCharacteristicOfWithdraw()\n////  verifies that if withraw returns amount0 == 0 and amount1 == 0 then necessarily shares == 0\nrule zeroCharacteristicOfWithdraw(uint256 shares, address to){\n    env e;\n    uint256 amount0;\n    uint256 amount1;\n\n    require governance() != currentContract;\n    require governance() != pool;\n    require to != currentContract && to != pool && to != governance();\n    require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();\n    amount0,amount1 =  withdraw(e,shares, to);\n    assert (amount0 == 0 && amount1 == 0 => shares == 0);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "zeroCharacteristicOfWithdraw",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "governance"
            ],
            "start_line": 278,
            "end_line": 293,
            "block_hash": "43b4c95a3f7bf89d97361dbea543b5be"
        }
    },
    {
        "id": "PopsicleV3Optimizer_more_shares_more_amounts_to_withdraw_cb845d08",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "withdraw",
        "text_chunk": "    function withdraw(\n        uint256 shares,\n        address to\n    ) \n        external\n        override\n        nonReentrant\n        checkDeviation\n        whenNotPaused\n        returns (\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        require(shares > 0, \"S\");\n        require(to != address(0), \"WZA\");\n        _earnFees();\n        _compoundFees();\n        (amount0, amount1) = pool.burnLiquidityShare(tickLower, tickUpper, totalSupply(), shares,  to);\n        require(amount0 > 0 || amount1 > 0, \"EA\");\n        uint256 imbalancedAmount0 = FullMath.mulDiv(_balance0(), shares, totalSupply());\n        uint256 imbalancedAmount1 = FullMath.mulDiv(_balance1(), shares, totalSupply());\n        if (imbalancedAmount0 > 0) pay(token0, address(this), to, imbalancedAmount0);\n        if (imbalancedAmount1 > 0) pay(token1, address(this), to, imbalancedAmount1);\n        // Burn shares\n        _burn(msg.sender, shares);\n        \n        emit Withdraw(msg.sender, to, shares, amount0, amount1);\n    }\n",
        "formal_property": "///// rule more_shares_more_amounts_to_withdraw()\n////  verifies that with larger number of shares one will withdraw a larger amount of assets\n////  this rule passes only when the following line added to burnLiquidityShares():\n////  require (share == liquidity * totalSupply/uint256(liquidityInPool));\n// rule more_shares_more_amounts_to_withdraw( address to){\n// env e;\n//     uint256 sharesX;\n//     uint256 sharesY;\n//     uint256 amount0X;\n//     uint256 amount1X;\n//     uint256 amount0Y;\n//     uint256 amount1Y;\n\n//     require governance() != currentContract;\n//     require governance() != pool;\n//     require to != currentContract && to != pool && to != governance();\n//     require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();\n//     require sharesX > sharesY;\n//     storage init = lastStorage;\n    \n//     amount0X,amount1X =  withdraw(e,sharesX, to);\n//     amount0Y,amount1Y =  withdraw(e,sharesY, to) at init;\n//     assert amount0X >= amount0Y && amount1X >= amount1Y;\n// }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "more_shares_more_amounts_to_withdraw",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "totalSupply",
                "governance"
            ],
            "start_line": 295,
            "end_line": 321,
            "block_hash": "cb845d08b4ee669dba0ee29ca86131d8"
        }
    },
    {
        "id": "PopsicleV3Optimizer_totalSupply_vs_positionAmounts_6fe15b7b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "position_Liquidity",
        "text_chunk": "    function position_Liquidity() public returns (uint128){\n        uint128 liquidity = pool.positionLiquidity(tickLower, tickUpper);\n        return liquidity;\n    }\n",
        "formal_property": "///// rule totalSupply_vs_positionAmounts()\n////  verifies that totalSupply before applying f() greater than totalSupply after implies posistion \n////  liquidity before is greater than position liquidity after minus last compound liquidity\nrule totalSupply_vs_positionAmounts(method f){\n   env e;\n\n   uint256 totalSupplyBefore = totalSupply();\n   uint256 posLiquidityBefore = position_Liquidity();\n    require governance() != currentContract;\n    require governance() != pool;\n   require lastCompoundLiquidity(e) == 0;\n   calldataarg args;\n\tf(e,args);\n   uint256 totalSupplyAfter = totalSupply();\n   uint256 posLiquidityAfter = position_Liquidity();   \n   uint256 compoundAfter = lastCompoundLiquidity(e);\n    assert totalSupplyAfter < totalSupplyBefore =>\n            posLiquidityAfter - compoundAfter < posLiquidityBefore;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "totalSupply_vs_positionAmounts",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "totalSupply",
                "position_Liquidity",
                "governance"
            ],
            "start_line": 323,
            "end_line": 346,
            "block_hash": "6fe15b7b7e2ae20d37e3e0e6a420be86"
        }
    },
    {
        "id": "PopsicleV3Optimizer_protocolFees_state_4eb34e82",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "acceptGovernance/uniswapV3MintCallback/uniswapV3SwapCallback",
        "text_chunk": "    function acceptGovernance() external {\n        require(msg.sender == pendingGovernance, \"PG\");\n        emit TransferGovernance(governance, pendingGovernance);\n        pendingGovernance = address(0);\n        governance = msg.sender;\n    }\n\n\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n\n\n    function uniswapV3SwapCallback(\n        int256 amount0,\n        int256 amount1,\n        bytes calldata _data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        require(amount0 > 0 || amount1 > 0, \"LEZ\"); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        bool zeroForOne = data.zeroForOne;\n\n        if (zeroForOne) pay(token0, address(this), msg.sender, uint256(amount0)); \n        else pay(token1, address(this), msg.sender, uint256(amount1));\n    }\n",
        "formal_property": "///// rule protocolFees_state()\n////  verifies that balance of governance before applying f() + the change in protocolFees is greater or equal balance of governance after applying f()\n////  uniswapV3SwapCallback() - meaningless outside of the swap context\n////  uniswapV3MintCallback() - meaningless outside of the mint context\n////  acceptGovernance()      - breaks the rule when governance changes\nrule protocolFees_state(env e, method f, uint256 shares, address to)\n    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector && f.selector != acceptGovernance().selector }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "protocolFees_state",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "governance",
                "uniswapV3MintCallback",
                "uniswapV3SwapCallback"
            ],
            "start_line": 348,
            "end_line": 354,
            "block_hash": "4eb34e82586c7b03fec7400b214eceeb"
        }
    },
    {
        "id": "PopsicleV3Optimizer_empty_pool_zero_totalSupply_0ee3df0b",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "collectProtocolFees/uniswapV3MintCallback",
        "text_chunk": "    function collectProtocolFees(\n        uint256 amount0,\n        uint256 amount1\n    ) external nonReentrant onlyGovernance {\n        _earnFees();\n        require(protocolFees0 >= amount0, \"A0F\");\n        require(protocolFees1 >= amount1, \"A1F\");\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);\n        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);\n        \n        protocolFees0 = protocolFees0.sub(amount0);\n        protocolFees1 = protocolFees1.sub(amount1);\n        _compoundFees();\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n",
        "formal_property": "///// rule empty_pool_zero_totalSupply()\n////  verifies that pool is empty IFF totalSupply == 0\n////  uniswapV3MintCallback() - meaningless outside of the mint context\n////  collectProtocolFees() - it breakes the rule\nrule empty_pool_zero_totalSupply(method f, address to)\nfiltered { f -> excludeCallback(f) }{\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "empty_pool_zero_totalSupply",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "totalSupply",
                "uniswapV3MintCallback"
            ],
            "start_line": 381,
            "end_line": 386,
            "block_hash": "0ee3df0bf509cc50c4455692c7f258ec"
        }
    },
    {
        "id": "PopsicleV3Optimizer_withdraw_amount_ca74932f",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "collectProtocolFees/deposit/uniswapV3MintCallback/uniswapV3SwapCallback/withdraw",
        "text_chunk": "    function collectProtocolFees(\n        uint256 amount0,\n        uint256 amount1\n    ) external nonReentrant onlyGovernance {\n        _earnFees();\n        require(protocolFees0 >= amount0, \"A0F\");\n        require(protocolFees1 >= amount1, \"A1F\");\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        require(balance0 >= amount0 && balance1 >= amount1);\n        if (amount0 > 0) pay(token0, address(this), msg.sender, amount0);\n        if (amount1 > 0) pay(token1, address(this), msg.sender, amount1);\n        \n        protocolFees0 = protocolFees0.sub(amount0);\n        protocolFees1 = protocolFees1.sub(amount1);\n        _compoundFees();\n        emit RewardPaid(msg.sender, amount0, amount1);\n    }\n\n\n     function deposit(\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        checkDeviation\n        whenNotPaused\n        returns (\n            uint256 shares,\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        _earnFees();\n        _compoundFees(); // prevent user drains others\n        (uint256 usersAmount0, uint256 usersAmount1) = pool.usersAmounts(tickLower, tickUpper);\n        usersAmount0 = usersAmount0.add(_balance0().unsafeDiv(2)); // prevent draining\n        usersAmount1 = usersAmount1.add(_balance1().unsafeDiv(2));\n        \n        // compute the liquidity amount\n        uint128 liquidity = pool.liquidityForAmounts(amount0Desired, amount1Desired, tickLower, tickUpper);\n        \n        (amount0, amount1) = pool.mint(\n            address(this),\n            tickLower,\n            tickUpper,\n            liquidity,\n            abi.encode(MintCallbackData({payer: msg.sender})));\n        \n        require(amount0 > 0 && amount1 > 0, \"ANV\");\n        uint256 shares0 = \n            totalSupply() == 0 \n            ? liquidity\n            : FullMath.mulDiv(amount0, totalSupply(), usersAmount0);\n        \n        uint256 shares1 = \n            totalSupply() == 0 \n            ? liquidity\n            : FullMath.mulDiv(amount1, totalSupply(), usersAmount1);\n        shares =  shares0 < shares1 ? shares0 : shares1;\n\n        _mint(to, shares);\n        require(IOptimizerStrategy(strategy).maxTotalSupply() >= totalSupply(), \"MTS\");\n        emit Deposit(msg.sender, to, shares, amount0, amount1);\n    }\n\n\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));\n        if (amount0 > 0) pay(token0, decoded.payer, msg.sender, amount0);\n        if (amount1 > 0) pay(token1, decoded.payer, msg.sender, amount1);\n    }\n\n\n    function uniswapV3SwapCallback(\n        int256 amount0,\n        int256 amount1,\n        bytes calldata _data\n    ) external {\n        require(msg.sender == address(pool), \"FP\");\n        require(amount0 > 0 || amount1 > 0, \"LEZ\"); // swaps entirely within 0-liquidity regions are not supported\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n        bool zeroForOne = data.zeroForOne;\n\n        if (zeroForOne) pay(token0, address(this), msg.sender, uint256(amount0)); \n        else pay(token1, address(this), msg.sender, uint256(amount1));\n    }\n\n\n    function withdraw(\n        uint256 shares,\n        address to\n    ) \n        external\n        override\n        nonReentrant\n        checkDeviation\n        whenNotPaused\n        returns (\n            uint256 amount0,\n            uint256 amount1\n        )\n    {\n        require(shares > 0, \"S\");\n        require(to != address(0), \"WZA\");\n        _earnFees();\n        _compoundFees();\n        (amount0, amount1) = pool.burnLiquidityShare(tickLower, tickUpper, totalSupply(), shares,  to);\n        require(amount0 > 0 || amount1 > 0, \"EA\");\n        uint256 imbalancedAmount0 = FullMath.mulDiv(_balance0(), shares, totalSupply());\n        uint256 imbalancedAmount1 = FullMath.mulDiv(_balance1(), shares, totalSupply());\n        if (imbalancedAmount0 > 0) pay(token0, address(this), to, imbalancedAmount0);\n        if (imbalancedAmount1 > 0) pay(token1, address(this), to, imbalancedAmount1);\n        // Burn shares\n        _burn(msg.sender, shares);\n        \n        emit Withdraw(msg.sender, to, shares, amount0, amount1);\n    }\n",
        "formal_property": "// rule withdraw_amount(address to){\n//     env e;\n\n//     require governance() != currentContract;\n//     require governance() != pool;\n//     require (to!=governance() && to != pool && to != currentContract);\n//     require e.msg.sender != pool && e.msg.sender != currentContract && e.msg.sender != governance();\n//     require token0.balanceOf(currentContract) == 0 &&\n//             token1.balanceOf(currentContract) == 0;\n//             requireInvariant empty_pool_state();\n    ///// invariant empty_pool_state()\n    ////  verifies that pool liquidity == 0 IFF totalSupply == 0\n    ////  collectProtocolFees() - it breakes the rule\n    ////  uniswapV3MintCallback() - meaningless outside of the mint context\n    invariant empty_pool_state()\n    pool.liquidity() == 0 <=> totalSupply() == 0\n    filtered { f -> excludeCallback(f) }\n//             requireInvariant zero_totalSupply_zero_owed();\n    ///// invariant zero_totalSupply_zero_owed()\n    ////  verifies that all assets withdrawn - totalSupply == 0 - no owed assets left in the pool\n    invariant zero_totalSupply_zero_owed()\n    totalSupply() == 0 => (pool.owed0() == 0 && pool.owed1() == 0){ \n    preserved {\n        requireInvariant empty_pool_state();\n    } \n    }\n//             requireInvariant pool_balance_vs_owed();\n    ///// invariant pool_balance_vs_owed()\n    ////  verifies that pool balance greater equal to pool owed\n    invariant pool_balance_vs_owed()\n    pool.balance0() >= pool.owed0() && pool.balance1() >= pool.owed1()\n//             requireInvariant total_vs_protocol_Fees();\n    ///// invariant total_vs_protocol_Fees()\n    ////  verifies that total fees greater than protocol fees\n    invariant total_vs_protocol_Fees()\n    totalFees0() > protocolFees0() ||\n    totalFees0() == 0 &&  protocolFees0() == 0\n    {\n        preserved deposit(uint256 amount0Desired,uint256 amount1Desired, address to) with (env e){\n             require to != currentContract && to != pool && to != governance();\n             require e.msg.sender != currentContract && e.msg.sender != pool && e.msg.sender != governance();\n         } \n//             requireInvariant liquidity_GE_poolBalance0();\n    ///// invariant liquidity_GE_poolBalance0()\n    ////  verifies that pool liquidity == pool balance - pool owed\n    ////  collectProtocolFees() - breaks the rule\n    invariant liquidity_GE_poolBalance0()\n    pool.liquidity() == pool.balance0() - pool.owed0()\n//             requireInvariant balance_contract_GE_protocolFees();\n    ///// invariant balance_contract_GE_protocolFees()\n    ////  verifies that balance of the conttract is greater than protocol fees\n    ////  uniswapV3SwapCallback() - meaningles outside of the swap context\n    ////  uniswapV3MintCallback() - meaningles outside of the mint context\n    invariant balance_contract_GE_protocolFees()\n    token0.balanceOf(currentContract) >= protocolFees0()\n    filtered { f -> f.selector != uniswapV3MintCallback(uint256,uint256,bytes).selector && f.selector != uniswapV3SwapCallback(int256,int256,bytes).selector }\n//     uint256 shares;\n//     uint256 amount0;\n//     uint256 amount1;\n//     uint256 totalsupply = totalSupply();\n//     uint256 pool_balance0 = pool.balance0();\n//     uint256 pool_owed0 = pool.owed0();\n//             amount0,amount1 =  withdraw(e,shares, to);\n    \n//     // uint256 amount0_calc = (pool_balance0 - pool_owed0) * shares / totalsupply;\n//     mathint amount0_calc = pool_balance0 * shares / totalsupply;\n//     require amount0_calc >= 1;\n//     assert  amount0 <= amount0_calc;\n// }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "withdraw_amount",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "balanceOf",
                "totalSupply",
                "governance",
                "token0.balanceOf",
                "token1.balanceOf",
                "pool.balance0",
                "pool.owed0"
            ],
            "start_line": 423,
            "end_line": 456,
            "block_hash": "ca74932f31646ae75b1447b838e76810"
        }
    },
    {
        "id": "PopsicleV3Optimizer_zeroBalancesAfterRebalance_f31d64c6",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "PopsicleV3Optimizer.sol",
        "target_function": "rebalance",
        "text_chunk": "    function rebalance() external override nonReentrant checkDeviation {\n        require(_operatorApproved[msg.sender], \"ONA\");\n    //    _earnFees();\n        //Burn all liquidity from pool to rerange for Optimizer's balances.\n        pool.burnAllLiquidity(tickLower, tickUpper);\n        \n        //Calc base ticks\n        (uint160 sqrtPriceX96, int24 currentTick, , , , , ) = pool.slot0();\n        PoolVariables.Info memory cache;\n        int24 baseThreshold = tickSpacing * IOptimizerStrategy(strategy).tickRangeMultiplier();\n        (cache.tickLower, cache.tickUpper) = PoolVariables.baseTicks(currentTick, baseThreshold, tickSpacing);\n        \n        cache.amount0Desired = _balance0();\n        cache.amount1Desired = _balance1();\n        emit Snapshot(cache.amount0Desired, cache.amount1Desired);\n        // Calc liquidity for base ticks\n        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, cache.tickLower, cache.tickUpper);\n\n        // Get exact amounts for base ticks\n        (cache.amount0, cache.amount1) = pool.amountsForLiquidity(cache.liquidity, cache.tickLower, cache.tickUpper);\n\n        // Get imbalanced token\n        bool zeroForOne = PoolVariables.amountsDirection(cache.amount0Desired, cache.amount1Desired, cache.amount0, cache.amount1);\n        // Calculate the amount of imbalanced token that should be swapped. Calculations strive to achieve one to one ratio\n        int256 amountSpecified = \n            zeroForOne\n                ? int256(cache.amount0Desired.sub(cache.amount0).unsafeDiv(2))\n                : int256(cache.amount1Desired.sub(cache.amount1).unsafeDiv(2)); // always positive. \"overflow\" safe convertion cuz we are dividing by 2\n\n        // Calculate Price limit depending on price impact\n        uint160 exactSqrtPriceImpact = sqrtPriceX96.mul160(IOptimizerStrategy(strategy).priceImpactPercentage() / 2) / GLOBAL_DIVISIONER;\n        uint160 sqrtPriceLimitX96 = zeroForOne ?  sqrtPriceX96.sub160(exactSqrtPriceImpact) : sqrtPriceX96.add160(exactSqrtPriceImpact);\n\n        //Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit\n        pool.swap(\n            address(this),\n            zeroForOne,\n            amountSpecified,\n            sqrtPriceLimitX96,\n            abi.encode(SwapCallbackData({zeroForOne: zeroForOne}))\n        );\n\n\n        (sqrtPriceX96, currentTick, , , , , ) = pool.slot0();\n\n        // Emit snapshot to record balances\n        cache.amount0Desired = _balance0();\n        cache.amount1Desired = _balance1();\n        emit Snapshot(cache.amount0Desired, cache.amount1Desired);\n        //Get exact ticks depending on Optimizer's new balances\n        (tickLower, tickUpper) = pool.getPositionTicks(cache.amount0Desired, cache.amount1Desired, baseThreshold, tickSpacing);\n\n        cache.liquidity = pool.liquidityForAmounts(cache.amount0Desired, cache.amount1Desired, tickLower, tickUpper);\n\n        // Add liquidity to the pool\n        (cache.amount0, cache.amount1) = pool.mint(\n            address(this),\n            tickLower,\n            tickUpper,\n            cache.liquidity,\n            abi.encode(MintCallbackData({payer: address(this)})));\n\n        emit Rerange(tickLower, tickUpper, cache.amount0, cache.amount1);\n    }\n",
        "formal_property": "/* rule zeroBalancesAfterRebalance(){\n    env e;\n    rebalance(e);\n    assert (token0.balanceOf(e, currentContract)==0 && \n                             token1.balanceOf(e, currentContract)==0);\n} */\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "zeroBalancesAfterRebalance",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "balanceOf",
                "token0.balanceOf",
                "token1.balanceOf"
            ],
            "start_line": 458,
            "end_line": 463,
            "block_hash": "f31d64c605997439630566263d0168c5"
        }
    }
]