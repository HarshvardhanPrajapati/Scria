[
    {
        "id": "Governance_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "Governance.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/utils/Address.sol\";\n\nimport \"./interfaces/IGovernance.sol\";\nimport \"./Proposals.sol\";\nimport \"../common/interfaces/IAccounts.sol\";\nimport \"../common/ExtractFunctionSignature.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/linkedlists/IntegerSortedLinkedList.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/UsingPrecompiles.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\n/**\n * @title A contract for making, passing, and executing on-chain governance proposals.\n */\ncontract Governance is\n  IGovernance,\n  ICeloVersionedContract,\n  Ownable,\n  Initializable,\n  ReentrancyGuard,\n  UsingRegistry,\n  UsingPrecompiles\n{\n  using Proposals for Proposals.Proposal;\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n  using IntegerSortedLinkedList for SortedLinkedList.List;\n  using BytesLib for bytes;\n  using Address for address payable; // prettier-ignore\n\n  uint256 private constant FIXED_HALF = 500000000000000000000000;\n\n  enum VoteValue { None, Abstain, No, Yes }\n\n  struct UpvoteRecord {\n    uint256 proposalId;\n    uint256 weight;\n  }\n\n  struct VoteRecord {\n    Proposals.VoteValue deprecated_value; // obsolete\n    uint256 proposalId;\n    uint256 deprecated_weight; // obsolete\n    uint256 yesVotes;\n    uint256 noVotes;\n    uint256 abstainVotes;\n  }\n\n  struct Voter {\n    // Key of the proposal voted for in the proposal queue\n    UpvoteRecord upvote;\n    uint256 mostRecentReferendumProposal;\n    // Maps a `dequeued` index to a voter's vote record.\n    mapping(uint256 => VoteRecord) referendumVotes;\n  }\n\n  struct ContractConstitution {\n    FixidityLib.Fraction defaultThreshold;\n    // Maps a function ID to a corresponding threshold, overriding the default.\n    mapping(bytes4 => FixidityLib.Fraction) functionThresholds;\n  }\n\n  struct HotfixRecord {\n    bool executed;\n    bool approved;\n    uint256 preparedEpoch;\n    mapping(address => bool) whitelisted;\n  }\n\n  // The baseline is updated as\n  // max{floor, (1 - baselineUpdateFactor) * baseline + baselineUpdateFactor * participation}\n  struct ParticipationParameters {\n    // The average network participation in governance, weighted toward recent proposals.\n    FixidityLib.Fraction baseline;\n    // The lower bound on the participation baseline.\n    FixidityLib.Fraction baselineFloor;\n    // The weight of the most recent proposal's participation on the baseline.\n    FixidityLib.Fraction baselineUpdateFactor;\n    // The proportion of the baseline that constitutes quorum.\n    FixidityLib.Fraction baselineQuorumFactor;\n  }\n\n  Proposals.StageDurations public stageDurations;\n  uint256 public queueExpiry;\n  uint256 public dequeueFrequency;\n  address public approver;\n  uint256 public lastDequeue;\n  uint256 public concurrentProposals;\n  uint256 public proposalCount;\n  uint256 public minDeposit;\n  mapping(address => uint256) public refundedDeposits;\n  mapping(address => ContractConstitution) private constitution;\n  mapping(uint256 => Proposals.Proposal) private proposals;\n  mapping(address => Voter) internal voters;\n  mapping(bytes32 => HotfixRecord) public hotfixes;\n  SortedLinkedList.List private queue;\n  uint256[] public dequeued;\n  uint256[] public emptyIndices;\n  ParticipationParameters private participationParameters;\n\n  event ApproverSet(address indexed approver);\n\n  event ConcurrentProposalsSet(uint256 concurrentProposals);\n\n  event MinDepositSet(uint256 minDeposit);\n\n  event QueueExpirySet(uint256 queueExpiry);\n\n  event DequeueFrequencySet(uint256 dequeueFrequency);\n\n  event ReferendumStageDurationSet(uint256 referendumStageDuration);\n\n  event ExecutionStageDurationSet(uint256 executionStageDuration);\n\n  event ConstitutionSet(address indexed destination, bytes4 indexed functionId, uint256 threshold);\n\n  event ProposalQueued(\n    uint256 indexed proposalId,\n    address indexed proposer,\n    uint256 transactionCount,\n    uint256 deposit,\n    uint256 timestamp\n  );\n\n  event ProposalUpvoted(uint256 indexed proposalId, address indexed account, uint256 upvotes);\n\n  event ProposalUpvoteRevoked(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 revokedUpvotes\n  );\n\n  event ProposalDequeued(uint256 indexed proposalId, uint256 timestamp);\n\n  event ProposalApproved(uint256 indexed proposalId);\n\n  event ProposalVoted(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 value,\n    uint256 weight\n  );\n\n  event ProposalVotedV2(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 yesVotes,\n    uint256 noVotes,\n    uint256 abstainVotes\n  );\n\n  event ProposalVoteRevoked(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 value,\n    uint256 weight\n  );\n\n  event ProposalVoteRevokedV2(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 yesVotes,\n    uint256 noVotes,\n    uint256 abstainVotes\n  );\n\n  event ProposalExecuted(uint256 indexed proposalId);\n\n  event ProposalExpired(uint256 indexed proposalId);\n\n  event ParticipationBaselineUpdated(uint256 participationBaseline);\n\n  event ParticipationFloorSet(uint256 participationFloor);\n\n  event ParticipationBaselineUpdateFactorSet(uint256 baselineUpdateFactor);\n\n  event ParticipationBaselineQuorumFactorSet(uint256 baselineQuorumFactor);\n\n  event HotfixWhitelisted(bytes32 indexed hash, address whitelister);\n\n  event HotfixApproved(bytes32 indexed hash);\n\n  event HotfixPrepared(bytes32 indexed hash, uint256 indexed epoch);\n\n  event HotfixExecuted(bytes32 indexed hash);\n\n  modifier hotfixNotExecuted(bytes32 hash) {\n    require(!hotfixes[hash].executed, \"hotfix already executed\");\n    _;\n  }\n\n  modifier onlyApprover() {\n    require(msg.sender == approver, \"msg.sender not approver\");\n    _;\n  }\n\n  modifier onlyLockedGold() {\n    require(msg.sender == address(getLockedGold()), \"msg.sender not lockedGold\");\n    _;\n  }\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  function() external payable {\n    require(msg.data.length == 0, \"unknown method\");\n  }\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return Storage version of the contract.\n   * @return Major version of the contract.\n   * @return Minor version of the contract.\n   * @return Patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 4, 1, 0);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry contract.\n   * @param _approver The address that needs to approve proposals to move to the referendum stage.\n   * @param _concurrentProposals The number of proposals to dequeue at once.\n   * @param _minDeposit The minimum CELO deposit needed to make a proposal.\n   * @param _queueExpiry The number of seconds a proposal can stay in the queue before expiring.\n   * @param _dequeueFrequency The number of seconds before the next batch of proposals can be\n   *   dequeued.\n   * @param referendumStageDuration The number of seconds users have to vote on a dequeued proposal\n   *   after the approval stage ends.\n   * @param executionStageDuration The number of seconds users have to execute a passed proposal\n   *   after the referendum stage ends.\n   * @param participationBaseline The initial value of the participation baseline.\n   * @param participationFloor The participation floor.\n   * @param baselineUpdateFactor The weight of the new participation in the baseline update rule.\n   * @param baselineQuorumFactor The proportion of the baseline that constitutes quorum.\n   * @dev Should be called only once.\n   */\n  function initialize(\n    address registryAddress,\n    address _approver,\n    uint256 _concurrentProposals,\n    uint256 _minDeposit,\n    uint256 _queueExpiry,\n    uint256 _dequeueFrequency,\n    uint256 referendumStageDuration,\n    uint256 executionStageDuration,\n    uint256 participationBaseline,\n    uint256 participationFloor,\n    uint256 baselineUpdateFactor,\n    uint256 baselineQuorumFactor\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setApprover(_approver);\n    setConcurrentProposals(_concurrentProposals);\n    setMinDeposit(_minDeposit);\n    setQueueExpiry(_queueExpiry);\n    setDequeueFrequency(_dequeueFrequency);\n    setReferendumStageDuration(referendumStageDuration);\n    setExecutionStageDuration(executionStageDuration);\n    setParticipationBaseline(participationBaseline);\n    setParticipationFloor(participationFloor);\n    setBaselineUpdateFactor(baselineUpdateFactor);\n    setBaselineQuorumFactor(baselineQuorumFactor);\n    // solhint-disable-next-line not-rely-on-time\n    lastDequeue = now;\n  }\n\n  /**\n   * @notice Updates the address that has permission to approve proposals in the approval stage.\n   * @param _approver The address that has permission to approve proposals in the approval stage.\n   */\n  function setApprover(address _approver) public onlyOwner {\n    require(_approver != address(0), \"Approver cannot be 0\");\n    require(_approver != approver, \"Approver unchanged\");\n    approver = _approver;\n    emit ApproverSet(_approver);\n  }\n\n  /**\n   * @notice Updates the number of proposals to dequeue at a time.\n   * @param _concurrentProposals The number of proposals to dequeue at at a time.\n   */\n  function setConcurrentProposals(uint256 _concurrentProposals) public onlyOwner {\n    require(_concurrentProposals != 0, \"Number of proposals must be larger than zero\");\n    require(_concurrentProposals != concurrentProposals, \"Number of proposals unchanged\");\n    concurrentProposals = _concurrentProposals;\n    emit ConcurrentProposalsSet(_concurrentProposals);\n  }\n\n  /**\n   * @notice Updates the minimum deposit needed to make a proposal.\n   * @param _minDeposit The minimum CELO deposit needed to make a proposal.\n   */\n  function setMinDeposit(uint256 _minDeposit) public onlyOwner {\n    require(_minDeposit != 0, \"minDeposit must be larger than 0\");\n    require(_minDeposit != minDeposit, \"Minimum deposit unchanged\");\n    minDeposit = _minDeposit;\n    emit MinDepositSet(_minDeposit);\n  }\n\n  /**\n   * @notice Updates the number of seconds before a queued proposal expires.\n   * @param _queueExpiry The number of seconds a proposal can stay in the queue before expiring.\n   */\n  function setQueueExpiry(uint256 _queueExpiry) public onlyOwner {\n    require(_queueExpiry != 0, \"QueueExpiry must be larger than 0\");\n    require(_queueExpiry != queueExpiry, \"QueueExpiry unchanged\");\n    queueExpiry = _queueExpiry;\n    emit QueueExpirySet(_queueExpiry);\n  }\n\n  /**\n   * @notice Updates the minimum number of seconds before the next batch of proposals can be\n   *   dequeued.\n   * @param _dequeueFrequency The number of seconds before the next batch of proposals can be\n   *   dequeued.\n   */\n  function setDequeueFrequency(uint256 _dequeueFrequency) public onlyOwner {\n    require(_dequeueFrequency != 0, \"dequeueFrequency must be larger than 0\");\n    require(_dequeueFrequency != dequeueFrequency, \"dequeueFrequency unchanged\");\n    dequeueFrequency = _dequeueFrequency;\n    emit DequeueFrequencySet(_dequeueFrequency);\n  }\n\n  /**\n   * @notice Updates the number of seconds proposals stay in the referendum stage.\n   * @param referendumStageDuration The number of seconds proposals stay in the referendum stage.\n   */\n  function setReferendumStageDuration(uint256 referendumStageDuration) public onlyOwner {\n    require(referendumStageDuration != 0, \"Duration must be larger than 0\");\n    require(referendumStageDuration != stageDurations.referendum, \"Duration unchanged\");\n    stageDurations.referendum = referendumStageDuration;\n    emit ReferendumStageDurationSet(referendumStageDuration);\n  }\n\n  /**\n   * @notice Updates the number of seconds proposals stay in the execution stage.\n   * @param executionStageDuration The number of seconds proposals stay in the execution stage.\n   */\n  function setExecutionStageDuration(uint256 executionStageDuration) public onlyOwner {\n    require(executionStageDuration != 0, \"Duration must be larger than 0\");\n    require(executionStageDuration != stageDurations.execution, \"Duration unchanged\");\n    stageDurations.execution = executionStageDuration;\n    emit ExecutionStageDurationSet(executionStageDuration);\n  }\n\n  /**\n   * @notice Updates the participation baseline.\n   * @param participationBaseline The value of the baseline.\n   */\n  function setParticipationBaseline(uint256 participationBaseline) public onlyOwner {\n    FixidityLib.Fraction memory participationBaselineFrac = FixidityLib.wrap(participationBaseline);\n    require(\n      FixidityLib.isProperFraction(participationBaselineFrac),\n      \"Participation baseline greater than one\"\n    );\n    require(\n      !participationBaselineFrac.equals(participationParameters.baseline),\n      \"Participation baseline unchanged\"\n    );\n    participationParameters.baseline = participationBaselineFrac;\n    emit ParticipationBaselineUpdated(participationBaseline);\n  }\n\n  /**\n   * @notice Updates the floor of the participation baseline.\n   * @param participationFloor The value at which the baseline is floored.\n   */\n  function setParticipationFloor(uint256 participationFloor) public onlyOwner {\n    FixidityLib.Fraction memory participationFloorFrac = FixidityLib.wrap(participationFloor);\n    require(\n      FixidityLib.isProperFraction(participationFloorFrac),\n      \"Participation floor greater than one\"\n    );\n    require(\n      !participationFloorFrac.equals(participationParameters.baselineFloor),\n      \"Participation baseline floor unchanged\"\n    );\n    participationParameters.baselineFloor = participationFloorFrac;\n    emit ParticipationFloorSet(participationFloor);\n  }\n\n  /**\n   * @notice Updates the weight of the new participation in the baseline update rule.\n   * @param baselineUpdateFactor The new baseline update factor.\n   */\n  function setBaselineUpdateFactor(uint256 baselineUpdateFactor) public onlyOwner {\n    FixidityLib.Fraction memory baselineUpdateFactorFrac = FixidityLib.wrap(baselineUpdateFactor);\n    require(\n      FixidityLib.isProperFraction(baselineUpdateFactorFrac),\n      \"Baseline update factor greater than one\"\n    );\n    require(\n      !baselineUpdateFactorFrac.equals(participationParameters.baselineUpdateFactor),\n      \"Baseline update factor unchanged\"\n    );\n    participationParameters.baselineUpdateFactor = baselineUpdateFactorFrac;\n    emit ParticipationBaselineUpdateFactorSet(baselineUpdateFactor);\n  }\n\n  /**\n   * @notice Updates the proportion of the baseline that constitutes quorum.\n   * @param baselineQuorumFactor The new baseline quorum factor.\n   */\n  function setBaselineQuorumFactor(uint256 baselineQuorumFactor) public onlyOwner {\n    FixidityLib.Fraction memory baselineQuorumFactorFrac = FixidityLib.wrap(baselineQuorumFactor);\n    require(\n      FixidityLib.isProperFraction(baselineQuorumFactorFrac),\n      \"Baseline quorum factor greater than one\"\n    );\n    require(\n      !baselineQuorumFactorFrac.equals(participationParameters.baselineQuorumFactor),\n      \"Baseline quorum factor unchanged\"\n    );\n    participationParameters.baselineQuorumFactor = baselineQuorumFactorFrac;\n    emit ParticipationBaselineQuorumFactorSet(baselineQuorumFactor);\n  }\n\n  /**\n   * @notice Updates the ratio of yes:yes+no votes needed for a specific class of proposals to pass.\n   * @param destination The destination of proposals for which this threshold should apply.\n   * @param functionId The function ID of proposals for which this threshold should apply. Zero\n   *   will set the default.\n   * @param threshold The threshold.\n   * @dev If no constitution is explicitly set the default is a simple majority, i.e. 1:2.\n   */\n  function setConstitution(address destination, bytes4 functionId, uint256 threshold)\n    external\n    onlyOwner\n  {\n    require(destination != address(0), \"Destination cannot be zero\");\n    require(\n      threshold > FIXED_HALF && threshold <= FixidityLib.fixed1().unwrap(),\n      \"Threshold has to be greater than majority and not greater than unanimity\"\n    );\n    if (functionId == 0) {\n      constitution[destination].defaultThreshold = FixidityLib.wrap(threshold);\n    } else {\n      constitution[destination].functionThresholds[functionId] = FixidityLib.wrap(threshold);\n    }\n    emit ConstitutionSet(destination, functionId, threshold);\n  }\n\n  /**\n   * @notice Creates a new proposal and adds it to end of the queue with no upvotes.\n   * @param values The values of CELO to be sent in the proposed transactions.\n   * @param destinations The destination addresses of the proposed transactions.\n   * @param data The concatenated data to be included in the proposed transactions.\n   * @param dataLengths The lengths of each transaction's data.\n   * @return The ID of the newly proposed proposal.\n   * @dev The minimum deposit must be included with the proposal, returned if/when the proposal is\n   *   dequeued.\n   */\n  function propose(\n    uint256[] calldata values,\n    address[] calldata destinations,\n    bytes calldata data,\n    uint256[] calldata dataLengths,\n    string calldata descriptionUrl\n  ) external payable returns (uint256) {\n    dequeueProposalsIfReady();\n    require(msg.value >= minDeposit, \"Too small deposit\");\n\n    proposalCount = proposalCount.add(1);\n    Proposals.Proposal storage proposal = proposals[proposalCount];\n    proposal.make(values, destinations, data, dataLengths, msg.sender, msg.value);\n    proposal.setDescriptionUrl(descriptionUrl);\n    queue.push(proposalCount);\n    // solhint-disable-next-line not-rely-on-time\n    emit ProposalQueued(proposalCount, msg.sender, proposal.transactions.length, msg.value, now);\n    return proposalCount;\n  }\n\n  /**\n   * @notice Removes a proposal if it is queued and expired.\n   * @param proposalId The ID of the proposal to remove.\n   * @return Whether the proposal was removed.\n   */\n  function removeIfQueuedAndExpired(uint256 proposalId) private returns (bool) {\n    if (isQueued(proposalId) && isQueuedProposalExpired(proposalId)) {\n      queue.remove(proposalId);\n      emit ProposalExpired(proposalId);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @notice Requires a proposal is dequeued and removes it if expired.\n   * @param proposalId The ID of the proposal.\n   * @return The proposal storage struct corresponding to `proposalId`.\n   * @return The proposal stage corresponding to `proposalId`.\n   */\n  function requireDequeuedAndDeleteExpired(uint256 proposalId, uint256 index)\n    private\n    returns (Proposals.Proposal storage, Proposals.Stage)\n  {\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    require(_isDequeuedProposal(proposal, proposalId, index), \"Proposal not dequeued\");\n    Proposals.Stage stage = getProposalDequeuedStage(proposal);\n    if (_isDequeuedProposalExpired(proposal, stage)) {\n      deleteDequeuedProposal(proposal, proposalId, index);\n      return (proposal, Proposals.Stage.Expiration);\n    }\n    return (proposal, stage);\n  }\n\n  /**\n   * @notice Upvotes a queued proposal.\n   * @param proposalId The ID of the proposal to upvote.\n   * @param lesser The ID of the proposal that will be just behind `proposalId` in the queue.\n   * @param greater The ID of the proposal that will be just ahead `proposalId` in the queue.\n   * @return Whether or not the upvote was made successfully.\n   * @dev Provide 0 for `lesser`/`greater` when the proposal will be at the tail/head of the queue.\n   * @dev Reverts if the account has already upvoted a proposal in the queue.\n   */\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n  /**\n   * @notice Returns stage of governance process given proposal is in\n   * @param proposalId The ID of the proposal to query.\n   * @return proposal stage\n   */\n  function getProposalStage(uint256 proposalId) external view returns (Proposals.Stage) {\n    if (proposalId == 0 || proposalId > proposalCount) {\n      return Proposals.Stage.None;\n    }\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    if (isQueued(proposalId)) {\n      return\n        _isQueuedProposalExpired(proposal) ? Proposals.Stage.Expiration : Proposals.Stage.Queued;\n    } else {\n      Proposals.Stage stage = getProposalDequeuedStage(proposal);\n      return _isDequeuedProposalExpired(proposal, stage) ? Proposals.Stage.Expiration : stage;\n    }\n  }\n\n  /**\n   * @notice Revokes an upvote on a queued proposal.\n   * @param lesser The ID of the proposal that will be just behind the previously upvoted proposal\n   *   in the queue.\n   * @param greater The ID of the proposal that will be just ahead of the previously upvoted\n   *   proposal in the queue.\n   * @return Whether or not the upvote was revoked successfully.\n   * @dev Provide 0 for `lesser`/`greater` when the proposal will be at the tail/head of the queue.\n   */\n  function revokeUpvote(uint256 lesser, uint256 greater) external nonReentrant returns (bool) {\n    dequeueProposalsIfReady();\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    uint256 proposalId = voter.upvote.proposalId;\n    require(proposalId != 0, \"Account has no historical upvote\");\n    removeIfQueuedAndExpired(proposalId);\n    if (queue.contains(proposalId)) {\n      queue.update(\n        proposalId,\n        queue.getValue(proposalId).sub(voter.upvote.weight),\n        lesser,\n        greater\n      );\n      emit ProposalUpvoteRevoked(proposalId, account, voter.upvote.weight);\n    }\n    voter.upvote = UpvoteRecord(0, 0);\n    return true;\n  }\n\n  /**\n   * @notice Approves a proposal in the approval stage.\n   * @param proposalId The ID of the proposal to approve.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @return Whether or not the approval was made successfully.\n   */\n  function approve(uint256 proposalId, uint256 index) external onlyApprover returns (bool) {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(!proposal.isApproved(), \"Proposal already approved\");\n    require(\n      stage == Proposals.Stage.Referendum || stage == Proposals.Stage.Execution,\n      \"Proposal not in correct stage\"\n    );\n    proposal.approved = true;\n    // Ensures networkWeight is set by the end of the Referendum stage, even if 0 votes are cast.\n    proposal.networkWeight = getLockedGold().getTotalLockedGold();\n    emit ProposalApproved(proposalId);\n    return true;\n  }\n\n  /**\n   * @notice Votes on a proposal in the referendum stage.\n   * @param proposalId The ID of the proposal to vote on.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @param value Whether to vote yes, no, or abstain.\n   * @return Whether or not the vote was cast successfully.\n   */\n  /* solhint-disable code-complexity */\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n\n  /**\n   * @notice Votes partially on a proposal in the referendum stage.\n   * @param proposalId The ID of the proposal to vote on.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @param yesVotes The yes votes weight.\n   * @param noVotes The no votes weight.\n   * @param abstainVotes The abstain votes weight.\n   * @return Whether or not the vote was cast successfully.\n   */\n  /* solhint-disable code-complexity */\n  function votePartially(\n    uint256 proposalId,\n    uint256 index,\n    uint256 yesVotes,\n    uint256 noVotes,\n    uint256 abstainVotes\n  ) external nonReentrant returns (bool) {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 totalVotingPower = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n\n    require(\n      totalVotingPower >= yesVotes.add(noVotes).add(abstainVotes),\n      \"Voter doesn't have enough locked Celo (formerly known as Celo Gold)\"\n    );\n    _vote(proposal, proposalId, index, account, yesVotes, noVotes, abstainVotes);\n\n    return true;\n  }\n\n  /**\n   * @notice Votes on a proposal in the referendum stage.\n   * @param proposal The proposal struct.\n   * @param proposalId The ID of the proposal to vote on.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @param account Account based on signer.\n   * @param yesVotes The yes votes weight.\n   * @param noVotes The no votes weight.\n   * @param abstainVotes The abstain votes weight.\n   * @return Whether or not the proposal is passing.\n   */\n  function _vote(\n    Proposals.Proposal storage proposal,\n    uint256 proposalId,\n    uint256 index,\n    address account,\n    uint256 yesVotes,\n    uint256 noVotes,\n    uint256 abstainVotes\n  ) private {\n    Voter storage voter = voters[account];\n\n    VoteRecord storage previousVoteRecord = voter.referendumVotes[index];\n\n    if (previousVoteRecord.proposalId != proposalId) {\n      // VoteRecord is being stored based on index (in `dequeued`) rather than proposalId.\n      // It can happen that user voted on proposal that later gets deleted.\n      // VoteRecord will still stay in `referendumVotes` mapping.\n      // Once new proposal is created it might get same index as previous proposal.\n      // In such case we need to check whether existing VoteRecord is relevant to new\n      // proposal of whether it is just left over data.\n      proposal.updateVote(0, 0, 0, yesVotes, noVotes, abstainVotes);\n    } else if (previousVoteRecord.deprecated_weight != 0) {\n      // backward compatibility for transition period - this should be deleted later on\n      proposal.updateVote(\n        previousVoteRecord.deprecated_value == Proposals.VoteValue.Yes\n          ? previousVoteRecord.deprecated_weight\n          : 0,\n        previousVoteRecord.deprecated_value == Proposals.VoteValue.No\n          ? previousVoteRecord.deprecated_weight\n          : 0,\n        previousVoteRecord.deprecated_value == Proposals.VoteValue.Abstain\n          ? previousVoteRecord.deprecated_weight\n          : 0,\n        yesVotes,\n        noVotes,\n        abstainVotes\n      );\n    } else {\n      proposal.updateVote(\n        previousVoteRecord.yesVotes,\n        previousVoteRecord.noVotes,\n        previousVoteRecord.abstainVotes,\n        yesVotes,\n        noVotes,\n        abstainVotes\n      );\n    }\n\n    proposal.networkWeight = getLockedGold().getTotalLockedGold();\n    voter.referendumVotes[index] = VoteRecord(\n      Proposals.VoteValue.None,\n      proposalId,\n      0,\n      yesVotes,\n      noVotes,\n      abstainVotes\n    );\n    if (proposal.timestamp > proposals[voter.mostRecentReferendumProposal].timestamp) {\n      voter.mostRecentReferendumProposal = proposalId;\n    }\n\n    emit ProposalVotedV2(proposalId, account, yesVotes, noVotes, abstainVotes);\n  }\n\n  /* solhint-enable code-complexity */\n\n  /**\n   * @notice Revoke votes on all proposals of sender in the referendum stage.\n   * @return Whether or not all votes of an account were successfully revoked.\n   */\n  function revokeVotes() external nonReentrant returns (bool) {\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    for (\n      uint256 dequeueIndex = 0;\n      dequeueIndex < dequeued.length;\n      dequeueIndex = dequeueIndex.add(1)\n    ) {\n      VoteRecord storage voteRecord = voter.referendumVotes[dequeueIndex];\n\n      // Skip proposals where there was no vote cast by the user AND\n      // ensure vote record proposal matches identifier of dequeued index proposal.\n      if (\n        voteRecord.proposalId == dequeued[dequeueIndex] &&\n        (voteRecord.yesVotes != 0 ||\n          voteRecord.noVotes != 0 ||\n          voteRecord.abstainVotes != 0 ||\n          voteRecord.deprecated_weight != 0)\n      ) {\n        (Proposals.Proposal storage proposal, Proposals.Stage stage) =\n          requireDequeuedAndDeleteExpired(voteRecord.proposalId, dequeueIndex); // prettier-ignore\n\n        // only revoke from proposals which are still in referendum\n        if (stage == Proposals.Stage.Referendum) {\n          if (voteRecord.deprecated_weight != 0) {\n            // backward compatibility for transition period - this should be deleted later on\n            uint256 previousYes = voteRecord.deprecated_value == Proposals.VoteValue.Yes\n              ? voteRecord.deprecated_weight\n              : 0;\n            uint256 previousNo = voteRecord.deprecated_value == Proposals.VoteValue.No\n              ? voteRecord.deprecated_weight\n              : 0;\n            uint256 previousAbstain = voteRecord.deprecated_value == Proposals.VoteValue.Abstain\n              ? voteRecord.deprecated_weight\n              : 0;\n            proposal.updateVote(previousYes, previousNo, previousAbstain, 0, 0, 0);\n\n            proposal.networkWeight = getLockedGold().getTotalLockedGold();\n            emit ProposalVoteRevokedV2(\n              voteRecord.proposalId,\n              account,\n              previousYes,\n              previousNo,\n              previousAbstain\n            );\n          } else {\n            proposal.updateVote(\n              voteRecord.yesVotes,\n              voteRecord.noVotes,\n              voteRecord.abstainVotes,\n              0,\n              0,\n              0\n            );\n            proposal.networkWeight = getLockedGold().getTotalLockedGold();\n            emit ProposalVoteRevokedV2(\n              voteRecord.proposalId,\n              account,\n              voteRecord.yesVotes,\n              voteRecord.noVotes,\n              voteRecord.abstainVotes\n            );\n          }\n        }\n\n        // always delete dequeue vote records for gas refund as they must be expired or revoked\n        delete voter.referendumVotes[dequeueIndex];\n      }\n    }\n\n    // reset most recent referendum proposal ID to guarantee isVotingReferendum == false\n    voter.mostRecentReferendumProposal = 0;\n    return true;\n  }\n\n  /**\n   * @notice Executes a proposal in the execution stage, removing it from `dequeued`.\n   * @param proposalId The ID of the proposal to vote on.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @return Whether or not the proposal was executed successfully.\n   * @dev Does not remove the proposal if the execution fails.\n   */\n  function execute(uint256 proposalId, uint256 index) external nonReentrant returns (bool) {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    bool notExpired = proposal.exists();\n    if (notExpired) {\n      require(proposal.isApproved(), \"Proposal not approved\");\n      require(\n        stage == Proposals.Stage.Execution && _isProposalPassing(proposal),\n        \"Proposal not in execution stage or not passing\"\n      );\n      proposal.execute();\n      emit ProposalExecuted(proposalId);\n      deleteDequeuedProposal(proposal, proposalId, index);\n    }\n    return notExpired;\n  }\n\n  /**\n   * @notice Approves the hash of a hotfix transaction(s).\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction(s) to be approved.\n   */\n  function approveHotfix(bytes32 hash) external hotfixNotExecuted(hash) onlyApprover {\n    hotfixes[hash].approved = true;\n    emit HotfixApproved(hash);\n  }\n\n  /**\n   * @notice Returns whether given hotfix hash has been whitelisted by given address.\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction(s) to be whitelisted.\n   * @param whitelister Address to check whitelist status of.\n   */\n  function isHotfixWhitelistedBy(bytes32 hash, address whitelister) public view returns (bool) {\n    return hotfixes[hash].whitelisted[whitelister];\n  }\n\n  /**\n   * @notice Whitelists the hash of a hotfix transaction(s).\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction(s) to be whitelisted.\n   */\n  function whitelistHotfix(bytes32 hash) external hotfixNotExecuted(hash) {\n    hotfixes[hash].whitelisted[msg.sender] = true;\n    emit HotfixWhitelisted(hash, msg.sender);\n  }\n\n  /**\n   * @notice Gives hotfix a prepared epoch for execution.\n   * @param hash The hash of the hotfix to be prepared.\n   */\n  function prepareHotfix(bytes32 hash) external hotfixNotExecuted(hash) {\n    require(isHotfixPassing(hash), \"hotfix not whitelisted by 2f+1 validators\");\n    uint256 epoch = getEpochNumber();\n    require(hotfixes[hash].preparedEpoch < epoch, \"hotfix already prepared for this epoch\");\n    hotfixes[hash].preparedEpoch = epoch;\n    emit HotfixPrepared(hash, epoch);\n  }\n\n  /**\n   * @notice Executes a whitelisted proposal.\n   * @param values The values of CELO to be sent in the proposed transactions.\n   * @param destinations The destination addresses of the proposed transactions.\n   * @param data The concatenated data to be included in the proposed transactions.\n   * @param dataLengths The lengths of each transaction's data.\n   * @param salt Arbitrary salt associated with hotfix which guarantees uniqueness of hash.\n   * @dev Reverts if hotfix is already executed, not approved, or not prepared for current epoch.\n   */\n  function executeHotfix(\n    uint256[] calldata values,\n    address[] calldata destinations,\n    bytes calldata data,\n    uint256[] calldata dataLengths,\n    bytes32 salt\n  ) external {\n    bytes32 hash = keccak256(abi.encode(values, destinations, data, dataLengths, salt));\n\n    (bool approved, bool executed, uint256 preparedEpoch) = getHotfixRecord(hash);\n    require(!executed, \"hotfix already executed\");\n    require(approved, \"hotfix not approved\");\n    require(preparedEpoch == getEpochNumber(), \"hotfix must be prepared for this epoch\");\n\n    Proposals.makeMem(values, destinations, data, dataLengths, msg.sender, 0).executeMem();\n\n    hotfixes[hash].executed = true;\n    emit HotfixExecuted(hash);\n  }\n\n  /**\n   * @notice Withdraws refunded CELO deposits.\n   * @return Whether or not the withdraw was successful.\n   */\n  function withdraw() external nonReentrant returns (bool) {\n    uint256 value = refundedDeposits[msg.sender];\n    require(value != 0, \"Nothing to withdraw\");\n    require(value <= address(this).balance, \"Inconsistent balance\");\n    refundedDeposits[msg.sender] = 0;\n    msg.sender.sendValue(value);\n    return true;\n  }\n\n  /**\n   * @notice Returns whether or not a particular account is voting on proposals.\n   * @param account The address of the account.\n   * @return Whether or not the account is voting on proposals.\n   */\n  function isVoting(address account) external view returns (bool) {\n    Voter storage voter = voters[account];\n    uint256 upvotedProposal = voter.upvote.proposalId;\n    bool isVotingQueue = upvotedProposal != 0 &&\n      isQueued(upvotedProposal) &&\n      !isQueuedProposalExpired(upvotedProposal);\n    Proposals.Proposal storage proposal = proposals[voter.mostRecentReferendumProposal];\n    bool isVotingReferendum = (getProposalDequeuedStage(proposal) == Proposals.Stage.Referendum);\n    return isVotingQueue || isVotingReferendum;\n  }\n\n  /**\n   * @notice Returns the number of seconds proposals stay in the referendum stage.\n   * @return The number of seconds proposals stay in the referendum stage.\n   */\n  function getReferendumStageDuration() external view returns (uint256) {\n    return stageDurations.referendum;\n  }\n\n  /**\n   * @notice Returns the number of seconds proposals stay in the execution stage.\n   * @return The number of seconds proposals stay in the execution stage.\n   */\n  function getExecutionStageDuration() external view returns (uint256) {\n    return stageDurations.execution;\n  }\n\n  /**\n   * @notice Returns the participation parameters.\n   * @return baseline The participation baseline parameter.\n   * @return baselineFloor The participation baseline floor parameter.\n   * @return baselineUpdateFactor The participation baseline update factor parameter.\n   * @return baselineQuorumFactor The participation baseline quorum factor parameter.\n   */\n  function getParticipationParameters() external view returns (uint256, uint256, uint256, uint256) {\n    return (\n      participationParameters.baseline.unwrap(),\n      participationParameters.baselineFloor.unwrap(),\n      participationParameters.baselineUpdateFactor.unwrap(),\n      participationParameters.baselineQuorumFactor.unwrap()\n    );\n  }\n\n  /**\n   * @notice Returns whether or not a proposal exists.\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the proposal exists.\n   */\n  function proposalExists(uint256 proposalId) external view returns (bool) {\n    return proposals[proposalId].exists();\n  }\n\n  /**\n   * @notice Returns an unpacked proposal struct with its transaction count.\n   * @param proposalId The ID of the proposal to unpack.\n   * @return proposer\n   * @return deposit\n   * @return timestamp\n   * @return transaction Transaction count.\n   * @return description Description url.\n   */\n  function getProposal(uint256 proposalId)\n    external\n    view\n    returns (address, uint256, uint256, uint256, string memory, uint256, bool)\n  {\n    return proposals[proposalId].unpack();\n  }\n\n  /**\n   * @notice Returns a specified transaction in a proposal.\n   * @param proposalId The ID of the proposal to query.\n   * @param index The index of the specified transaction in the proposal's transaction list.\n   * @return value Transaction value.\n   * @return destination Transaction destination.\n   * @return data Transaction data.\n   */\n  function getProposalTransaction(uint256 proposalId, uint256 index)\n    external\n    view\n    returns (uint256, address, bytes memory)\n  {\n    return proposals[proposalId].getTransaction(index);\n  }\n\n  /**\n   * @notice Returns whether or not a proposal has been approved.\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the proposal has been approved.\n   */\n  function isApproved(uint256 proposalId) external view returns (bool) {\n    return proposals[proposalId].isApproved();\n  }\n\n  /**\n   * @notice Returns the referendum vote totals for a proposal.\n   * @param proposalId The ID of the proposal.\n   * @return yes The yes vote totals.\n   * @return no The no vote totals.\n   * @return abstain The abstain vote totals.\n   */\n  function getVoteTotals(uint256 proposalId) external view returns (uint256, uint256, uint256) {\n    return proposals[proposalId].getVoteTotals();\n  }\n\n  /**\n   * @notice Returns an accounts vote record on a particular index in `dequeued`.\n   * @param account The address of the account to get the record for.\n   * @param index The index in `dequeued`.\n   * @return The corresponding proposal ID, vote value, and weight.\n   * @return The depreciated vote value.\n   * @return The deprecieated weight.\n   * @return The yes weight.\n   * @return The no weight.\n   * @return The abstain weight.\n   */\n  function getVoteRecord(address account, uint256 index)\n    external\n    view\n    returns (uint256, uint256, uint256, uint256, uint256, uint256)\n  {\n    VoteRecord storage record = voters[account].referendumVotes[index];\n    return (\n      record.proposalId,\n      uint256(record.deprecated_value),\n      record.deprecated_weight,\n      record.yesVotes,\n      record.noVotes,\n      record.abstainVotes\n    );\n  }\n\n  /**\n   * @notice Returns the number of proposals in the queue.\n   * @return The number of proposals in the queue.\n   */\n  function getQueueLength() external view returns (uint256) {\n    return queue.list.numElements;\n  }\n\n  /**\n   * @notice Returns the number of upvotes the queued proposal has received.\n   * @param proposalId The ID of the proposal.\n   * @return The number of upvotes a queued proposal has received.\n   */\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n  /**\n   * @notice Returns the proposal ID and upvote total for all queued proposals.\n   * @return proposalID The proposal ID for all queued proposals.\n   * @return total The upvote total for all queued proposals.\n   * @dev Note that this includes expired proposals that have yet to be removed from the queue.\n   */\n  function getQueue() external view returns (uint256[] memory, uint256[] memory) {\n    return queue.getElements();\n  }\n\n  /**\n   * @notice Returns the dequeued proposal IDs.\n   * @return The dequeued proposal IDs.\n   * @dev Note that this includes unused indices with proposalId == 0 from deleted proposals.\n   */\n  function getDequeue() external view returns (uint256[] memory) {\n    return dequeued;\n  }\n\n  /**\n   * @notice Returns the ID of the proposal upvoted by `account` and the weight of that upvote.\n   * @param account The address of the account.\n   * @return The ID of the proposal upvoted by `account`.\n   * @return The weight of that upvote.\n   */\n  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n  /**\n   * @notice Returns the ID of the most recently dequeued proposal voted on by `account`.\n   * @param account The address of the account.\n   * @return The ID of the most recently dequeued proposal voted on by `account`..\n   */\n  function getMostRecentReferendumProposal(address account) external view returns (uint256) {\n    return voters[account].mostRecentReferendumProposal;\n  }\n\n  /**\n   * @notice Returns number of validators from current set which have whitelisted the given hotfix.\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction.\n   * @return Whitelist tally\n   */\n  function hotfixWhitelistValidatorTally(bytes32 hash) public view returns (uint256) {\n    uint256 tally = 0;\n    uint256 n = numberValidatorsInCurrentSet();\n    IAccounts accounts = getAccounts();\n    for (uint256 i = 0; i < n; i = i.add(1)) {\n      address validatorSigner = validatorSignerAddressFromCurrentSet(i);\n      address validatorAccount = accounts.signerToAccount(validatorSigner);\n      if (\n        isHotfixWhitelistedBy(hash, validatorSigner) ||\n        isHotfixWhitelistedBy(hash, validatorAccount)\n      ) {\n        tally = tally.add(1);\n      }\n    }\n    return tally;\n  }\n\n  /**\n   * @notice Checks if a byzantine quorum of validators has whitelisted the given hotfix.\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction.\n   * @return Whether validator whitelist tally >= validator byzantine quorum\n   */\n  function isHotfixPassing(bytes32 hash) public view returns (bool) {\n    return hotfixWhitelistValidatorTally(hash) >= minQuorumSizeInCurrentSet();\n  }\n\n  /**\n   * @notice Gets information about a hotfix.\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction.\n   * @return Hotfix approved.\n   * @return Hotfix executed.\n   * @return Hotfix preparedEpoch.\n   */\n  function getHotfixRecord(bytes32 hash) public view returns (bool, bool, uint256) {\n    return (hotfixes[hash].approved, hotfixes[hash].executed, hotfixes[hash].preparedEpoch);\n  }\n\n  /**\n   * @notice Removes the proposals with the most upvotes from the queue, moving them to the\n   *   approval stage.\n   * @dev If any of the top proposals have expired, they are deleted.\n   */\n  function dequeueProposalsIfReady() public {\n    // solhint-disable-next-line not-rely-on-time\n    if (now >= lastDequeue.add(dequeueFrequency)) {\n      uint256 numProposalsToDequeue = Math.min(concurrentProposals, queue.list.numElements);\n      uint256[] memory dequeuedIds = queue.popN(numProposalsToDequeue);\n\n      bool wasAnyProposalDequeued = false;\n      for (uint256 i = 0; i < numProposalsToDequeue; i = i.add(1)) {\n        uint256 proposalId = dequeuedIds[i];\n        Proposals.Proposal storage proposal = proposals[proposalId];\n        if (_isQueuedProposalExpired(proposal)) {\n          emit ProposalExpired(proposalId);\n          continue;\n        }\n        refundedDeposits[proposal.proposer] = refundedDeposits[proposal.proposer].add(\n          proposal.deposit\n        );\n        // solhint-disable-next-line not-rely-on-time\n        proposal.timestamp = now;\n        if (emptyIndices.length != 0) {\n          uint256 indexOfLastEmptyIndex = emptyIndices.length.sub(1);\n          dequeued[emptyIndices[indexOfLastEmptyIndex]] = proposalId;\n          delete emptyIndices[indexOfLastEmptyIndex];\n          emptyIndices.length = indexOfLastEmptyIndex;\n        } else {\n          dequeued.push(proposalId);\n        }\n        // solhint-disable-next-line not-rely-on-time\n        emit ProposalDequeued(proposalId, now);\n        wasAnyProposalDequeued = true;\n      }\n      if (wasAnyProposalDequeued) {\n        // solhint-disable-next-line not-rely-on-time\n        lastDequeue = now;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns whether or not a proposal is in the queue.\n   * @dev NOTE: proposal may be expired\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the proposal is in the queue.\n   */\n  function isQueued(uint256 proposalId) public view returns (bool) {\n    return queue.contains(proposalId);\n  }\n\n  /**\n   * @notice Returns whether or not a particular proposal is passing according to the constitution\n   *   and the participation levels.\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the proposal is passing.\n   */\n  function isProposalPassing(uint256 proposalId) external view returns (bool) {\n    return _isProposalPassing(proposals[proposalId]);\n  }\n\n  /**\n   * @notice Returns whether or not a particular proposal is passing according to the constitution\n   *   and the participation levels.\n   * @param proposal The proposal struct.\n   * @return Whether or not the proposal is passing.\n   */\n  function _isProposalPassing(Proposals.Proposal storage proposal) private view returns (bool) {\n    FixidityLib.Fraction memory support = proposal.getSupportWithQuorumPadding(\n      participationParameters.baseline.multiply(participationParameters.baselineQuorumFactor)\n    );\n\n    if (proposal.transactions.length == 0) {\n      // default treshold\n      FixidityLib.Fraction memory threshold = _getConstitution(address(0), \"\");\n      return support.gt(threshold);\n    }\n\n    for (uint256 i = 0; i < proposal.transactions.length; i = i.add(1)) {\n      bytes4 functionId = ExtractFunctionSignature.extractFunctionSignature(\n        proposal.transactions[i].data\n      );\n      FixidityLib.Fraction memory threshold = _getConstitution(\n        proposal.transactions[i].destination,\n        functionId\n      );\n      if (support.lte(threshold)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @notice Returns whether a proposal is dequeued at the given index.\n   * @param proposalId The ID of the proposal.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @return Whether the proposal is in `dequeued`.\n   */\n  function isDequeuedProposal(uint256 proposalId, uint256 index) external view returns (bool) {\n    return _isDequeuedProposal(proposals[proposalId], proposalId, index);\n  }\n\n  /**\n   * @notice Returns whether a proposal is dequeued at the given index.\n   * @param proposal The proposal struct.\n   * @param proposalId The ID of the proposal.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @return Whether the proposal is in `dequeued` at index.\n   */\n  function _isDequeuedProposal(\n    Proposals.Proposal storage proposal,\n    uint256 proposalId,\n    uint256 index\n  ) private view returns (bool) {\n    require(index < dequeued.length, \"Provided index greater than dequeue length.\");\n    return proposal.exists() && dequeued[index] == proposalId;\n  }\n\n  /**\n   * @notice Returns whether or not a dequeued proposal has expired.\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the dequeued proposal has expired.\n   */\n  function isDequeuedProposalExpired(uint256 proposalId) external view returns (bool) {\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    return _isDequeuedProposalExpired(proposal, getProposalDequeuedStage(proposal));\n  }\n\n  /**\n   * @notice Returns whether or not a dequeued proposal has expired.\n   * @param proposal The proposal struct.\n   * @return Whether or not the dequeued proposal has expired.\n   */\n  function _isDequeuedProposalExpired(Proposals.Proposal storage proposal, Proposals.Stage stage)\n    private\n    view\n    returns (bool)\n  {\n    // The proposal is considered expired under the following conditions:\n    //   1. Past the referendum stage and not passing.\n    //   2. Past the execution stage.\n    return ((stage > Proposals.Stage.Execution) ||\n      (stage > Proposals.Stage.Referendum && !_isProposalPassing(proposal)));\n  }\n\n  /**\n   * @notice Returns whether or not a queued proposal has expired.\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the dequeued proposal has expired.\n   */\n  function isQueuedProposalExpired(uint256 proposalId) public view returns (bool) {\n    return _isQueuedProposalExpired(proposals[proposalId]);\n  }\n\n  /**\n   * @notice Returns whether or not a queued proposal has expired.\n   * @param proposal The proposal struct.\n   * @return Whether or not the dequeued proposal has expired.\n   */\n  function _isQueuedProposalExpired(Proposals.Proposal storage proposal)\n    private\n    view\n    returns (bool)\n  {\n    // solhint-disable-next-line not-rely-on-time\n    return now >= proposal.timestamp.add(queueExpiry);\n  }\n\n  /**\n   * @notice Deletes a dequeued proposal.\n   * @param proposal The proposal struct.\n   * @param proposalId The ID of the proposal to delete.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @dev Must always be preceded by `isDequeuedProposal`, which checks `index`.\n   */\n  function deleteDequeuedProposal(\n    Proposals.Proposal storage proposal,\n    uint256 proposalId,\n    uint256 index\n  ) private {\n    if (proposal.isApproved() && proposal.networkWeight != 0) {\n      updateParticipationBaseline(proposal);\n    }\n    dequeued[index] = 0;\n    emptyIndices.push(index);\n    delete proposals[proposalId];\n  }\n\n  /**\n   * @notice Updates the participation baseline based on the proportion of BondedDeposit weight\n   *   that participated in the proposal's Referendum stage.\n   * @param proposal The proposal struct.\n   */\n  function updateParticipationBaseline(Proposals.Proposal storage proposal) private {\n    FixidityLib.Fraction memory participation = proposal.getParticipation();\n    FixidityLib.Fraction memory participationComponent = participation.multiply(\n      participationParameters.baselineUpdateFactor\n    );\n    FixidityLib.Fraction memory baselineComponent = participationParameters.baseline.multiply(\n      FixidityLib.fixed1().subtract(participationParameters.baselineUpdateFactor)\n    );\n    participationParameters.baseline = participationComponent.add(baselineComponent);\n    if (participationParameters.baseline.lt(participationParameters.baselineFloor)) {\n      participationParameters.baseline = participationParameters.baselineFloor;\n    }\n    emit ParticipationBaselineUpdated(participationParameters.baseline.unwrap());\n  }\n\n  /**\n   * @notice Returns the constitution for a particular destination and function ID.\n   * @param destination The destination address to get the constitution for.\n   * @param functionId The function ID to get the constitution for, zero for the destination\n   *   default.\n   * @return The ratio of yes:no votes needed to exceed in order to pass the proposal.\n   */\n  function getConstitution(address destination, bytes4 functionId) external view returns (uint256) {\n    return _getConstitution(destination, functionId).unwrap();\n  }\n\n  function _getConstitution(address destination, bytes4 functionId)\n    internal\n    view\n    returns (FixidityLib.Fraction memory)\n  {\n    // Default to a simple majority.\n    FixidityLib.Fraction memory threshold = FixidityLib.wrap(FIXED_HALF);\n    if (constitution[destination].functionThresholds[functionId].unwrap() != 0) {\n      threshold = constitution[destination].functionThresholds[functionId];\n    } else if (constitution[destination].defaultThreshold.unwrap() != 0) {\n      threshold = constitution[destination].defaultThreshold;\n    }\n    return threshold;\n  }\n\n  /**\n   * @notice Returns max number of votes cast by an account.\n   * @param account The address of the account.\n   * @return The total number of votes cast by an account.\n   */\n  function getAmountOfGoldUsedForVoting(address account) public view returns (uint256) {\n    Voter storage voter = voters[account];\n\n    uint256 upvotedProposalId = voter.upvote.proposalId;\n    bool isVotingQueue = upvotedProposalId != 0 &&\n      isQueued(upvotedProposalId) &&\n      !isQueuedProposalExpired(upvotedProposalId);\n\n    if (isVotingQueue) {\n      uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n      return weight;\n    }\n\n    uint256 maxUsed = 0;\n    for (uint256 index = 0; index < dequeued.length; index = index.add(1)) {\n      Proposals.Proposal storage proposal = proposals[dequeued[index]];\n      bool isVotingReferendum = (getProposalDequeuedStage(proposal) == Proposals.Stage.Referendum);\n\n      if (!isVotingReferendum) {\n        continue;\n      }\n\n      VoteRecord storage voteRecord = voter.referendumVotes[index];\n      uint256 votesCast = voteRecord.yesVotes.add(voteRecord.noVotes).add(voteRecord.abstainVotes);\n      maxUsed = Math.max(\n        maxUsed,\n        // backward compatibility for transition period - this should be updated later on\n        votesCast == 0 ? voteRecord.deprecated_weight : votesCast\n      );\n    }\n    return maxUsed;\n  }\n\n  /**\n   * @notice When delegator removes votes from delegatee during the time when delegator is voting\n   * for governance proposal, this method will remove votes from voted proposal proportionally.\n   * @param account The address of the account.\n   * @param newVotingPower The adjusted voting power of delegatee.\n   */\n  function removeVotesWhenRevokingDelegatedVotes(address account, uint256 newVotingPower)\n    public\n    onlyLockedGold\n  {\n    _removeVotesWhenRevokingDelegatedVotes(account, newVotingPower);\n  }\n\n  /**\n   * @notice When delegator removes votes from delegatee during the time when delegator is voting\n   * for governance proposal, this method will remove votes from voted proposal proportionally.\n   * @param account The address of the account.\n   * @param newVotingPower The adjusted voting power of delegatee.\n   */\n  function _removeVotesWhenRevokingDelegatedVotes(address account, uint256 newVotingPower)\n    internal\n  {\n    Voter storage voter = voters[account];\n\n    for (uint256 index = 0; index < dequeued.length; index = index.add(1)) {\n      Proposals.Proposal storage proposal = proposals[dequeued[index]];\n      bool isVotingReferendum = (getProposalDequeuedStage(proposal) == Proposals.Stage.Referendum);\n\n      if (!isVotingReferendum) {\n        continue;\n      }\n\n      VoteRecord storage voteRecord = voter.referendumVotes[index];\n      uint256 sumOfVotes = voteRecord.yesVotes.add(voteRecord.noVotes).add(voteRecord.abstainVotes);\n\n      if (sumOfVotes > newVotingPower) {\n        uint256 toRemove = sumOfVotes.sub(newVotingPower);\n\n        uint256 abstainToRemove = getVotesPortion(toRemove, voteRecord.abstainVotes, sumOfVotes);\n        uint256 yesToRemove = getVotesPortion(toRemove, voteRecord.yesVotes, sumOfVotes);\n        uint256 noToRemove = getVotesPortion(toRemove, voteRecord.noVotes, sumOfVotes);\n\n        uint256 totalRemoved = abstainToRemove.add(yesToRemove).add(noToRemove);\n\n        uint256 yesVotes = voteRecord.yesVotes.sub(yesToRemove);\n        uint256 noVotes = voteRecord.noVotes.sub(noToRemove);\n        uint256 abstainVotes = voteRecord.abstainVotes.sub(abstainToRemove);\n\n        if (totalRemoved < toRemove) {\n          // in case of rounding error\n          uint256 roundingToRemove = toRemove.sub(totalRemoved);\n\n          uint256 toRemoveRounding = Math.min(roundingToRemove, yesVotes);\n          yesVotes = yesVotes.sub(toRemoveRounding);\n          roundingToRemove = roundingToRemove.sub(toRemoveRounding);\n\n          if (roundingToRemove != 0) {\n            toRemoveRounding = Math.min(roundingToRemove, noVotes);\n            noVotes = noVotes.sub(toRemoveRounding);\n            roundingToRemove = roundingToRemove.sub(toRemoveRounding);\n          }\n\n          if (roundingToRemove != 0) {\n            toRemoveRounding = Math.min(roundingToRemove, abstainVotes);\n            abstainVotes = abstainVotes.sub(toRemoveRounding);\n          }\n        }\n\n        proposal.updateVote(\n          voteRecord.yesVotes,\n          voteRecord.noVotes,\n          voteRecord.abstainVotes,\n          yesVotes,\n          noVotes,\n          abstainVotes\n        );\n\n        voteRecord.abstainVotes = abstainVotes;\n        voteRecord.yesVotes = yesVotes;\n        voteRecord.noVotes = noVotes;\n      }\n    }\n  }\n\n  /**\n   * Returns amount of votes that should be removed from delegatee's proposal voting.\n   * @param totalToRemove Total votes to be removed.\n   * @param votes Yes/no/abstrain votes\n   * @param sumOfAllVotes Sum of yes, no, and abstain votes.\n   */\n  function getVotesPortion(uint256 totalToRemove, uint256 votes, uint256 sumOfAllVotes)\n    private\n    pure\n    returns (uint256)\n  {\n    return\n      FixidityLib\n        .newFixed(totalToRemove)\n        .multiply(FixidityLib.newFixedFraction(votes, sumOfAllVotes))\n        .fromFixed();\n  }\n\n  /**\n   * @param values The values of CELO to be sent in the proposed transactions.\n   * @param destinations The destination addresses of the proposed transactions.\n   * @param data The concatenated data to be included in the proposed transactions.\n   * @param dataLengths The lengths of each transaction's data.\n   * @param salt Arbitrary salt associated with hotfix which guarantees uniqueness of hash.\n   * @return The hash of the hotfix.\n   */\n  function getHotfixHash(\n    uint256[] calldata values,\n    address[] calldata destinations,\n    bytes calldata data,\n    uint256[] calldata dataLengths,\n    bytes32 salt\n  ) external pure returns (bytes32) {\n    return keccak256(abi.encode(values, destinations, data, dataLengths, salt));\n  }\n\n  /**\n   * @notice Returns the stage of a dequeued proposal.\n   * @param proposal The proposal struct.\n   * @return The stage of the dequeued proposal.\n   * @dev Must be called on a dequeued proposal.\n   */\n  function getProposalDequeuedStage(Proposals.Proposal storage proposal)\n    internal\n    view\n    returns (Proposals.Stage)\n  {\n    uint256 stageStartTime = proposal.timestamp.add(stageDurations.referendum).add(\n      stageDurations.execution\n    );\n    // solhint-disable-next-line not-rely-on-time\n    if (\n      now >= stageStartTime &&\n      (proposal.transactions.length != 0 ||\n        // proposals with 0 transactions can expire only when not approved or not passing\n        !proposal.isApproved() ||\n        !_isProposalPassing(proposal))\n    ) {\n      return Proposals.Stage.Expiration;\n    }\n    stageStartTime = stageStartTime.sub(stageDurations.execution);\n    // solhint-disable-next-line not-rely-on-time\n    if (now >= stageStartTime) {\n      return Proposals.Stage.Execution;\n    }\n    return Proposals.Stage.Referendum;\n  }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "getVersionNumber",
                "initialize",
                "setApprover",
                "setConcurrentProposals",
                "setMinDeposit",
                "setQueueExpiry",
                "setDequeueFrequency",
                "setReferendumStageDuration",
                "setExecutionStageDuration",
                "setParticipationBaseline",
                "setParticipationFloor",
                "setBaselineUpdateFactor",
                "setBaselineQuorumFactor",
                "setConstitution",
                "propose",
                "removeIfQueuedAndExpired",
                "requireDequeuedAndDeleteExpired",
                "upvote",
                "getProposalStage",
                "revokeUpvote",
                "approve",
                "vote",
                "votePartially",
                "_vote",
                "revokeVotes",
                "execute",
                "approveHotfix",
                "isHotfixWhitelistedBy",
                "whitelistHotfix",
                "prepareHotfix",
                "executeHotfix",
                "withdraw",
                "isVoting",
                "getReferendumStageDuration",
                "getExecutionStageDuration",
                "getParticipationParameters",
                "proposalExists",
                "getProposal",
                "getProposalTransaction",
                "isApproved",
                "getVoteTotals",
                "getVoteRecord",
                "getQueueLength",
                "getUpvotes",
                "getQueue",
                "getDequeue",
                "getUpvoteRecord",
                "getMostRecentReferendumProposal",
                "hotfixWhitelistValidatorTally",
                "isHotfixPassing",
                "getHotfixRecord",
                "dequeueProposalsIfReady",
                "isQueued",
                "isProposalPassing",
                "_isProposalPassing",
                "isDequeuedProposal",
                "_isDequeuedProposal",
                "isDequeuedProposalExpired",
                "_isDequeuedProposalExpired",
                "isQueuedProposalExpired",
                "_isQueuedProposalExpired",
                "deleteDequeuedProposal",
                "updateParticipationBaseline",
                "getConstitution",
                "_getConstitution",
                "getAmountOfGoldUsedForVoting",
                "removeVotesWhenRevokingDelegatedVotes",
                "_removeVotesWhenRevokingDelegatedVotes",
                "getVotesPortion",
                "getHotfixHash",
                "getProposalDequeuedStage"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "Governance_check_initializer",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "Governance.sol",
        "target_function": "initialize",
        "text_chunk": "function initialize(\n    address registryAddress,\n    address _approver,\n    uint256 _concurrentProposals,\n    uint256 _minDeposit,\n    uint256 _queueExpiry,\n    uint256 _dequeueFrequency,\n    uint256 referendumStageDuration,\n    uint256 executionStageDuration,\n    uint256 participationBaseline,\n    uint256 participationFloor,\n    uint256 baselineUpdateFactor,\n    uint256 baselineQuorumFactor\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setApprover(_approver);\n    setConcurrentProposals(_concurrentProposals);\n    setMinDeposit(_minDeposit);\n    setQueueExpiry(_queueExpiry);\n    setDequeueFrequency(_dequeueFrequency);\n    setReferendumStageDuration(referendumStageDuration);\n    setExecutionStageDuration(executionStageDuration);\n    setParticipationBaseline(participationBaseline);\n    setParticipationFloor(participationFloor);\n    setBaselineUpdateFactor(baselineUpdateFactor);\n    setBaselineQuorumFactor(baselineQuorumFactor);\n    // solhint-disable-next-line not-rely-on-time\n    lastDequeue = now;\n  }",
        "formal_property": "rule check_initializer {\n\tenv _e;\n\tenv eF;\n\tenv e_;\n\t\n\tbool _isInitialized = initialized(_e);\n\t\n\tcalldataarg arg;\n\tinitialize@withrevert(eF,arg);\n\tbool successInit = !lastReverted;\n\t\n\tbool isInitialized_ = initialized(e_);\n\t\n\tassert _isInitialized => !successInit, \"initialize() must revert if already initialized\";\n\tassert successInit => isInitialized_, \"When initialize() succeeds, must set initialization field to true\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "check_initializer",
            "rule_type": "RULE"
        }
    },
    {
        "id": "Governance_dequeuedIsWithinRange",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Governance.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.5.13;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/math/Math.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/utils/Address.sol\";\n\nimport \"./interfaces/IGovernance.sol\";\nimport \"./Proposals.sol\";\nimport \"../common/interfaces/IAccounts.sol\";\nimport \"../common/ExtractFunctionSignature.sol\";\nimport \"../common/Initializable.sol\";\nimport \"../common/FixidityLib.sol\";\nimport \"../common/linkedlists/IntegerSortedLinkedList.sol\";\nimport \"../common/UsingRegistry.sol\";\nimport \"../common/UsingPrecompiles.sol\";\nimport \"../common/interfaces/ICeloVersionedContract.sol\";\nimport \"../common/libraries/ReentrancyGuard.sol\";\n\n/**\n * @title A contract for making, passing, and executing on-chain governance proposals.\n */\ncontract Governance is\n  IGovernance,\n  ICeloVersionedContract,\n  Ownable,\n  Initializable,\n  ReentrancyGuard,\n  UsingRegistry,\n  UsingPrecompiles\n{\n  using Proposals for Proposals.Proposal;\n  using FixidityLib for FixidityLib.Fraction;\n  using SafeMath for uint256;\n  using IntegerSortedLinkedList for SortedLinkedList.List;\n  using BytesLib for bytes;\n  using Address for address payable; // prettier-ignore\n\n  uint256 private constant FIXED_HALF = 500000000000000000000000;\n\n  enum VoteValue { None, Abstain, No, Yes }\n\n  struct UpvoteRecord {\n    uint256 proposalId;\n    uint256 weight;\n  }\n\n  struct VoteRecord {\n    Proposals.VoteValue deprecated_value; // obsolete\n    uint256 proposalId;\n    uint256 deprecated_weight; // obsolete\n    uint256 yesVotes;\n    uint256 noVotes;\n    uint256 abstainVotes;\n  }\n\n  struct Voter {\n    // Key of the proposal voted for in the proposal queue\n    UpvoteRecord upvote;\n    uint256 mostRecentReferendumProposal;\n    // Maps a `dequeued` index to a voter's vote record.\n    mapping(uint256 => VoteRecord) referendumVotes;\n  }\n\n  struct ContractConstitution {\n    FixidityLib.Fraction defaultThreshold;\n    // Maps a function ID to a corresponding threshold, overriding the default.\n    mapping(bytes4 => FixidityLib.Fraction) functionThresholds;\n  }\n\n  struct HotfixRecord {\n    bool executed;\n    bool approved;\n    uint256 preparedEpoch;\n    mapping(address => bool) whitelisted;\n  }\n\n  // The baseline is updated as\n  // max{floor, (1 - baselineUpdateFactor) * baseline + baselineUpdateFactor * participation}\n  struct ParticipationParameters {\n    // The average network participation in governance, weighted toward recent proposals.\n    FixidityLib.Fraction baseline;\n    // The lower bound on the participation baseline.\n    FixidityLib.Fraction baselineFloor;\n    // The weight of the most recent proposal's participation on the baseline.\n    FixidityLib.Fraction baselineUpdateFactor;\n    // The proportion of the baseline that constitutes quorum.\n    FixidityLib.Fraction baselineQuorumFactor;\n  }\n\n  Proposals.StageDurations public stageDurations;\n  uint256 public queueExpiry;\n  uint256 public dequeueFrequency;\n  address public approver;\n  uint256 public lastDequeue;\n  uint256 public concurrentProposals;\n  uint256 public proposalCount;\n  uint256 public minDeposit;\n  mapping(address => uint256) public refundedDeposits;\n  mapping(address => ContractConstitution) private constitution;\n  mapping(uint256 => Proposals.Proposal) private proposals;\n  mapping(address => Voter) internal voters;\n  mapping(bytes32 => HotfixRecord) public hotfixes;\n  SortedLinkedList.List private queue;\n  uint256[] public dequeued;\n  uint256[] public emptyIndices;\n  ParticipationParameters private participationParameters;\n\n  event ApproverSet(address indexed approver);\n\n  event ConcurrentProposalsSet(uint256 concurrentProposals);\n\n  event MinDepositSet(uint256 minDeposit);\n\n  event QueueExpirySet(uint256 queueExpiry);\n\n  event DequeueFrequencySet(uint256 dequeueFrequency);\n\n  event ReferendumStageDurationSet(uint256 referendumStageDuration);\n\n  event ExecutionStageDurationSet(uint256 executionStageDuration);\n\n  event ConstitutionSet(address indexed destination, bytes4 indexed functionId, uint256 threshold);\n\n  event ProposalQueued(\n    uint256 indexed proposalId,\n    address indexed proposer,\n    uint256 transactionCount,\n    uint256 deposit,\n    uint256 timestamp\n  );\n\n  event ProposalUpvoted(uint256 indexed proposalId, address indexed account, uint256 upvotes);\n\n  event ProposalUpvoteRevoked(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 revokedUpvotes\n  );\n\n  event ProposalDequeued(uint256 indexed proposalId, uint256 timestamp);\n\n  event ProposalApproved(uint256 indexed proposalId);\n\n  event ProposalVoted(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 value,\n    uint256 weight\n  );\n\n  event ProposalVotedV2(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 yesVotes,\n    uint256 noVotes,\n    uint256 abstainVotes\n  );\n\n  event ProposalVoteRevoked(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 value,\n    uint256 weight\n  );\n\n  event ProposalVoteRevokedV2(\n    uint256 indexed proposalId,\n    address indexed account,\n    uint256 yesVotes,\n    uint256 noVotes,\n    uint256 abstainVotes\n  );\n\n  event ProposalExecuted(uint256 indexed proposalId);\n\n  event ProposalExpired(uint256 indexed proposalId);\n\n  event ParticipationBaselineUpdated(uint256 participationBaseline);\n\n  event ParticipationFloorSet(uint256 participationFloor);\n\n  event ParticipationBaselineUpdateFactorSet(uint256 baselineUpdateFactor);\n\n  event ParticipationBaselineQuorumFactorSet(uint256 baselineQuorumFactor);\n\n  event HotfixWhitelisted(bytes32 indexed hash, address whitelister);\n\n  event HotfixApproved(bytes32 indexed hash);\n\n  event HotfixPrepared(bytes32 indexed hash, uint256 indexed epoch);\n\n  event HotfixExecuted(bytes32 indexed hash);\n\n  modifier hotfixNotExecuted(bytes32 hash) {\n    require(!hotfixes[hash].executed, \"hotfix already executed\");\n    _;\n  }\n\n  modifier onlyApprover() {\n    require(msg.sender == approver, \"msg.sender not approver\");\n    _;\n  }\n\n  modifier onlyLockedGold() {\n    require(msg.sender == address(getLockedGold()), \"msg.sender not lockedGold\");\n    _;\n  }\n\n  /**\n   * @notice Sets initialized == true on implementation contracts\n   * @param test Set to true to skip implementation initialization\n   */\n  constructor(bool test) public Initializable(test) {}\n\n  function() external payable {\n    require(msg.data.length == 0, \"unknown method\");\n  }\n\n  /**\n   * @notice Returns the storage, major, minor, and patch version of the contract.\n   * @return Storage version of the contract.\n   * @return Major version of the contract.\n   * @return Minor version of the contract.\n   * @return Patch version of the contract.\n   */\n  function getVersionNumber() external pure returns (uint256, uint256, uint256, uint256) {\n    return (1, 4, 1, 0);\n  }\n\n  /**\n   * @notice Used in place of the constructor to allow the contract to be upgradable via proxy.\n   * @param registryAddress The address of the registry contract.\n   * @param _approver The address that needs to approve proposals to move to the referendum stage.\n   * @param _concurrentProposals The number of proposals to dequeue at once.\n   * @param _minDeposit The minimum CELO deposit needed to make a proposal.\n   * @param _queueExpiry The number of seconds a proposal can stay in the queue before expiring.\n   * @param _dequeueFrequency The number of seconds before the next batch of proposals can be\n   *   dequeued.\n   * @param referendumStageDuration The number of seconds users have to vote on a dequeued proposal\n   *   after the approval stage ends.\n   * @param executionStageDuration The number of seconds users have to execute a passed proposal\n   *   after the referendum stage ends.\n   * @param participationBaseline The initial value of the participation baseline.\n   * @param participationFloor The participation floor.\n   * @param baselineUpdateFactor The weight of the new participation in the baseline update rule.\n   * @param baselineQuorumFactor The proportion of the baseline that constitutes quorum.\n   * @dev Should be called only once.\n   */\n  function initialize(\n    address registryAddress,\n    address _approver,\n    uint256 _concurrentProposals,\n    uint256 _minDeposit,\n    uint256 _queueExpiry,\n    uint256 _dequeueFrequency,\n    uint256 referendumStageDuration,\n    uint256 executionStageDuration,\n    uint256 participationBaseline,\n    uint256 participationFloor,\n    uint256 baselineUpdateFactor,\n    uint256 baselineQuorumFactor\n  ) external initializer {\n    _transferOwnership(msg.sender);\n    setRegistry(registryAddress);\n    setApprover(_approver);\n    setConcurrentProposals(_concurrentProposals);\n    setMinDeposit(_minDeposit);\n    setQueueExpiry(_queueExpiry);\n    setDequeueFrequency(_dequeueFrequency);\n    setReferendumStageDuration(referendumStageDuration);\n    setExecutionStageDuration(executionStageDuration);\n    setParticipationBaseline(participationBaseline);\n    setParticipationFloor(participationFloor);\n    setBaselineUpdateFactor(baselineUpdateFactor);\n    setBaselineQuorumFactor(baselineQuorumFactor);\n    // solhint-disable-next-line not-rely-on-time\n    lastDequeue = now;\n  }\n\n  /**\n   * @notice Updates the address that has permission to approve proposals in the approval stage.\n   * @param _approver The address that has permission to approve proposals in the approval stage.\n   */\n  function setApprover(address _approver) public onlyOwner {\n    require(_approver != address(0), \"Approver cannot be 0\");\n    require(_approver != approver, \"Approver unchanged\");\n    approver = _approver;\n    emit ApproverSet(_approver);\n  }\n\n  /**\n   * @notice Updates the number of proposals to dequeue at a time.\n   * @param _concurrentProposals The number of proposals to dequeue at at a time.\n   */\n  function setConcurrentProposals(uint256 _concurrentProposals) public onlyOwner {\n    require(_concurrentProposals != 0, \"Number of proposals must be larger than zero\");\n    require(_concurrentProposals != concurrentProposals, \"Number of proposals unchanged\");\n    concurrentProposals = _concurrentProposals;\n    emit ConcurrentProposalsSet(_concurrentProposals);\n  }\n\n  /**\n   * @notice Updates the minimum deposit needed to make a proposal.\n   * @param _minDeposit The minimum CELO deposit needed to make a proposal.\n   */\n  function setMinDeposit(uint256 _minDeposit) public onlyOwner {\n    require(_minDeposit != 0, \"minDeposit must be larger than 0\");\n    require(_minDeposit != minDeposit, \"Minimum deposit unchanged\");\n    minDeposit = _minDeposit;\n    emit MinDepositSet(_minDeposit);\n  }\n\n  /**\n   * @notice Updates the number of seconds before a queued proposal expires.\n   * @param _queueExpiry The number of seconds a proposal can stay in the queue before expiring.\n   */\n  function setQueueExpiry(uint256 _queueExpiry) public onlyOwner {\n    require(_queueExpiry != 0, \"QueueExpiry must be larger than 0\");\n    require(_queueExpiry != queueExpiry, \"QueueExpiry unchanged\");\n    queueExpiry = _queueExpiry;\n    emit QueueExpirySet(_queueExpiry);\n  }\n\n  /**\n   * @notice Updates the minimum number of seconds before the next batch of proposals can be\n   *   dequeued.\n   * @param _dequeueFrequency The number of seconds before the next batch of proposals can be\n   *   dequeued.\n   */\n  function setDequeueFrequency(uint256 _dequeueFrequency) public onlyOwner {\n    require(_dequeueFrequency != 0, \"dequeueFrequency must be larger than 0\");\n    require(_dequeueFrequency != dequeueFrequency, \"dequeueFrequency unchanged\");\n    dequeueFrequency = _dequeueFrequency;\n    emit DequeueFrequencySet(_dequeueFrequency);\n  }\n\n  /**\n   * @notice Updates the number of seconds proposals stay in the referendum stage.\n   * @param referendumStageDuration The number of seconds proposals stay in the referendum stage.\n   */\n  function setReferendumStageDuration(uint256 referendumStageDuration) public onlyOwner {\n    require(referendumStageDuration != 0, \"Duration must be larger than 0\");\n    require(referendumStageDuration != stageDurations.referendum, \"Duration unchanged\");\n    stageDurations.referendum = referendumStageDuration;\n    emit ReferendumStageDurationSet(referendumStageDuration);\n  }\n\n  /**\n   * @notice Updates the number of seconds proposals stay in the execution stage.\n   * @param executionStageDuration The number of seconds proposals stay in the execution stage.\n   */\n  function setExecutionStageDuration(uint256 executionStageDuration) public onlyOwner {\n    require(executionStageDuration != 0, \"Duration must be larger than 0\");\n    require(executionStageDuration != stageDurations.execution, \"Duration unchanged\");\n    stageDurations.execution = executionStageDuration;\n    emit ExecutionStageDurationSet(executionStageDuration);\n  }\n\n  /**\n   * @notice Updates the participation baseline.\n   * @param participationBaseline The value of the baseline.\n   */\n  function setParticipationBaseline(uint256 participationBaseline) public onlyOwner {\n    FixidityLib.Fraction memory participationBaselineFrac = FixidityLib.wrap(participationBaseline);\n    require(\n      FixidityLib.isProperFraction(participationBaselineFrac),\n      \"Participation baseline greater than one\"\n    );\n    require(\n      !participationBaselineFrac.equals(participationParameters.baseline),\n      \"Participation baseline unchanged\"\n    );\n    participationParameters.baseline = participationBaselineFrac;\n    emit ParticipationBaselineUpdated(participationBaseline);\n  }\n\n  /**\n   * @notice Updates the floor of the participation baseline.\n   * @param participationFloor The value at which the baseline is floored.\n   */\n  function setParticipationFloor(uint256 participationFloor) public onlyOwner {\n    FixidityLib.Fraction memory participationFloorFrac = FixidityLib.wrap(participationFloor);\n    require(\n      FixidityLib.isProperFraction(participationFloorFrac),\n      \"Participation floor greater than one\"\n    );\n    require(\n      !participationFloorFrac.equals(participationParameters.baselineFloor),\n      \"Participation baseline floor unchanged\"\n    );\n    participationParameters.baselineFloor = participationFloorFrac;\n    emit ParticipationFloorSet(participationFloor);\n  }\n\n  /**\n   * @notice Updates the weight of the new participation in the baseline update rule.\n   * @param baselineUpdateFactor The new baseline update factor.\n   */\n  function setBaselineUpdateFactor(uint256 baselineUpdateFactor) public onlyOwner {\n    FixidityLib.Fraction memory baselineUpdateFactorFrac = FixidityLib.wrap(baselineUpdateFactor);\n    require(\n      FixidityLib.isProperFraction(baselineUpdateFactorFrac),\n      \"Baseline update factor greater than one\"\n    );\n    require(\n      !baselineUpdateFactorFrac.equals(participationParameters.baselineUpdateFactor),\n      \"Baseline update factor unchanged\"\n    );\n    participationParameters.baselineUpdateFactor = baselineUpdateFactorFrac;\n    emit ParticipationBaselineUpdateFactorSet(baselineUpdateFactor);\n  }\n\n  /**\n   * @notice Updates the proportion of the baseline that constitutes quorum.\n   * @param baselineQuorumFactor The new baseline quorum factor.\n   */\n  function setBaselineQuorumFactor(uint256 baselineQuorumFactor) public onlyOwner {\n    FixidityLib.Fraction memory baselineQuorumFactorFrac = FixidityLib.wrap(baselineQuorumFactor);\n    require(\n      FixidityLib.isProperFraction(baselineQuorumFactorFrac),\n      \"Baseline quorum factor greater than one\"\n    );\n    require(\n      !baselineQuorumFactorFrac.equals(participationParameters.baselineQuorumFactor),\n      \"Baseline quorum factor unchanged\"\n    );\n    participationParameters.baselineQuorumFactor = baselineQuorumFactorFrac;\n    emit ParticipationBaselineQuorumFactorSet(baselineQuorumFactor);\n  }\n\n  /**\n   * @notice Updates the ratio of yes:yes+no votes needed for a specific class of proposals to pass.\n   * @param destination The destination of proposals for which this threshold should apply.\n   * @param functionId The function ID of proposals for which this threshold should apply. Zero\n   *   will set the default.\n   * @param threshold The threshold.\n   * @dev If no constitution is explicitly set the default is a simple majority, i.e. 1:2.\n   */\n  function setConstitution(address destination, bytes4 functionId, uint256 threshold)\n    external\n    onlyOwner\n  {\n    require(destination != address(0), \"Destination cannot be zero\");\n    require(\n      threshold > FIXED_HALF && threshold <= FixidityLib.fixed1().unwrap(),\n      \"Threshold has to be greater than majority and not greater than unanimity\"\n    );\n    if (functionId == 0) {\n      constitution[destination].defaultThreshold = FixidityLib.wrap(threshold);\n    } else {\n      constitution[destination].functionThresholds[functionId] = FixidityLib.wrap(threshold);\n    }\n    emit ConstitutionSet(destination, functionId, threshold);\n  }\n\n  /**\n   * @notice Creates a new proposal and adds it to end of the queue with no upvotes.\n   * @param values The values of CELO to be sent in the proposed transactions.\n   * @param destinations The destination addresses of the proposed transactions.\n   * @param data The concatenated data to be included in the proposed transactions.\n   * @param dataLengths The lengths of each transaction's data.\n   * @return The ID of the newly proposed proposal.\n   * @dev The minimum deposit must be included with the proposal, returned if/when the proposal is\n   *   dequeued.\n   */\n  function propose(\n    uint256[] calldata values,\n    address[] calldata destinations,\n    bytes calldata data,\n    uint256[] calldata dataLengths,\n    string calldata descriptionUrl\n  ) external payable returns (uint256) {\n    dequeueProposalsIfReady();\n    require(msg.value >= minDeposit, \"Too small deposit\");\n\n    proposalCount = proposalCount.add(1);\n    Proposals.Proposal storage proposal = proposals[proposalCount];\n    proposal.make(values, destinations, data, dataLengths, msg.sender, msg.value);\n    proposal.setDescriptionUrl(descriptionUrl);\n    queue.push(proposalCount);\n    // solhint-disable-next-line not-rely-on-time\n    emit ProposalQueued(proposalCount, msg.sender, proposal.transactions.length, msg.value, now);\n    return proposalCount;\n  }\n\n  /**\n   * @notice Removes a proposal if it is queued and expired.\n   * @param proposalId The ID of the proposal to remove.\n   * @return Whether the proposal was removed.\n   */\n  function removeIfQueuedAndExpired(uint256 proposalId) private returns (bool) {\n    if (isQueued(proposalId) && isQueuedProposalExpired(proposalId)) {\n      queue.remove(proposalId);\n      emit ProposalExpired(proposalId);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @notice Requires a proposal is dequeued and removes it if expired.\n   * @param proposalId The ID of the proposal.\n   * @return The proposal storage struct corresponding to `proposalId`.\n   * @return The proposal stage corresponding to `proposalId`.\n   */\n  function requireDequeuedAndDeleteExpired(uint256 proposalId, uint256 index)\n    private\n    returns (Proposals.Proposal storage, Proposals.Stage)\n  {\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    require(_isDequeuedProposal(proposal, proposalId, index), \"Proposal not dequeued\");\n    Proposals.Stage stage = getProposalDequeuedStage(proposal);\n    if (_isDequeuedProposalExpired(proposal, stage)) {\n      deleteDequeuedProposal(proposal, proposalId, index);\n      return (proposal, Proposals.Stage.Expiration);\n    }\n    return (proposal, stage);\n  }\n\n  /**\n   * @notice Upvotes a queued proposal.\n   * @param proposalId The ID of the proposal to upvote.\n   * @param lesser The ID of the proposal that will be just behind `proposalId` in the queue.\n   * @param greater The ID of the proposal that will be just ahead `proposalId` in the queue.\n   * @return Whether or not the upvote was made successfully.\n   * @dev Provide 0 for `lesser`/`greater` when the proposal will be at the tail/head of the queue.\n   * @dev Reverts if the account has already upvoted a proposal in the queue.\n   */\n  function upvote(uint256 proposalId, uint256 lesser, uint256 greater)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    // If acting on an expired proposal, expire the proposal and take no action.\n    if (removeIfQueuedAndExpired(proposalId)) {\n      return false;\n    }\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    removeIfQueuedAndExpired(voter.upvote.proposalId);\n\n    // We can upvote a proposal in the queue if we're not already upvoting a proposal in the queue.\n    uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n    require(weight > 0, \"cannot upvote without locking gold\");\n    require(queue.contains(proposalId), \"cannot upvote a proposal not in the queue\");\n    require(\n      voter.upvote.proposalId == 0 || !queue.contains(voter.upvote.proposalId),\n      \"cannot upvote more than one queued proposal\"\n    );\n    uint256 upvotes = queue.getValue(proposalId).add(weight);\n    queue.update(proposalId, upvotes, lesser, greater);\n    voter.upvote = UpvoteRecord(proposalId, weight);\n    emit ProposalUpvoted(proposalId, account, weight);\n    return true;\n  }\n\n  /**\n   * @notice Returns stage of governance process given proposal is in\n   * @param proposalId The ID of the proposal to query.\n   * @return proposal stage\n   */\n  function getProposalStage(uint256 proposalId) external view returns (Proposals.Stage) {\n    if (proposalId == 0 || proposalId > proposalCount) {\n      return Proposals.Stage.None;\n    }\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    if (isQueued(proposalId)) {\n      return\n        _isQueuedProposalExpired(proposal) ? Proposals.Stage.Expiration : Proposals.Stage.Queued;\n    } else {\n      Proposals.Stage stage = getProposalDequeuedStage(proposal);\n      return _isDequeuedProposalExpired(proposal, stage) ? Proposals.Stage.Expiration : stage;\n    }\n  }\n\n  /**\n   * @notice Revokes an upvote on a queued proposal.\n   * @param lesser The ID of the proposal that will be just behind the previously upvoted proposal\n   *   in the queue.\n   * @param greater The ID of the proposal that will be just ahead of the previously upvoted\n   *   proposal in the queue.\n   * @return Whether or not the upvote was revoked successfully.\n   * @dev Provide 0 for `lesser`/`greater` when the proposal will be at the tail/head of the queue.\n   */\n  function revokeUpvote(uint256 lesser, uint256 greater) external nonReentrant returns (bool) {\n    dequeueProposalsIfReady();\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    uint256 proposalId = voter.upvote.proposalId;\n    require(proposalId != 0, \"Account has no historical upvote\");\n    removeIfQueuedAndExpired(proposalId);\n    if (queue.contains(proposalId)) {\n      queue.update(\n        proposalId,\n        queue.getValue(proposalId).sub(voter.upvote.weight),\n        lesser,\n        greater\n      );\n      emit ProposalUpvoteRevoked(proposalId, account, voter.upvote.weight);\n    }\n    voter.upvote = UpvoteRecord(0, 0);\n    return true;\n  }\n\n  /**\n   * @notice Approves a proposal in the approval stage.\n   * @param proposalId The ID of the proposal to approve.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @return Whether or not the approval was made successfully.\n   */\n  function approve(uint256 proposalId, uint256 index) external onlyApprover returns (bool) {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(!proposal.isApproved(), \"Proposal already approved\");\n    require(\n      stage == Proposals.Stage.Referendum || stage == Proposals.Stage.Execution,\n      \"Proposal not in correct stage\"\n    );\n    proposal.approved = true;\n    // Ensures networkWeight is set by the end of the Referendum stage, even if 0 votes are cast.\n    proposal.networkWeight = getLockedGold().getTotalLockedGold();\n    emit ProposalApproved(proposalId);\n    return true;\n  }\n\n  /**\n   * @notice Votes on a proposal in the referendum stage.\n   * @param proposalId The ID of the proposal to vote on.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @param value Whether to vote yes, no, or abstain.\n   * @return Whether or not the vote was cast successfully.\n   */\n  /* solhint-disable code-complexity */\n  function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n    require(value != Proposals.VoteValue.None, \"Vote value unset\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 weight = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n    require(weight != 0, \"Voter weight zero\");\n\n    _vote(\n      proposal,\n      proposalId,\n      index,\n      account,\n      value == Proposals.VoteValue.Yes ? weight : 0,\n      value == Proposals.VoteValue.No ? weight : 0,\n      value == Proposals.VoteValue.Abstain ? weight : 0\n    );\n    return true;\n  }\n\n  /**\n   * @notice Votes partially on a proposal in the referendum stage.\n   * @param proposalId The ID of the proposal to vote on.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @param yesVotes The yes votes weight.\n   * @param noVotes The no votes weight.\n   * @param abstainVotes The abstain votes weight.\n   * @return Whether or not the vote was cast successfully.\n   */\n  /* solhint-disable code-complexity */\n  function votePartially(\n    uint256 proposalId,\n    uint256 index,\n    uint256 yesVotes,\n    uint256 noVotes,\n    uint256 abstainVotes\n  ) external nonReentrant returns (bool) {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }\n\n    require(stage == Proposals.Stage.Referendum, \"Incorrect proposal state\");\n\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    uint256 totalVotingPower = getLockedGold().getAccountTotalGovernanceVotingPower(account);\n\n    require(\n      totalVotingPower >= yesVotes.add(noVotes).add(abstainVotes),\n      \"Voter doesn't have enough locked Celo (formerly known as Celo Gold)\"\n    );\n    _vote(proposal, proposalId, index, account, yesVotes, noVotes, abstainVotes);\n\n    return true;\n  }\n\n  /**\n   * @notice Votes on a proposal in the referendum stage.\n   * @param proposal The proposal struct.\n   * @param proposalId The ID of the proposal to vote on.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @param account Account based on signer.\n   * @param yesVotes The yes votes weight.\n   * @param noVotes The no votes weight.\n   * @param abstainVotes The abstain votes weight.\n   * @return Whether or not the proposal is passing.\n   */\n  function _vote(\n    Proposals.Proposal storage proposal,\n    uint256 proposalId,\n    uint256 index,\n    address account,\n    uint256 yesVotes,\n    uint256 noVotes,\n    uint256 abstainVotes\n  ) private {\n    Voter storage voter = voters[account];\n\n    VoteRecord storage previousVoteRecord = voter.referendumVotes[index];\n\n    if (previousVoteRecord.proposalId != proposalId) {\n      // VoteRecord is being stored based on index (in `dequeued`) rather than proposalId.\n      // It can happen that user voted on proposal that later gets deleted.\n      // VoteRecord will still stay in `referendumVotes` mapping.\n      // Once new proposal is created it might get same index as previous proposal.\n      // In such case we need to check whether existing VoteRecord is relevant to new\n      // proposal of whether it is just left over data.\n      proposal.updateVote(0, 0, 0, yesVotes, noVotes, abstainVotes);\n    } else if (previousVoteRecord.deprecated_weight != 0) {\n      // backward compatibility for transition period - this should be deleted later on\n      proposal.updateVote(\n        previousVoteRecord.deprecated_value == Proposals.VoteValue.Yes\n          ? previousVoteRecord.deprecated_weight\n          : 0,\n        previousVoteRecord.deprecated_value == Proposals.VoteValue.No\n          ? previousVoteRecord.deprecated_weight\n          : 0,\n        previousVoteRecord.deprecated_value == Proposals.VoteValue.Abstain\n          ? previousVoteRecord.deprecated_weight\n          : 0,\n        yesVotes,\n        noVotes,\n        abstainVotes\n      );\n    } else {\n      proposal.updateVote(\n        previousVoteRecord.yesVotes,\n        previousVoteRecord.noVotes,\n        previousVoteRecord.abstainVotes,\n        yesVotes,\n        noVotes,\n        abstainVotes\n      );\n    }\n\n    proposal.networkWeight = getLockedGold().getTotalLockedGold();\n    voter.referendumVotes[index] = VoteRecord(\n      Proposals.VoteValue.None,\n      proposalId,\n      0,\n      yesVotes,\n      noVotes,\n      abstainVotes\n    );\n    if (proposal.timestamp > proposals[voter.mostRecentReferendumProposal].timestamp) {\n      voter.mostRecentReferendumProposal = proposalId;\n    }\n\n    emit ProposalVotedV2(proposalId, account, yesVotes, noVotes, abstainVotes);\n  }\n\n  /* solhint-enable code-complexity */\n\n  /**\n   * @notice Revoke votes on all proposals of sender in the referendum stage.\n   * @return Whether or not all votes of an account were successfully revoked.\n   */\n  function revokeVotes() external nonReentrant returns (bool) {\n    address account = getAccounts().voteSignerToAccount(msg.sender);\n    Voter storage voter = voters[account];\n    for (\n      uint256 dequeueIndex = 0;\n      dequeueIndex < dequeued.length;\n      dequeueIndex = dequeueIndex.add(1)\n    ) {\n      VoteRecord storage voteRecord = voter.referendumVotes[dequeueIndex];\n\n      // Skip proposals where there was no vote cast by the user AND\n      // ensure vote record proposal matches identifier of dequeued index proposal.\n      if (\n        voteRecord.proposalId == dequeued[dequeueIndex] &&\n        (voteRecord.yesVotes != 0 ||\n          voteRecord.noVotes != 0 ||\n          voteRecord.abstainVotes != 0 ||\n          voteRecord.deprecated_weight != 0)\n      ) {\n        (Proposals.Proposal storage proposal, Proposals.Stage stage) =\n          requireDequeuedAndDeleteExpired(voteRecord.proposalId, dequeueIndex); // prettier-ignore\n\n        // only revoke from proposals which are still in referendum\n        if (stage == Proposals.Stage.Referendum) {\n          if (voteRecord.deprecated_weight != 0) {\n            // backward compatibility for transition period - this should be deleted later on\n            uint256 previousYes = voteRecord.deprecated_value == Proposals.VoteValue.Yes\n              ? voteRecord.deprecated_weight\n              : 0;\n            uint256 previousNo = voteRecord.deprecated_value == Proposals.VoteValue.No\n              ? voteRecord.deprecated_weight\n              : 0;\n            uint256 previousAbstain = voteRecord.deprecated_value == Proposals.VoteValue.Abstain\n              ? voteRecord.deprecated_weight\n              : 0;\n            proposal.updateVote(previousYes, previousNo, previousAbstain, 0, 0, 0);\n\n            proposal.networkWeight = getLockedGold().getTotalLockedGold();\n            emit ProposalVoteRevokedV2(\n              voteRecord.proposalId,\n              account,\n              previousYes,\n              previousNo,\n              previousAbstain\n            );\n          } else {\n            proposal.updateVote(\n              voteRecord.yesVotes,\n              voteRecord.noVotes,\n              voteRecord.abstainVotes,\n              0,\n              0,\n              0\n            );\n            proposal.networkWeight = getLockedGold().getTotalLockedGold();\n            emit ProposalVoteRevokedV2(\n              voteRecord.proposalId,\n              account,\n              voteRecord.yesVotes,\n              voteRecord.noVotes,\n              voteRecord.abstainVotes\n            );\n          }\n        }\n\n        // always delete dequeue vote records for gas refund as they must be expired or revoked\n        delete voter.referendumVotes[dequeueIndex];\n      }\n    }\n\n    // reset most recent referendum proposal ID to guarantee isVotingReferendum == false\n    voter.mostRecentReferendumProposal = 0;\n    return true;\n  }\n\n  /**\n   * @notice Executes a proposal in the execution stage, removing it from `dequeued`.\n   * @param proposalId The ID of the proposal to vote on.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @return Whether or not the proposal was executed successfully.\n   * @dev Does not remove the proposal if the execution fails.\n   */\n  function execute(uint256 proposalId, uint256 index) external nonReentrant returns (bool) {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    bool notExpired = proposal.exists();\n    if (notExpired) {\n      require(proposal.isApproved(), \"Proposal not approved\");\n      require(\n        stage == Proposals.Stage.Execution && _isProposalPassing(proposal),\n        \"Proposal not in execution stage or not passing\"\n      );\n      proposal.execute();\n      emit ProposalExecuted(proposalId);\n      deleteDequeuedProposal(proposal, proposalId, index);\n    }\n    return notExpired;\n  }\n\n  /**\n   * @notice Approves the hash of a hotfix transaction(s).\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction(s) to be approved.\n   */\n  function approveHotfix(bytes32 hash) external hotfixNotExecuted(hash) onlyApprover {\n    hotfixes[hash].approved = true;\n    emit HotfixApproved(hash);\n  }\n\n  /**\n   * @notice Returns whether given hotfix hash has been whitelisted by given address.\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction(s) to be whitelisted.\n   * @param whitelister Address to check whitelist status of.\n   */\n  function isHotfixWhitelistedBy(bytes32 hash, address whitelister) public view returns (bool) {\n    return hotfixes[hash].whitelisted[whitelister];\n  }\n\n  /**\n   * @notice Whitelists the hash of a hotfix transaction(s).\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction(s) to be whitelisted.\n   */\n  function whitelistHotfix(bytes32 hash) external hotfixNotExecuted(hash) {\n    hotfixes[hash].whitelisted[msg.sender] = true;\n    emit HotfixWhitelisted(hash, msg.sender);\n  }\n\n  /**\n   * @notice Gives hotfix a prepared epoch for execution.\n   * @param hash The hash of the hotfix to be prepared.\n   */\n  function prepareHotfix(bytes32 hash) external hotfixNotExecuted(hash) {\n    require(isHotfixPassing(hash), \"hotfix not whitelisted by 2f+1 validators\");\n    uint256 epoch = getEpochNumber();\n    require(hotfixes[hash].preparedEpoch < epoch, \"hotfix already prepared for this epoch\");\n    hotfixes[hash].preparedEpoch = epoch;\n    emit HotfixPrepared(hash, epoch);\n  }\n\n  /**\n   * @notice Executes a whitelisted proposal.\n   * @param values The values of CELO to be sent in the proposed transactions.\n   * @param destinations The destination addresses of the proposed transactions.\n   * @param data The concatenated data to be included in the proposed transactions.\n   * @param dataLengths The lengths of each transaction's data.\n   * @param salt Arbitrary salt associated with hotfix which guarantees uniqueness of hash.\n   * @dev Reverts if hotfix is already executed, not approved, or not prepared for current epoch.\n   */\n  function executeHotfix(\n    uint256[] calldata values,\n    address[] calldata destinations,\n    bytes calldata data,\n    uint256[] calldata dataLengths,\n    bytes32 salt\n  ) external {\n    bytes32 hash = keccak256(abi.encode(values, destinations, data, dataLengths, salt));\n\n    (bool approved, bool executed, uint256 preparedEpoch) = getHotfixRecord(hash);\n    require(!executed, \"hotfix already executed\");\n    require(approved, \"hotfix not approved\");\n    require(preparedEpoch == getEpochNumber(), \"hotfix must be prepared for this epoch\");\n\n    Proposals.makeMem(values, destinations, data, dataLengths, msg.sender, 0).executeMem();\n\n    hotfixes[hash].executed = true;\n    emit HotfixExecuted(hash);\n  }\n\n  /**\n   * @notice Withdraws refunded CELO deposits.\n   * @return Whether or not the withdraw was successful.\n   */\n  function withdraw() external nonReentrant returns (bool) {\n    uint256 value = refundedDeposits[msg.sender];\n    require(value != 0, \"Nothing to withdraw\");\n    require(value <= address(this).balance, \"Inconsistent balance\");\n    refundedDeposits[msg.sender] = 0;\n    msg.sender.sendValue(value);\n    return true;\n  }\n\n  /**\n   * @notice Returns whether or not a particular account is voting on proposals.\n   * @param account The address of the account.\n   * @return Whether or not the account is voting on proposals.\n   */\n  function isVoting(address account) external view returns (bool) {\n    Voter storage voter = voters[account];\n    uint256 upvotedProposal = voter.upvote.proposalId;\n    bool isVotingQueue = upvotedProposal != 0 &&\n      isQueued(upvotedProposal) &&\n      !isQueuedProposalExpired(upvotedProposal);\n    Proposals.Proposal storage proposal = proposals[voter.mostRecentReferendumProposal];\n    bool isVotingReferendum = (getProposalDequeuedStage(proposal) == Proposals.Stage.Referendum);\n    return isVotingQueue || isVotingReferendum;\n  }\n\n  /**\n   * @notice Returns the number of seconds proposals stay in the referendum stage.\n   * @return The number of seconds proposals stay in the referendum stage.\n   */\n  function getReferendumStageDuration() external view returns (uint256) {\n    return stageDurations.referendum;\n  }\n\n  /**\n   * @notice Returns the number of seconds proposals stay in the execution stage.\n   * @return The number of seconds proposals stay in the execution stage.\n   */\n  function getExecutionStageDuration() external view returns (uint256) {\n    return stageDurations.execution;\n  }\n\n  /**\n   * @notice Returns the participation parameters.\n   * @return baseline The participation baseline parameter.\n   * @return baselineFloor The participation baseline floor parameter.\n   * @return baselineUpdateFactor The participation baseline update factor parameter.\n   * @return baselineQuorumFactor The participation baseline quorum factor parameter.\n   */\n  function getParticipationParameters() external view returns (uint256, uint256, uint256, uint256) {\n    return (\n      participationParameters.baseline.unwrap(),\n      participationParameters.baselineFloor.unwrap(),\n      participationParameters.baselineUpdateFactor.unwrap(),\n      participationParameters.baselineQuorumFactor.unwrap()\n    );\n  }\n\n  /**\n   * @notice Returns whether or not a proposal exists.\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the proposal exists.\n   */\n  function proposalExists(uint256 proposalId) external view returns (bool) {\n    return proposals[proposalId].exists();\n  }\n\n  /**\n   * @notice Returns an unpacked proposal struct with its transaction count.\n   * @param proposalId The ID of the proposal to unpack.\n   * @return proposer\n   * @return deposit\n   * @return timestamp\n   * @return transaction Transaction count.\n   * @return description Description url.\n   */\n  function getProposal(uint256 proposalId)\n    external\n    view\n    returns (address, uint256, uint256, uint256, string memory, uint256, bool)\n  {\n    return proposals[proposalId].unpack();\n  }\n\n  /**\n   * @notice Returns a specified transaction in a proposal.\n   * @param proposalId The ID of the proposal to query.\n   * @param index The index of the specified transaction in the proposal's transaction list.\n   * @return value Transaction value.\n   * @return destination Transaction destination.\n   * @return data Transaction data.\n   */\n  function getProposalTransaction(uint256 proposalId, uint256 index)\n    external\n    view\n    returns (uint256, address, bytes memory)\n  {\n    return proposals[proposalId].getTransaction(index);\n  }\n\n  /**\n   * @notice Returns whether or not a proposal has been approved.\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the proposal has been approved.\n   */\n  function isApproved(uint256 proposalId) external view returns (bool) {\n    return proposals[proposalId].isApproved();\n  }\n\n  /**\n   * @notice Returns the referendum vote totals for a proposal.\n   * @param proposalId The ID of the proposal.\n   * @return yes The yes vote totals.\n   * @return no The no vote totals.\n   * @return abstain The abstain vote totals.\n   */\n  function getVoteTotals(uint256 proposalId) external view returns (uint256, uint256, uint256) {\n    return proposals[proposalId].getVoteTotals();\n  }\n\n  /**\n   * @notice Returns an accounts vote record on a particular index in `dequeued`.\n   * @param account The address of the account to get the record for.\n   * @param index The index in `dequeued`.\n   * @return The corresponding proposal ID, vote value, and weight.\n   * @return The depreciated vote value.\n   * @return The deprecieated weight.\n   * @return The yes weight.\n   * @return The no weight.\n   * @return The abstain weight.\n   */\n  function getVoteRecord(address account, uint256 index)\n    external\n    view\n    returns (uint256, uint256, uint256, uint256, uint256, uint256)\n  {\n    VoteRecord storage record = voters[account].referendumVotes[index];\n    return (\n      record.proposalId,\n      uint256(record.deprecated_value),\n      record.deprecated_weight,\n      record.yesVotes,\n      record.noVotes,\n      record.abstainVotes\n    );\n  }\n\n  /**\n   * @notice Returns the number of proposals in the queue.\n   * @return The number of proposals in the queue.\n   */\n  function getQueueLength() external view returns (uint256) {\n    return queue.list.numElements;\n  }\n\n  /**\n   * @notice Returns the number of upvotes the queued proposal has received.\n   * @param proposalId The ID of the proposal.\n   * @return The number of upvotes a queued proposal has received.\n   */\n  function getUpvotes(uint256 proposalId) external view returns (uint256) {\n    require(isQueued(proposalId), \"Proposal not queued\");\n    return queue.getValue(proposalId);\n  }\n\n  /**\n   * @notice Returns the proposal ID and upvote total for all queued proposals.\n   * @return proposalID The proposal ID for all queued proposals.\n   * @return total The upvote total for all queued proposals.\n   * @dev Note that this includes expired proposals that have yet to be removed from the queue.\n   */\n  function getQueue() external view returns (uint256[] memory, uint256[] memory) {\n    return queue.getElements();\n  }\n\n  /**\n   * @notice Returns the dequeued proposal IDs.\n   * @return The dequeued proposal IDs.\n   * @dev Note that this includes unused indices with proposalId == 0 from deleted proposals.\n   */\n  function getDequeue() external view returns (uint256[] memory) {\n    return dequeued;\n  }\n\n  /**\n   * @notice Returns the ID of the proposal upvoted by `account` and the weight of that upvote.\n   * @param account The address of the account.\n   * @return The ID of the proposal upvoted by `account`.\n   * @return The weight of that upvote.\n   */\n  function getUpvoteRecord(address account) external view returns (uint256, uint256) {\n    UpvoteRecord memory upvoteRecord = voters[account].upvote;\n    return (upvoteRecord.proposalId, upvoteRecord.weight);\n  }\n\n  /**\n   * @notice Returns the ID of the most recently dequeued proposal voted on by `account`.\n   * @param account The address of the account.\n   * @return The ID of the most recently dequeued proposal voted on by `account`..\n   */\n  function getMostRecentReferendumProposal(address account) external view returns (uint256) {\n    return voters[account].mostRecentReferendumProposal;\n  }\n\n  /**\n   * @notice Returns number of validators from current set which have whitelisted the given hotfix.\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction.\n   * @return Whitelist tally\n   */\n  function hotfixWhitelistValidatorTally(bytes32 hash) public view returns (uint256) {\n    uint256 tally = 0;\n    uint256 n = numberValidatorsInCurrentSet();\n    IAccounts accounts = getAccounts();\n    for (uint256 i = 0; i < n; i = i.add(1)) {\n      address validatorSigner = validatorSignerAddressFromCurrentSet(i);\n      address validatorAccount = accounts.signerToAccount(validatorSigner);\n      if (\n        isHotfixWhitelistedBy(hash, validatorSigner) ||\n        isHotfixWhitelistedBy(hash, validatorAccount)\n      ) {\n        tally = tally.add(1);\n      }\n    }\n    return tally;\n  }\n\n  /**\n   * @notice Checks if a byzantine quorum of validators has whitelisted the given hotfix.\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction.\n   * @return Whether validator whitelist tally >= validator byzantine quorum\n   */\n  function isHotfixPassing(bytes32 hash) public view returns (bool) {\n    return hotfixWhitelistValidatorTally(hash) >= minQuorumSizeInCurrentSet();\n  }\n\n  /**\n   * @notice Gets information about a hotfix.\n   * @param hash The abi encoded keccak256 hash of the hotfix transaction.\n   * @return Hotfix approved.\n   * @return Hotfix executed.\n   * @return Hotfix preparedEpoch.\n   */\n  function getHotfixRecord(bytes32 hash) public view returns (bool, bool, uint256) {\n    return (hotfixes[hash].approved, hotfixes[hash].executed, hotfixes[hash].preparedEpoch);\n  }\n\n  /**\n   * @notice Removes the proposals with the most upvotes from the queue, moving them to the\n   *   approval stage.\n   * @dev If any of the top proposals have expired, they are deleted.\n   */\n  function dequeueProposalsIfReady() public {\n    // solhint-disable-next-line not-rely-on-time\n    if (now >= lastDequeue.add(dequeueFrequency)) {\n      uint256 numProposalsToDequeue = Math.min(concurrentProposals, queue.list.numElements);\n      uint256[] memory dequeuedIds = queue.popN(numProposalsToDequeue);\n\n      bool wasAnyProposalDequeued = false;\n      for (uint256 i = 0; i < numProposalsToDequeue; i = i.add(1)) {\n        uint256 proposalId = dequeuedIds[i];\n        Proposals.Proposal storage proposal = proposals[proposalId];\n        if (_isQueuedProposalExpired(proposal)) {\n          emit ProposalExpired(proposalId);\n          continue;\n        }\n        refundedDeposits[proposal.proposer] = refundedDeposits[proposal.proposer].add(\n          proposal.deposit\n        );\n        // solhint-disable-next-line not-rely-on-time\n        proposal.timestamp = now;\n        if (emptyIndices.length != 0) {\n          uint256 indexOfLastEmptyIndex = emptyIndices.length.sub(1);\n          dequeued[emptyIndices[indexOfLastEmptyIndex]] = proposalId;\n          delete emptyIndices[indexOfLastEmptyIndex];\n          emptyIndices.length = indexOfLastEmptyIndex;\n        } else {\n          dequeued.push(proposalId);\n        }\n        // solhint-disable-next-line not-rely-on-time\n        emit ProposalDequeued(proposalId, now);\n        wasAnyProposalDequeued = true;\n      }\n      if (wasAnyProposalDequeued) {\n        // solhint-disable-next-line not-rely-on-time\n        lastDequeue = now;\n      }\n    }\n  }\n\n  /**\n   * @notice Returns whether or not a proposal is in the queue.\n   * @dev NOTE: proposal may be expired\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the proposal is in the queue.\n   */\n  function isQueued(uint256 proposalId) public view returns (bool) {\n    return queue.contains(proposalId);\n  }\n\n  /**\n   * @notice Returns whether or not a particular proposal is passing according to the constitution\n   *   and the participation levels.\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the proposal is passing.\n   */\n  function isProposalPassing(uint256 proposalId) external view returns (bool) {\n    return _isProposalPassing(proposals[proposalId]);\n  }\n\n  /**\n   * @notice Returns whether or not a particular proposal is passing according to the constitution\n   *   and the participation levels.\n   * @param proposal The proposal struct.\n   * @return Whether or not the proposal is passing.\n   */\n  function _isProposalPassing(Proposals.Proposal storage proposal) private view returns (bool) {\n    FixidityLib.Fraction memory support = proposal.getSupportWithQuorumPadding(\n      participationParameters.baseline.multiply(participationParameters.baselineQuorumFactor)\n    );\n\n    if (proposal.transactions.length == 0) {\n      // default treshold\n      FixidityLib.Fraction memory threshold = _getConstitution(address(0), \"\");\n      return support.gt(threshold);\n    }\n\n    for (uint256 i = 0; i < proposal.transactions.length; i = i.add(1)) {\n      bytes4 functionId = ExtractFunctionSignature.extractFunctionSignature(\n        proposal.transactions[i].data\n      );\n      FixidityLib.Fraction memory threshold = _getConstitution(\n        proposal.transactions[i].destination,\n        functionId\n      );\n      if (support.lte(threshold)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @notice Returns whether a proposal is dequeued at the given index.\n   * @param proposalId The ID of the proposal.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @return Whether the proposal is in `dequeued`.\n   */\n  function isDequeuedProposal(uint256 proposalId, uint256 index) external view returns (bool) {\n    return _isDequeuedProposal(proposals[proposalId], proposalId, index);\n  }\n\n  /**\n   * @notice Returns whether a proposal is dequeued at the given index.\n   * @param proposal The proposal struct.\n   * @param proposalId The ID of the proposal.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @return Whether the proposal is in `dequeued` at index.\n   */\n  function _isDequeuedProposal(\n    Proposals.Proposal storage proposal,\n    uint256 proposalId,\n    uint256 index\n  ) private view returns (bool) {\n    require(index < dequeued.length, \"Provided index greater than dequeue length.\");\n    return proposal.exists() && dequeued[index] == proposalId;\n  }\n\n  /**\n   * @notice Returns whether or not a dequeued proposal has expired.\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the dequeued proposal has expired.\n   */\n  function isDequeuedProposalExpired(uint256 proposalId) external view returns (bool) {\n    Proposals.Proposal storage proposal = proposals[proposalId];\n    return _isDequeuedProposalExpired(proposal, getProposalDequeuedStage(proposal));\n  }\n\n  /**\n   * @notice Returns whether or not a dequeued proposal has expired.\n   * @param proposal The proposal struct.\n   * @return Whether or not the dequeued proposal has expired.\n   */\n  function _isDequeuedProposalExpired(Proposals.Proposal storage proposal, Proposals.Stage stage)\n    private\n    view\n    returns (bool)\n  {\n    // The proposal is considered expired under the following conditions:\n    //   1. Past the referendum stage and not passing.\n    //   2. Past the execution stage.\n    return ((stage > Proposals.Stage.Execution) ||\n      (stage > Proposals.Stage.Referendum && !_isProposalPassing(proposal)));\n  }\n\n  /**\n   * @notice Returns whether or not a queued proposal has expired.\n   * @param proposalId The ID of the proposal.\n   * @return Whether or not the dequeued proposal has expired.\n   */\n  function isQueuedProposalExpired(uint256 proposalId) public view returns (bool) {\n    return _isQueuedProposalExpired(proposals[proposalId]);\n  }\n\n  /**\n   * @notice Returns whether or not a queued proposal has expired.\n   * @param proposal The proposal struct.\n   * @return Whether or not the dequeued proposal has expired.\n   */\n  function _isQueuedProposalExpired(Proposals.Proposal storage proposal)\n    private\n    view\n    returns (bool)\n  {\n    // solhint-disable-next-line not-rely-on-time\n    return now >= proposal.timestamp.add(queueExpiry);\n  }\n\n  /**\n   * @notice Deletes a dequeued proposal.\n   * @param proposal The proposal struct.\n   * @param proposalId The ID of the proposal to delete.\n   * @param index The index of the proposal ID in `dequeued`.\n   * @dev Must always be preceded by `isDequeuedProposal`, which checks `index`.\n   */\n  function deleteDequeuedProposal(\n    Proposals.Proposal storage proposal,\n    uint256 proposalId,\n    uint256 index\n  ) private {\n    if (proposal.isApproved() && proposal.networkWeight != 0) {\n      updateParticipationBaseline(proposal);\n    }\n    dequeued[index] = 0;\n    emptyIndices.push(index);\n    delete proposals[proposalId];\n  }\n\n  /**\n   * @notice Updates the participation baseline based on the proportion of BondedDeposit weight\n   *   that participated in the proposal's Referendum stage.\n   * @param proposal The proposal struct.\n   */\n  function updateParticipationBaseline(Proposals.Proposal storage proposal) private {\n    FixidityLib.Fraction memory participation = proposal.getParticipation();\n    FixidityLib.Fraction memory participationComponent = participation.multiply(\n      participationParameters.baselineUpdateFactor\n    );\n    FixidityLib.Fraction memory baselineComponent = participationParameters.baseline.multiply(\n      FixidityLib.fixed1().subtract(participationParameters.baselineUpdateFactor)\n    );\n    participationParameters.baseline = participationComponent.add(baselineComponent);\n    if (participationParameters.baseline.lt(participationParameters.baselineFloor)) {\n      participationParameters.baseline = participationParameters.baselineFloor;\n    }\n    emit ParticipationBaselineUpdated(participationParameters.baseline.unwrap());\n  }\n\n  /**\n   * @notice Returns the constitution for a particular destination and function ID.\n   * @param destination The destination address to get the constitution for.\n   * @param functionId The function ID to get the constitution for, zero for the destination\n   *   default.\n   * @return The ratio of yes:no votes needed to exceed in order to pass the proposal.\n   */\n  function getConstitution(address destination, bytes4 functionId) external view returns (uint256) {\n    return _getConstitution(destination, functionId).unwrap();\n  }\n\n  function _getConstitution(address destination, bytes4 functionId)\n    internal\n    view\n    returns (FixidityLib.Fraction memory)\n  {\n    // Default to a simple majority.\n    FixidityLib.Fraction memory threshold = FixidityLib.wrap(FIXED_HALF);\n    if (constitution[destination].functionThresholds[functionId].unwrap() != 0) {\n      threshold = constitution[destination].functionThresholds[functionId];\n    } else if (constitution[destination].defaultThreshold.unwrap() != 0) {\n      threshold = constitution[destination].defaultThreshold;\n    }\n    return threshold;\n  }\n\n  /**\n   * @notice Returns max number of votes cast by an account.\n   * @param account The address of the account.\n   * @return The total number of votes cast by an account.\n   */\n  function getAmountOfGoldUsedForVoting(address account) public view returns (uint256) {\n    Voter storage voter = voters[account];\n\n    uint256 upvotedProposalId = voter.upvote.proposalId;\n    bool isVotingQueue = upvotedProposalId != 0 &&\n      isQueued(upvotedProposalId) &&\n      !isQueuedProposalExpired(upvotedProposalId);\n\n    if (isVotingQueue) {\n      uint256 weight = getLockedGold().getAccountTotalLockedGold(account);\n      return weight;\n    }\n\n    uint256 maxUsed = 0;\n    for (uint256 index = 0; index < dequeued.length; index = index.add(1)) {\n      Proposals.Proposal storage proposal = proposals[dequeued[index]];\n      bool isVotingReferendum = (getProposalDequeuedStage(proposal) == Proposals.Stage.Referendum);\n\n      if (!isVotingReferendum) {\n        continue;\n      }\n\n      VoteRecord storage voteRecord = voter.referendumVotes[index];\n      uint256 votesCast = voteRecord.yesVotes.add(voteRecord.noVotes).add(voteRecord.abstainVotes);\n      maxUsed = Math.max(\n        maxUsed,\n        // backward compatibility for transition period - this should be updated later on\n        votesCast == 0 ? voteRecord.deprecated_weight : votesCast\n      );\n    }\n    return maxUsed;\n  }\n\n  /**\n   * @notice When delegator removes votes from delegatee during the time when delegator is voting\n   * for governance proposal, this method will remove votes from voted proposal proportionally.\n   * @param account The address of the account.\n   * @param newVotingPower The adjusted voting power of delegatee.\n   */\n  function removeVotesWhenRevokingDelegatedVotes(address account, uint256 newVotingPower)\n    public\n    onlyLockedGold\n  {\n    _removeVotesWhenRevokingDelegatedVotes(account, newVotingPower);\n  }\n\n  /**\n   * @notice When delegator removes votes from delegatee during the time when delegator is voting\n   * for governance proposal, this method will remove votes from voted proposal proportionally.\n   * @param account The address of the account.\n   * @param newVotingPower The adjusted voting power of delegatee.\n   */\n  function _removeVotesWhenRevokingDelegatedVotes(address account, uint256 newVotingPower)\n    internal\n  {\n    Voter storage voter = voters[account];\n\n    for (uint256 index = 0; index < dequeued.length; index = index.add(1)) {\n      Proposals.Proposal storage proposal = proposals[dequeued[index]];\n      bool isVotingReferendum = (getProposalDequeuedStage(proposal) == Proposals.Stage.Referendum);\n\n      if (!isVotingReferendum) {\n        continue;\n      }\n\n      VoteRecord storage voteRecord = voter.referendumVotes[index];\n      uint256 sumOfVotes = voteRecord.yesVotes.add(voteRecord.noVotes).add(voteRecord.abstainVotes);\n\n      if (sumOfVotes > newVotingPower) {\n        uint256 toRemove = sumOfVotes.sub(newVotingPower);\n\n        uint256 abstainToRemove = getVotesPortion(toRemove, voteRecord.abstainVotes, sumOfVotes);\n        uint256 yesToRemove = getVotesPortion(toRemove, voteRecord.yesVotes, sumOfVotes);\n        uint256 noToRemove = getVotesPortion(toRemove, voteRecord.noVotes, sumOfVotes);\n\n        uint256 totalRemoved = abstainToRemove.add(yesToRemove).add(noToRemove);\n\n        uint256 yesVotes = voteRecord.yesVotes.sub(yesToRemove);\n        uint256 noVotes = voteRecord.noVotes.sub(noToRemove);\n        uint256 abstainVotes = voteRecord.abstainVotes.sub(abstainToRemove);\n\n        if (totalRemoved < toRemove) {\n          // in case of rounding error\n          uint256 roundingToRemove = toRemove.sub(totalRemoved);\n\n          uint256 toRemoveRounding = Math.min(roundingToRemove, yesVotes);\n          yesVotes = yesVotes.sub(toRemoveRounding);\n          roundingToRemove = roundingToRemove.sub(toRemoveRounding);\n\n          if (roundingToRemove != 0) {\n            toRemoveRounding = Math.min(roundingToRemove, noVotes);\n            noVotes = noVotes.sub(toRemoveRounding);\n            roundingToRemove = roundingToRemove.sub(toRemoveRounding);\n          }\n\n          if (roundingToRemove != 0) {\n            toRemoveRounding = Math.min(roundingToRemove, abstainVotes);\n            abstainVotes = abstainVotes.sub(toRemoveRounding);\n          }\n        }\n\n        proposal.updateVote(\n          voteRecord.yesVotes,\n          voteRecord.noVotes,\n          voteRecord.abstainVotes,\n          yesVotes,\n          noVotes,\n          abstainVotes\n        );\n\n        voteRecord.abstainVotes = abstainVotes;\n        voteRecord.yesVotes = yesVotes;\n        voteRecord.noVotes = noVotes;\n      }\n    }\n  }\n\n  /**\n   * Returns amount of votes that should be removed from delegatee's proposal voting.\n   * @param totalToRemove Total votes to be removed.\n   * @param votes Yes/no/abstrain votes\n   * @param sumOfAllVotes Sum of yes, no, and abstain votes.\n   */\n  function getVotesPortion(uint256 totalToRemove, uint256 votes, uint256 sumOfAllVotes)\n    private\n    pure\n    returns (uint256)\n  {\n    return\n      FixidityLib\n        .newFixed(totalToRemove)\n        .multiply(FixidityLib.newFixedFraction(votes, sumOfAllVotes))\n        .fromFixed();\n  }\n\n  /**\n   * @param values The values of CELO to be sent in the proposed transactions.\n   * @param destinations The destination addresses of the proposed transactions.\n   * @param data The concatenated data to be included in the proposed transactions.\n   * @param dataLengths The lengths of each transaction's data.\n   * @param salt Arbitrary salt associated with hotfix which guarantees uniqueness of hash.\n   * @return The hash of the hotfix.\n   */\n  function getHotfixHash(\n    uint256[] calldata values,\n    address[] calldata destinations,\n    bytes calldata data,\n    uint256[] calldata dataLengths,\n    bytes32 salt\n  ) external pure returns (bytes32) {\n    return keccak256(abi.encode(values, destinations, data, dataLengths, salt));\n  }\n\n  /**\n   * @notice Returns the stage of a dequeued proposal.\n   * @param proposal The proposal struct.\n   * @return The stage of the dequeued proposal.\n   * @dev Must be called on a dequeued proposal.\n   */\n  function getProposalDequeuedStage(Proposals.Proposal storage proposal)\n    internal\n    view\n    returns (Proposals.Stage)\n  {\n    uint256 stageStartTime = proposal.timestamp.add(stageDurations.referendum).add(\n      stageDurations.execution\n    );\n    // solhint-disable-next-line not-rely-on-time\n    if (\n      now >= stageStartTime &&\n      (proposal.transactions.length != 0 ||\n        // proposals with 0 transactions can expire only when not approved or not passing\n        !proposal.isApproved() ||\n        !_isProposalPassing(proposal))\n    ) {\n      return Proposals.Stage.Expiration;\n    }\n    stageStartTime = stageStartTime.sub(stageDurations.execution);\n    // solhint-disable-next-line not-rely-on-time\n    if (now >= stageStartTime) {\n      return Proposals.Stage.Execution;\n    }\n    return Proposals.Stage.Referendum;\n  }\n}\n",
        "formal_property": "invariant dequeuedIsWithinRange(uint i) getFromDequeued(i) <= proposalCount()\n\n\n// upvoting\nrule upvotesConsistency(address u, method f) filtered { f -> !f.isView } {\n    uint _p;",
        "nl_summary": "",
        "metadata": {
            "rule_name": "dequeuedIsWithinRange",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "Governance_referendumVoteIDIsLessThanOrEqCounter",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "Governance.sol",
        "target_function": "vote",
        "text_chunk": "function vote(uint256 proposalId, uint256 index, Proposals.VoteValue value)\n    external\n    nonReentrant\n    returns (bool)\n  {\n    dequeueProposalsIfReady();\n    (Proposals.Proposal storage proposal, Proposals.Stage stage) = requireDequeuedAndDeleteExpired(\n      proposalId,\n      index\n    );\n    if (!proposal.exists()) {\n      return false;\n    }",
        "formal_property": "invariant referendumVoteIDIsLessThanOrEqCounter(address v, uint p) votedFor(v,p) => p <= proposalCount() {\n    preserved vote(uint256 _, uint256 indx, uint8 vr) with (env e) {\n        requireInvariant dequeuedIsWithinRange(indx);",
        "nl_summary": "",
        "metadata": {
            "rule_name": "referendumVoteIDIsLessThanOrEqCounter",
            "rule_type": "INVARIANT"
        }
    }
]