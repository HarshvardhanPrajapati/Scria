[
    {
        "id": "GovernorCountingSimple_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\n\nabstract contract GovernorCountingSimple is Governor {\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    function proposalVotes(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);\n    }\n\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= proposalvote.forVotes + proposalvote.abstainVotes;\n    }\n\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return proposalvote.forVotes > proposalvote.againstVotes;\n    }\n\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory\n    ) internal virtual override {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        require(!proposalvote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");\n        proposalvote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalvote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalvote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalvote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "COUNTING_MODE",
                "hasVoted",
                "proposalVotes",
                "_quorumReached",
                "_voteSucceeded",
                "_countVote"
            ],
            "state_variables": [
                "forVotes",
                "againstVotes",
                "_proposalVotes",
                "abstainVotes",
                "hasVoted"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "GovernorCountingSimple_SumOfVotesCastEqualSumOfPowerOfVotedPerProposal_3cc6e1a5",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "hasVoted",
        "text_chunk": "    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n",
        "formal_property": "invariant SumOfVotesCastEqualSumOfPowerOfVotedPerProposal(uint256 pId) \n\ttracked_weight(pId) == ghost_sum_vote_power_by_id(pId)\n\n/*\n * sum of all votes casted is equal to the sum of voting power of those who voted\n */\ninvariant SumOfVotesCastEqualSumOfPowerOfVoted() \n\tsum_tracked_weight() == sum_all_votes_power()\n* sum of all votes casted is greater or equal to the sum of voting power of those who voted at a specific proposal\n*/\ninvariant OneIsNotMoreThanAll(uint256 pId) \n\tsum_all_votes_power() >= tracked_weight(pId)\n//////////////////////////////////////////////////////////////////////////////\n///////////////////////////////// RULES //////////////////////////////////////\n * Only sender's voting status can be changed by execution of any cast vote function\n// Checked for castVote only. all 3 castVote functions call _castVote, so the completeness of the verification is counted on\n // the fact that the 3 functions themselves makes no changes, but rather call an internal function to execute.\n // That means that we do not check those 3 functions directly, however for castVote & castVoteWithReason it is quite trivial\n // to understand why this is ok. For castVoteBySig we basically assume that the signature referendum is correct without checking it.\n // We could check each function separately and pass the rule, but that would have uglyfied the code with no concrete \n // benefit, as it is evident that nothing is happening in the first 2 functions (calling a view function), and we do not desire to check the signature verification.\nrule noVoteForSomeoneElse(uint256 pId, uint8 sup, method f) {\n    env e; calldataarg args;\n    address voter = e.msg.sender;\n    address user;\n    bool hasVotedBefore_User = hasVoted(e, pId, user);\n    castVote@withrevert(e, pId, sup);\n    require(!lastReverted);\n    bool hasVotedAfter_User = hasVoted(e, pId, user);\n    assert user != voter => hasVotedBefore_User == hasVotedAfter_User;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "SumOfVotesCastEqualSumOfPowerOfVotedPerProposal",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "ghost_sum_vote_power_by_id"
            ],
            "start_line": 100,
            "end_line": 146,
            "block_hash": "3cc6e1a598a5ba7e312b46c014f7285b"
        }
    },
    {
        "id": "GovernorCountingSimple_noVoteForSomeoneElse_58a3768c",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "hasVoted",
        "text_chunk": "    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n",
        "formal_property": "rule noVoteForSomeoneElse(uint256 pId, uint8 sup, method f) {\n    env e; calldataarg args;\n\n    address voter = e.msg.sender;\n    address user;\n    bool hasVotedBefore_User = hasVoted(e, pId, user);\n    castVote@withrevert(e, pId, sup);\n    require(!lastReverted);\n    bool hasVotedAfter_User = hasVoted(e, pId, user);\n    assert user != voter => hasVotedBefore_User == hasVotedAfter_User;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "noVoteForSomeoneElse",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 132,
            "end_line": 146,
            "block_hash": "58a3768c1f3192f9e2346197ad30efc4"
        }
    },
    {
        "id": "GovernorCountingSimple_votingWeightMonotonicity_f9744902",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\n\nabstract contract GovernorCountingSimple is Governor {\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    function proposalVotes(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);\n    }\n\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= proposalvote.forVotes + proposalvote.abstainVotes;\n    }\n\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return proposalvote.forVotes > proposalvote.againstVotes;\n    }\n\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory\n    ) internal virtual override {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        require(!proposalvote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");\n        proposalvote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalvote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalvote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalvote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n}",
        "formal_property": "rule votingWeightMonotonicity(method f){\n    uint256 votingWeightBefore = sum_tracked_weight();\n\n    env e; \n    calldataarg args;\n    f(e, args);\n    uint256 votingWeightAfter = sum_tracked_weight();\n    assert votingWeightBefore <= votingWeightAfter, \"Voting weight was decreased somehow\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "votingWeightMonotonicity",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 152,
            "end_line": 162,
            "block_hash": "f9744902ef7e23d70e0d4813cef47589"
        }
    },
    {
        "id": "GovernorCountingSimple_hasVotedCorrelation_aedb2280",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "hasVoted",
        "text_chunk": "    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n",
        "formal_property": "rule hasVotedCorrelation(uint256 pId, method f, env e, uint256 bn) {\n    address acc = e.msg.sender;\n    \n    uint256 againstBefore = votesAgainst();\n    uint256 forBefore = votesFor();\n    uint256 abstainBefore = votesAbstain();\n\n    bool hasVotedBefore = hasVoted(e, pId, acc);\n    helperFunctionsWithRevert(pId, f, e);\n    require(!lastReverted);\n    uint256 againstAfter = votesAgainst();\n    uint256 forAfter = votesFor();\n    uint256 abstainAfter = votesAbstain();\n    bool hasVotedAfter = hasVoted(e, pId, acc);\n    // want all vote categories to not decrease and at least one category to increase\n    assert (!hasVotedBefore && hasVotedAfter) => (againstBefore <= againstAfter && forBefore <= forAfter && abstainBefore <= abstainAfter), \"no correlation: some category decreased\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "hasVotedCorrelation",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 168,
            "end_line": 188,
            "block_hash": "aedb2280c240a0ed78397f4d5813e7fd"
        }
    },
    {
        "id": "GovernorCountingSimple_privilegedOnlyNumerator_21ee4bc4",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\n\nabstract contract GovernorCountingSimple is Governor {\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    function proposalVotes(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);\n    }\n\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= proposalvote.forVotes + proposalvote.abstainVotes;\n    }\n\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return proposalvote.forVotes > proposalvote.againstVotes;\n    }\n\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory\n    ) internal virtual override {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        require(!proposalvote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");\n        proposalvote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalvote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalvote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalvote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n}",
        "formal_property": "rule privilegedOnlyNumerator(method f, uint256 newQuorumNumerator){\n    env e;\n    calldataarg arg;\n    uint256 quorumNumBefore = quorumNumerator(e);\n\n    f(e, arg);\n    uint256 quorumNumAfter = quorumNumerator(e);\n    address executorCheck = getExecutor(e);\n    assert quorumNumBefore != quorumNumAfter => e.msg.sender == executorCheck, \"non privileged user changed quorum numerator\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "privilegedOnlyNumerator",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "quorum",
                "quorumNumerator",
                "getExecutor"
            ],
            "start_line": 194,
            "end_line": 205,
            "block_hash": "21ee4bc4be4e4407f38c365bb5a1bb58"
        }
    },
    {
        "id": "GovernorCountingSimple_privilegedOnlyTimelock_2d2fc4d5",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\n\nabstract contract GovernorCountingSimple is Governor {\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    function proposalVotes(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);\n    }\n\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= proposalvote.forVotes + proposalvote.abstainVotes;\n    }\n\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return proposalvote.forVotes > proposalvote.againstVotes;\n    }\n\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory\n    ) internal virtual override {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        require(!proposalvote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");\n        proposalvote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalvote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalvote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalvote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n}",
        "formal_property": "rule privilegedOnlyTimelock(method f, uint256 newQuorumNumerator){\n    env e;\n    calldataarg arg;\n    uint256 timelockBefore = timelock(e);\n\n    f(e, arg);\n    uint256 timelockAfter = timelock(e);\n    assert timelockBefore != timelockAfter => e.msg.sender == timelockBefore, \"non privileged user changed timelock\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "privilegedOnlyTimelock",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "timelock"
            ],
            "start_line": 207,
            "end_line": 217,
            "block_hash": "2d2fc4d516a0fbe6bffd4979cbf2a6db"
        }
    }
]