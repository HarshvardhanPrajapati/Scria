[
    {
        "id": "GovernorCountingSimple_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\n\nabstract contract GovernorCountingSimple is Governor {\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    function proposalVotes(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);\n    }\n\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= proposalvote.forVotes + proposalvote.abstainVotes;\n    }\n\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return proposalvote.forVotes > proposalvote.againstVotes;\n    }\n\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory\n    ) internal virtual override {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        require(!proposalvote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");\n        proposalvote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalvote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalvote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalvote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n}",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "COUNTING_MODE",
                "hasVoted",
                "proposalVotes",
                "_quorumReached",
                "_voteSucceeded",
                "_countVote"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "GovernorCountingSimple_SumOfVotesCastEqualSumOfPowerOfVotedPerProposal",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GovernorCountingSimple.sol",
        "target_function": "ALL",
        "text_chunk": "pragma solidity ^0.8.0;\n\nimport \"../Governor.sol\";\n\nabstract contract GovernorCountingSimple is Governor {\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    function proposalVotes(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);\n    }\n\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return quorum(proposalSnapshot(proposalId)) <= proposalvote.forVotes + proposalvote.abstainVotes;\n    }\n\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return proposalvote.forVotes > proposalvote.againstVotes;\n    }\n\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory\n    ) internal virtual override {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        require(!proposalvote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");\n        proposalvote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalvote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalvote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalvote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n}",
        "formal_property": "invariant SumOfVotesCastEqualSumOfPowerOfVotedPerProposal(uint256 pId) \n\ttracked_weight(pId) == ghost_sum_vote_power_by_id(pId)\n\n\n/*\n * sum of all votes casted is equal to the sum of voting power of those who voted\n */\ninvariant SumOfVotesCastEqualSumOfPowerOfVoted() \n\tsum_tracked_weight() == sum_all_votes_power()\n\n\n/*\n* sum of all votes casted is greater or equal to the sum of voting power of those who voted at a specific proposal\n*/\ninvariant OneIsNotMoreThanAll(uint256 pId) \n\tsum_all_votes_power() >= tracked_weight(pId)\n\n\n//////////////////////////////////////////////////////////////////////////////\n///////////////////////////////// RULES //////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////\n\n\n/*\n * Only sender's voting status can be changed by execution of any cast vote function\n */\n// Checked for castVote only. all 3 castVote functions call _castVote, so the completeness of the verification is counted on\n // the fact that the 3 functions themselves makes no changes, but rather call an internal function to execute.\n // That means that we do not check those 3 functions directly, however for castVote & castVoteWithReason it is quite trivial\n // to understand why this is ok. For castVoteBySig we basically assume that the signature referendum is correct without checking it.\n // We could check each function separately and pass the rule, but that would have uglyfied the code with no concrete \n // benefit, as it is evident that nothing is happening in the first 2 functions (calling a view function), and we do not desire to check the signature verification.\nrule noVoteForSomeoneElse(uint256 pId, uint8 sup, method f) {\n    env e;",
        "nl_summary": "",
        "metadata": {
            "rule_name": "SumOfVotesCastEqualSumOfPowerOfVotedPerProposal",
            "rule_type": "INVARIANT"
        }
    }
]