[
    {
        "id": "GhoToken_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "mint",
                "burn",
                "addFacilitator",
                "removeFacilitator",
                "setFacilitatorBucketCapacity",
                "getFacilitator",
                "getFacilitatorBucket",
                "getFacilitatorsList"
            ],
            "state_variables": [
                "_facilitatorsList",
                "_facilitators"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "GhoToken_length_leq_max_uint160_d4265876",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t{\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "length_leq_max_uint160",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "totalSupply",
                "balanceOf"
            ],
            "start_line": 64,
            "end_line": 77,
            "block_hash": "d4265876e9935163545eec17dd6f410b"
        }
    },
    {
        "id": "GhoToken_total_supply_eq_sumAllLevel_0b9483f7",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "burn",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "invariant total_supply_eq_sumAllLevel()\n\t\tsumAllLevel() == totalSupply() \n\t{\n\t  preserved burn(uint256 amount) with (env e){\n\t\t\trequireInvariant inv_balanceOf_leq_totalSupply(e.msg.sender);\n\t\t}\n\t}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "total_supply_eq_sumAllLevel",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "burn",
                "totalSupply",
                "balanceOf"
            ],
            "start_line": 83,
            "end_line": 89,
            "block_hash": "0b9483f75c803592d6efc2c806284deb"
        }
    },
    {
        "id": "GhoToken_sumAllBalance_eq_totalSupply_5a21a7b8",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t{\n\t\tpreserved {\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sumAllBalance_eq_totalSupply",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "totalSupply"
            ],
            "start_line": 98,
            "end_line": 104,
            "block_hash": "5a21a7b8f56ec93f6b402148e8ee5733"
        }
    },
    {
        "id": "GhoToken_can_1c23451c",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "burn",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": " * @dev This invariant can be deduced from sumAllBalance_eq_totalSupply and total_supply_eq_sumAllLevel\ninvariant total_supply_eq_sumAllLevel()\n\t\tsumAllLevel() == totalSupply() \n\t{\n\t  preserved burn(uint256 amount) with (env e){\n\t\t\trequireInvariant inv_balanceOf_leq_totalSupply(e.msg.sender);\n\t\t}\n\t}\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n * @dev requireInvariant of EITHER sumAllBalance_eq_totalSupply() OR total_supply_eq_sumAllLevel() suffuces for the proof\n **/\ninvariant sumAllLevel_eq_sumAllBalance()\n\tsumAllLevel() == sumAllBalance()\n\t  \t{\n\t\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "can",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "totalSupply"
            ],
            "start_line": 109,
            "end_line": 118,
            "block_hash": "1c23451c40429a90d43151560b8ed6bd"
        }
    },
    {
        "id": "GhoToken_inv_valid_capacity_ed2fbfad",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant inv_valid_capacity(address facilitator)\n\t((getFacilitatorBucketCapacity(facilitator)>0) => is_in_facilitator_mapping(facilitator) )\n\n// INV #7\n/**\n* @title A facilitator with a positive bucket level exists in the _facilitators mapping\n*/\ninvariant inv_valid_level(address facilitator)\n\t((getFacilitatorBucketLevel(facilitator)>0) => is_in_facilitator_mapping(facilitator) )\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant inv_valid_capacity(facilitator);\n\t\t}\n\t}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "inv_valid_capacity",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "getFacilitatorBucketLevel",
                "getFacilitatorBucketCapacity",
                "is_in_facilitator_mapping"
            ],
            "start_line": 126,
            "end_line": 139,
            "block_hash": "ed2fbfad709b636f7ac9a70d5611ebbe"
        }
    },
    {
        "id": "GhoToken_address_in_set_values_iff_in_set_indexes_0799d206",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant address_in_set_values_iff_in_set_indexes(address facilitator)\n\tis_in_facilitator_set_array(facilitator) <=> is_in_facilitator_set_map(facilitator)\n\t{preserved{\n\t\trequireInvariant addressSetInvariant();\ninvariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\t\trequireInvariant length_leq_max_uint160();\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "address_in_set_values_iff_in_set_indexes",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "is_in_facilitator_set_map",
                "is_in_facilitator_set_array"
            ],
            "start_line": 147,
            "end_line": 153,
            "block_hash": "0799d206eb978bbd7fe77339b7351c06"
        }
    },
    {
        "id": "GhoToken_addr_in_set_iff_in_map_00cbe730",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant addr_in_set_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)\n\t{preserved{\n \t\trequireInvariant addressSetInvariant();\ninvariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "addr_in_set_iff_in_map",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "is_in_facilitator_mapping",
                "is_in_facilitator_set_map"
            ],
            "start_line": 161,
            "end_line": 167,
            "block_hash": "00cbe730a1fff3c9e79befdb439e7b69"
        }
    },
    {
        "id": "GhoToken_addr_in_set_list_iff_in_map_425bdea5",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant addr_in_set_list_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_array(facilitator)\n\t{preserved{\n\t\trequireInvariant addressSetInvariant();\ninvariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\t\trequireInvariant length_leq_max_uint160();\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "addr_in_set_list_iff_in_map",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [
                "is_in_facilitator_mapping",
                "is_in_facilitator_set_array"
            ],
            "start_line": 175,
            "end_line": 181,
            "block_hash": "425bdea51fedb31e5f91dcfd9f8eefd0"
        }
    },
    {
        "id": "GhoToken_ARRAY_IS_INVERSE_OF_MAP_Invariant_8e78d164",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant ARRAY_IS_INVERSE_OF_MAP_Invariant()\n    ARRAY_IS_INVERSE_OF_MAP()\n\t{\n\t\tpreserved{\n\t\t\trequire ADDRESS_SET_INVARIANT();\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "ARRAY_IS_INVERSE_OF_MAP_Invariant",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 501,
            "end_line": 508,
            "block_hash": "8e78d164bd83009c93f384e3de377547"
        }
    },
    {
        "id": "GhoToken_addressSetInvariant_20a22f8a",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "addressSetInvariant",
            "rule_type": "invariant",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 511,
            "end_line": 517,
            "block_hash": "20a22f8a805c5d3ad2b62ba6c0cdef08"
        }
    },
    {
        "id": "GhoToken_level_leq_capacity_60e5ce70",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "rule level_leq_capacity(address facilitator, method f) filtered {f -> !f.isView}{\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "level_leq_capacity",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 192,
            "end_line": 192,
            "block_hash": "60e5ce70f554e0c886eb5f153db66001"
        }
    },
    {
        "id": "GhoToken_mint_after_burn_b9da6fc1",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "burn/mint",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule mint_after_burn(method f) filtered {f -> !f.isView}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "mint_after_burn",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint",
                "burn"
            ],
            "start_line": 208,
            "end_line": 208,
            "block_hash": "b9da6fc11ea00767683782435e750f3d"
        }
    },
    {
        "id": "GhoToken_burn_after_mint_3d9d2532",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "burn/mint",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule burn_after_mint(method f) filtered {f -> !f.isView}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burn_after_mint",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint",
                "burn"
            ],
            "start_line": 239,
            "end_line": 239,
            "block_hash": "3d9d253248012cb2cb5e1c9e635a319d"
        }
    },
    {
        "id": "GhoToken_level_unchanged_after_mint_followed_by_burn_baffa955",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "burn/mint",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule level_unchanged_after_mint_followed_by_burn()\n{\n\tenv e;\n\tcalldataarg arg;\n\tuint256 amount;\n\taddress account;\n\n\tuint256 levelBefore = getFacilitatorBucketLevel(e.msg.sender);\n\tmint(e, account, amount);\n\tburn(e, amount);\n\tuint256 leveAfter = getFacilitatorBucketLevel(e.msg.sender);\n\tassert levelBefore == leveAfter;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "level_unchanged_after_mint_followed_by_burn",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint",
                "burn",
                "getFacilitatorBucketLevel"
            ],
            "start_line": 259,
            "end_line": 272,
            "block_hash": "baffa95500f7eace70b243b152133106"
        }
    },
    {
        "id": "GhoToken_level_after_mint_234348cd",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "mint",
        "text_chunk": "  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule level_after_mint()\n{\n\tenv e;\n\tcalldataarg arg;\n\tuint256 amount;\n\taddress account;\n\n\tuint256 levelBefore = getFacilitatorBucketLevel(e.msg.sender);\n\tmint(e, account, amount);\n\tuint256 leveAfter = getFacilitatorBucketLevel(e.msg.sender);\n\tassert levelBefore + amount == leveAfter;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "level_after_mint",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint",
                "getFacilitatorBucketLevel"
            ],
            "start_line": 274,
            "end_line": 286,
            "block_hash": "234348cd997cf2b6967024b26ea3ab08"
        }
    },
    {
        "id": "GhoToken_level_after_burn_bce62ac6",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "burn",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule level_after_burn()\n{\n\tenv e;\n\tcalldataarg arg;\n\tuint256 amount;\n\n\tuint256 levelBefore = getFacilitatorBucketLevel(e.msg.sender);\n\tburn(e, amount);\n\tuint256 leveAfter = getFacilitatorBucketLevel(e.msg.sender);\n\tassert levelBefore == leveAfter + amount;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "level_after_burn",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "burn",
                "getFacilitatorBucketLevel"
            ],
            "start_line": 288,
            "end_line": 299,
            "block_hash": "bce62ac6f7fb177be1a94eb9db0ecaef"
        }
    },
    {
        "id": "GhoToken_facilitator_in_list_after_setFacilitatorBucketCapacity_2d1ea76c",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "setFacilitatorBucketCapacity",
        "text_chunk": "  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n",
        "formal_property": "rule facilitator_in_list_after_setFacilitatorBucketCapacity(){\n\n\tenv e;\n\taddress facilitator;\n\tuint128 newCapacity;\n\trequireInvariant addr_in_set_iff_in_map(facilitator);\ninvariant addr_in_set_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)\n\t{preserved{\n \t\trequireInvariant addressSetInvariant();\ninvariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\trequireInvariant addr_in_set_list_iff_in_map(facilitator);\ninvariant addr_in_set_list_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_array(facilitator)\n\t\trequireInvariant addressSetInvariant();\n\t\trequireInvariant length_leq_max_uint160();\n\tsetFacilitatorBucketCapacity(e, facilitator, newCapacity);\n\t\n\tassert is_in_facilitator_set_map(facilitator);\n\tassert is_in_facilitator_set_array(facilitator);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "facilitator_in_list_after_setFacilitatorBucketCapacity",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "setFacilitatorBucketCapacity",
                "is_in_facilitator_set_map",
                "is_in_facilitator_set_array"
            ],
            "start_line": 305,
            "end_line": 318,
            "block_hash": "2d1ea76c9b8e22a8e390ae19193292fd"
        }
    },
    {
        "id": "GhoToken_getFacilitatorBucketCapacity_after_setFacilitatorBucketCapacity_4f6a552d",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "setFacilitatorBucketCapacity",
        "text_chunk": "  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n",
        "formal_property": "rule getFacilitatorBucketCapacity_after_setFacilitatorBucketCapacity(){\n\n\tenv e;\n\taddress facilitator;\n\tuint128 newCapacity;\n\tsetFacilitatorBucketCapacity(e, facilitator, newCapacity);\n\tassert getFacilitatorBucketCapacity(facilitator) == newCapacity;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "getFacilitatorBucketCapacity_after_setFacilitatorBucketCapacity",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "setFacilitatorBucketCapacity",
                "getFacilitatorBucketCapacity"
            ],
            "start_line": 323,
            "end_line": 331,
            "block_hash": "4f6a552d1503167fb8f86605430a1f5f"
        }
    },
    {
        "id": "GhoToken_facilitator_in_list_after_addFacilitator_9026b774",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "addFacilitator",
        "text_chunk": "  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n",
        "formal_property": "rule facilitator_in_list_after_addFacilitator(){\n\n\tenv e;\n\taddress facilitator;\n\tstring label;\n\tuint128 capacity;\n\trequireInvariant addr_in_set_iff_in_map(facilitator);\ninvariant addr_in_set_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)\n\t{preserved{\n \t\trequireInvariant addressSetInvariant();\ninvariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\t\n\taddFacilitator(e,facilitator, label, capacity);\n\tassert is_in_facilitator_set_map(facilitator);\n\tassert is_in_facilitator_set_array(facilitator);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "facilitator_in_list_after_addFacilitator",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "is_in_facilitator_set_map",
                "is_in_facilitator_set_array"
            ],
            "start_line": 336,
            "end_line": 349,
            "block_hash": "9026b7749b67874c376debb54dd5abc5"
        }
    },
    {
        "id": "GhoToken_facilitator_in_list_after_mint_and_burn_c1fabe9f",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "burn/mint",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule facilitator_in_list_after_mint_and_burn(method f){\n\n\tenv e;\n\tcalldataarg args;\n\trequireInvariant inv_valid_capacity(e.msg.sender);\ninvariant inv_valid_capacity(address facilitator)\n\t((getFacilitatorBucketCapacity(facilitator)>0) => is_in_facilitator_mapping(facilitator) )\n// INV #7\n/**\n* @title A facilitator with a positive bucket level exists in the _facilitators mapping\n*/\ninvariant inv_valid_level(address facilitator)\n\t((getFacilitatorBucketLevel(facilitator)>0) => is_in_facilitator_mapping(facilitator) )\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant inv_valid_capacity(facilitator);\n\t\t}\n\t}\n\trequireInvariant inv_valid_level(e.msg.sender);\n\trequireInvariant addr_in_set_iff_in_map(e.msg.sender);\ninvariant addr_in_set_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)\n\t{preserved{\n \t\trequireInvariant addressSetInvariant();\ninvariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n// INV #2\n* @title User's balance not greater than totalSupply()\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\trequireInvariant addr_in_set_list_iff_in_map(e.msg.sender);\ninvariant addr_in_set_list_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_array(facilitator)\n\t\trequireInvariant addressSetInvariant();\n\t\trequireInvariant length_leq_max_uint160();\n\tf(e,args);\n\tassert (((f.selector == mint(address,uint256).selector) || (f.selector == burn(uint256).selector)) => is_in_facilitator_mapping(e.msg.sender));\n\tassert (((f.selector == mint(address,uint256).selector) || (f.selector == burn(uint256).selector)) => is_in_facilitator_set_map(e.msg.sender));\n\tassert (((f.selector == mint(address,uint256).selector) || (f.selector == burn(uint256).selector)) => is_in_facilitator_set_array(e.msg.sender));\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "facilitator_in_list_after_mint_and_burn",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint",
                "burn",
                "is_in_facilitator_mapping",
                "is_in_facilitator_set_map",
                "is_in_facilitator_set_array"
            ],
            "start_line": 354,
            "end_line": 367,
            "block_hash": "c1fabe9fa9651ea77225ce2c3dd36300"
        }
    },
    {
        "id": "GhoToken_address_not_in_list_after_removeFacilitator_22068bfb",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "removeFacilitator",
        "text_chunk": "  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n",
        "formal_property": "rule address_not_in_list_after_removeFacilitator(address facilitator){\n\tenv e;\n\trequireInvariant addressSetInvariant();\ninvariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\trequireInvariant length_leq_max_uint160();\n\trequireInvariant addr_in_set_iff_in_map(facilitator);\ninvariant addr_in_set_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)\n\t{preserved{\n \t\trequireInvariant addressSetInvariant();\n\tremoveFacilitator(e, facilitator);\n\tassert !is_in_facilitator_set_array(facilitator);\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "address_not_in_list_after_removeFacilitator",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "removeFacilitator",
                "is_in_facilitator_set_array"
            ],
            "start_line": 372,
            "end_line": 379,
            "block_hash": "22068bfbcf2ffe3cb9b8458131b1ba35"
        }
    },
    {
        "id": "GhoToken_mintIsAdditive_5f734ad8",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "mint",
        "text_chunk": "  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "// rule mintIsAdditive() {\n// \taddress user1;\n// \taddress user2;\n// \trequire (user1 != user2);\n// \tuint256 initBalance1 = balanceOf(user1);\n// \tuint256 initBalance2 = balanceOf(user2);\n// \trequire (sumAllBalance() >= initBalance1 + initBalance2);\n// \trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t{\n\t\tpreserved {\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\n// \tuint256 amount1;\n// \tuint256 amount2;\n// \tuint256 sum = amount1 + amount2;\n// \tenv e;\n// \tmint(e, user1, amount1);\n// \tmint(e, user1, amount2);\n// \tmint(e, user2, sum);\n// \tuint256 finBalance1 = balanceOf(user1);\n// \tuint256 finBalance2 = balanceOf(user2);\n// \tmathint diff1 = finBalance1 - initBalance1;\n// \tmathint diff2 = finBalance2 - initBalance2;\n// \tassert diff1 == diff2;\n// }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "mintIsAdditive",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint",
                "totalSupply",
                "balanceOf"
            ],
            "start_line": 385,
            "end_line": 408,
            "block_hash": "5f734ad830f914fc888da788a02fedfb"
        }
    },
    {
        "id": "GhoToken_balance_after_mint_e7ace2dc",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "mint",
        "text_chunk": "  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule balance_after_mint() {\n\t\n\tenv e;\n\taddress user;\n\tuint256 initBalance = balanceOf(user);\n\tuint256 initSupply = totalSupply();\n\tuint256 amount;\n\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t{\n\t\tpreserved {\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\tmint(e, user, amount);\n\tuint256 finBalance = balanceOf(user);\n\tuint256 finSupply = totalSupply();\n\tassert initBalance + amount == finBalance;\n\tassert initSupply + amount == finSupply;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "balance_after_mint",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint",
                "totalSupply",
                "balanceOf"
            ],
            "start_line": 410,
            "end_line": 423,
            "block_hash": "e7ace2dcf1aaae6f35c33c9af7c078d2"
        }
    },
    {
        "id": "GhoToken_balance_after_burn_6c93eb0c",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "burn",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule balance_after_burn() {\n\t\n\tenv e;\n\trequireInvariant inv_balanceOf_leq_totalSupply(e.msg.sender);\n\tuint256 initBalance = balanceOf(e.msg.sender);\n\tuint256 initSupply = totalSupply();\n\tuint256 amount;\n\tburn(e, amount);\n\tuint256 finBalance = balanceOf(e.msg.sender);\n\tuint256 finSupply = totalSupply();\n\tassert initBalance == finBalance + amount;\n\tassert initSupply == finSupply + amount ;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "balance_after_burn",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "burn",
                "totalSupply",
                "balanceOf"
            ],
            "start_line": 425,
            "end_line": 437,
            "block_hash": "6c93eb0cacc3b3810f863f86e1c62f69"
        }
    },
    {
        "id": "GhoToken_burnIsAdditive_1dd12709",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "burn",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "// rule burnIsAdditive() {\n// \tenv e;\n// \tuint256 senderBalance = balanceOf(e.msg.sender);\n// \trequire(senderBalance <= sumAllBalance());\n// \trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t{\n\t\tpreserved {\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\n// \tuint256 amount1;\n// \tuint256 amount2;\n// \tuint256 sum = amount1 + amount2;\n// \tuint256 initSupply = totalSupply();\n// \tburn(e, amount1);\n// \tburn(e, amount2);\n// \tuint256 midSupply = totalSupply();\n// \tburn(e, sum);\n// \tuint256 finSupply = totalSupply();\n// \tmathint diff1 = finSupply - midSupply;\n// \tmathint diff2 = midSupply - initSupply;\n// \tassert diff1 == diff2;\n// }\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burnIsAdditive",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "burn",
                "totalSupply",
                "balanceOf"
            ],
            "start_line": 442,
            "end_line": 462,
            "block_hash": "1dd12709d155c89479892893748c9149"
        }
    },
    {
        "id": "GhoToken_mintLimitedByFacilitatorRemainingCapacity_7849df10",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "mint",
        "text_chunk": "  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule mintLimitedByFacilitatorRemainingCapacity() {\n\tenv e;\n\trequire(getFacilitatorBucketCapacity(e.msg.sender) > getFacilitatorBucketLevel(e.msg.sender));\n\n\tuint256 amount;\n\trequire(amount > (getFacilitatorBucketCapacity(e.msg.sender) - getFacilitatorBucketLevel(e.msg.sender)));\n\taddress user;\n\tmint@withrevert(e, user, amount);\n\tassert lastReverted;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "mintLimitedByFacilitatorRemainingCapacity",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "mint",
                "getFacilitatorBucketLevel",
                "getFacilitatorBucketCapacity"
            ],
            "start_line": 467,
            "end_line": 476,
            "block_hash": "7849df10e87eb4b106d0a5351f44c928"
        }
    },
    {
        "id": "GhoToken_burnLimitedByFacilitatorLevel_b1fbcffa",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "burn",
        "text_chunk": "  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n",
        "formal_property": "rule burnLimitedByFacilitatorLevel() {\n\tenv e;\n\trequire(getFacilitatorBucketCapacity(e.msg.sender) > getFacilitatorBucketLevel(e.msg.sender));\n\n\tuint256 amount;\n\trequire(amount > getFacilitatorBucketLevel(e.msg.sender));\n\tburn@withrevert(e, amount);\n\tassert lastReverted;\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burnLimitedByFacilitatorLevel",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "burn",
                "getFacilitatorBucketLevel",
                "getFacilitatorBucketCapacity"
            ],
            "start_line": 481,
            "end_line": 489,
            "block_hash": "b1fbcffaae9d8bc8244cdc0ab5c14e40"
        }
    },
    {
        "id": "GhoToken_address_not_in_list_after_removeFacilitator_CASE_SPLIT_zero_address_f5025826",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "GhoToken.sol",
        "target_function": "removeFacilitator",
        "text_chunk": "  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n",
        "formal_property": "rule address_not_in_list_after_removeFacilitator_CASE_SPLIT_zero_address(address facilitator){\nrule address_not_in_list_after_removeFacilitator(address facilitator){\n\tenv e;\n\trequireInvariant addressSetInvariant();\ninvariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant length_leq_max_uint160();\ninvariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();\ninvariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();\n\t\t}\n\t}\n\trequireInvariant length_leq_max_uint160();\n\trequireInvariant addr_in_set_iff_in_map(facilitator);\ninvariant addr_in_set_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)\n\t{preserved{\n \t\trequireInvariant addressSetInvariant();\n\tremoveFacilitator(e, facilitator);\n\tassert !is_in_facilitator_set_array(facilitator);\n}\n\trequire facilitator == 0;\n\t\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "address_not_in_list_after_removeFacilitator_CASE_SPLIT_zero_address",
            "rule_type": "rule",
            "modifies_state": true,
            "methods_in_block": [
                "removeFacilitator",
                "is_in_facilitator_set_array"
            ],
            "start_line": 523,
            "end_line": 531,
            "block_hash": "f5025826f964091825cc4c234c4c9ae5"
        }
    }
]