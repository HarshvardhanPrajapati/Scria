[
    {
        "id": "GhoToken_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "mint",
                "burn",
                "addFacilitator",
                "removeFacilitator",
                "setFacilitatorBucketCapacity",
                "getFacilitator",
                "getFacilitatorBucket",
                "getFacilitatorsList"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "GhoToken_length_leq_max_uint160",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant length_leq_max_uint160()\n\tgetFacilitatorsListLen() < TWO_TO_160()\n\n// INV #2\n/**\n* @title User's balance not greater than totalSupply()\n*/\ninvariant inv_balanceOf_leq_totalSupply(address user)\n\tbalanceOf(user) <= totalSupply()\n\t{\n\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "length_leq_max_uint160",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "GhoToken_total_supply_eq_sumAllLevel",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "burn",
        "text_chunk": "function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }",
        "formal_property": "invariant total_supply_eq_sumAllLevel()\n\t\tsumAllLevel() == totalSupply() \n\t{\n\t  preserved burn(uint256 amount) with (env e){\n\t\t\trequireInvariant inv_balanceOf_leq_totalSupply(e.msg.sender);",
        "nl_summary": "",
        "metadata": {
            "rule_name": "total_supply_eq_sumAllLevel",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "GhoToken_sumAllBalance_eq_totalSupply",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant sumAllBalance_eq_totalSupply()\n\tsumAllBalance() == totalSupply()\n\t{\n\t\tpreserved {\n\t\t\trequireInvariant sumAllLevel_eq_sumAllBalance();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sumAllBalance_eq_totalSupply",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "GhoToken_sumAllLevel_eq_sumAllBalance",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant sumAllLevel_eq_sumAllBalance()\n\tsumAllLevel() == sumAllBalance()\n\t  \t{\n\t\t\tpreserved {\n\t\t\trequireInvariant sumAllBalance_eq_totalSupply();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sumAllLevel_eq_sumAllBalance",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "GhoToken_inv_valid_capacity",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant inv_valid_capacity(address facilitator)\n\t((getFacilitatorBucketCapacity(facilitator)>0) => is_in_facilitator_mapping(facilitator) )\n\n// INV #7\n/**\n* @title A facilitator with a positive bucket level exists in the _facilitators mapping\n*/\ninvariant inv_valid_level(address facilitator)\n\t((getFacilitatorBucketLevel(facilitator)>0) => is_in_facilitator_mapping(facilitator) )\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant inv_valid_capacity(facilitator);",
        "nl_summary": "",
        "metadata": {
            "rule_name": "inv_valid_capacity",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "GhoToken_address_in_set_values_iff_in_set_indexes",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant address_in_set_values_iff_in_set_indexes(address facilitator)\n\tis_in_facilitator_set_array(facilitator) <=> is_in_facilitator_set_map(facilitator)\n\t{preserved{\n\t\trequireInvariant addressSetInvariant();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "address_in_set_values_iff_in_set_indexes",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "GhoToken_addr_in_set_iff_in_map",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant addr_in_set_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_map(facilitator)\n\t{preserved{\n \t\trequireInvariant addressSetInvariant();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "addr_in_set_iff_in_map",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "GhoToken_addr_in_set_list_iff_in_map",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant addr_in_set_list_iff_in_map(address facilitator)\n\tis_in_facilitator_mapping(facilitator) <=> is_in_facilitator_set_array(facilitator)\n\t{preserved{\n\t\trequireInvariant addressSetInvariant();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "addr_in_set_list_iff_in_map",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "GhoToken_ARRAY_IS_INVERSE_OF_MAP_Invariant",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant ARRAY_IS_INVERSE_OF_MAP_Invariant()\n    ARRAY_IS_INVERSE_OF_MAP()\n\t{\n\t\tpreserved{\n\t\t\trequire ADDRESS_SET_INVARIANT();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "ARRAY_IS_INVERSE_OF_MAP_Invariant",
            "rule_type": "INVARIANT"
        }
    },
    {
        "id": "GhoToken_addressSetInvariant",
        "chunk_type": "CONTRACT_INVARIANT",
        "source_contract": "GhoToken.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport {AccessControl} from '@openzeppelin/contracts/access/AccessControl.sol';\nimport {ERC20} from './ERC20.sol';\nimport {IGhoToken} from './interfaces/IGhoToken.sol';\n\n/**\n * @title GHO Token\n * @author Aave\n */\ncontract GhoToken is ERC20, AccessControl, IGhoToken {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(address => Facilitator) internal _facilitators;\n  EnumerableSet.AddressSet internal _facilitatorsList;\n\n  bytes32 public constant FACILITATOR_MANAGER = keccak256('FACILITATOR_MANAGER');\n  bytes32 public constant BUCKET_MANAGER = keccak256('BUCKET_MANAGER');\n\n  /**\n   * @dev Constructor\n   * @param admin This is the initial holder of the default admin role\n   */\n  constructor(address admin) ERC20('Gho Token', 'GHO', 18) {\n    _setupRole(DEFAULT_ADMIN_ROLE, admin);\n  }\n\n  /**\n   * @notice Mints the requested amount of tokens to the account address.\n   * @dev Only facilitators with enough bucket capacity available can mint.\n   * @dev The bucket level is increased upon minting.\n   * @param account The address receiving the GHO tokens\n   * @param amount The amount to mint\n   */\n  function mint(address account, uint256 amount) external override {\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 bucketCapacity = f.bucketCapacity;\n    require(bucketCapacity > 0, 'INVALID_FACILITATOR');\n\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel + amount;\n    require(bucketCapacity >= newBucketLevel, 'FACILITATOR_BUCKET_CAPACITY_EXCEEDED');\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _mint(account, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /**\n   * @notice Burns the requested amount of tokens from the account address.\n   * @dev Only active facilitators (bucket level > 0) can burn.\n   * @dev The bucket level is decreased upon burning.\n   * @param amount The amount to burn\n   */\n  function burn(uint256 amount) external override {\n    require(amount != 0, 'INVALID_BURN_AMOUNT');\n\n    Facilitator storage f = _facilitators[msg.sender];\n    uint256 currentBucketLevel = f.bucketLevel;\n    uint256 newBucketLevel = currentBucketLevel - amount;\n    f.bucketLevel = uint128(newBucketLevel);\n\n    _burn(msg.sender, amount);\n\n    emit FacilitatorBucketLevelUpdated(msg.sender, currentBucketLevel, newBucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function addFacilitator(\n    address facilitatorAddress,\n    string calldata facilitatorLabel,\n    uint128 bucketCapacity\n  ) external onlyRole(FACILITATOR_MANAGER) {\n    Facilitator storage facilitator = _facilitators[facilitatorAddress];\n    require(bytes(facilitator.label).length == 0, 'FACILITATOR_ALREADY_EXISTS');\n    require(bytes(facilitatorLabel).length > 0, 'INVALID_LABEL');\n\n    facilitator.label = facilitatorLabel;\n    facilitator.bucketCapacity = bucketCapacity;\n\n    _facilitatorsList.add(facilitatorAddress);\n\n    emit FacilitatorAdded(\n      facilitatorAddress,\n      keccak256(abi.encodePacked(facilitatorLabel)),\n      bucketCapacity\n    );\n  }\n\n  /// @inheritdoc IGhoToken\n  function removeFacilitator(address facilitatorAddress) external onlyRole(FACILITATOR_MANAGER) {\n    require(\n      bytes(_facilitators[facilitatorAddress].label).length > 0,\n      'FACILITATOR_DOES_NOT_EXIST'\n    );\n    require(\n      _facilitators[facilitatorAddress].bucketLevel == 0,\n      'FACILITATOR_BUCKET_LEVEL_NOT_ZERO'\n    );\n\n    delete _facilitators[facilitatorAddress];\n    _facilitatorsList.remove(facilitatorAddress);\n\n    emit FacilitatorRemoved(facilitatorAddress);\n  }\n\n  /// @inheritdoc IGhoToken\n  function setFacilitatorBucketCapacity(\n    address facilitator,\n    uint128 newCapacity\n  ) external onlyRole(BUCKET_MANAGER) {\n    require(bytes(_facilitators[facilitator].label).length > 0, 'FACILITATOR_DOES_NOT_EXIST');\n\n    uint256 oldCapacity = _facilitators[facilitator].bucketCapacity;\n    _facilitators[facilitator].bucketCapacity = newCapacity;\n\n    emit FacilitatorBucketCapacityUpdated(facilitator, oldCapacity, newCapacity);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitator(address facilitator) external view returns (Facilitator memory) {\n    return _facilitators[facilitator];\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorBucket(address facilitator) external view returns (uint256, uint256) {\n    return (_facilitators[facilitator].bucketCapacity, _facilitators[facilitator].bucketLevel);\n  }\n\n  /// @inheritdoc IGhoToken\n  function getFacilitatorsList() external view returns (address[] memory) {\n    return _facilitatorsList.values();\n  }\n}\n",
        "formal_property": "invariant addressSetInvariant()\n    ADDRESS_SET_INVARIANT()\n\t{\n\t\tpreserved{\n\t\t\trequireInvariant length_leq_max_uint160();",
        "nl_summary": "",
        "metadata": {
            "rule_name": "addressSetInvariant",
            "rule_type": "INVARIANT"
        }
    }
]