[
    {
        "id": "ERC1155Burnable_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "burn",
                "burnBatch"
            ],
            "state_variables": [],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC1155Burnable_onlyHolderOrApprovedCanReduceBalance_edc154e9",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n",
        "formal_property": "rule onlyHolderOrApprovedCanReduceBalance(method f) \n{\n    address holder; uint256 token; uint256 amount;\n    uint256 balanceBefore = balanceOf(holder, token);\n\n    env e; calldataarg args;\n    f(e, args);\n    uint256 balanceAfter = balanceOf(holder, token);\n    assert balanceAfter < balanceBefore => e.msg.sender == holder || isApprovedForAll(holder, e.msg.sender), \n        \"An account balance may only be reduced by the holder or a holder-approved agent\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "onlyHolderOrApprovedCanReduceBalance",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "isApprovedForAll"
            ],
            "start_line": 8,
            "end_line": 20,
            "block_hash": "edc154e9e2ff4e00dc1db6146ef38b14"
        }
    },
    {
        "id": "ERC1155Burnable_holds_be8ac5a4",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burn",
        "text_chunk": "    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n",
        "formal_property": "/// n.b. This rule holds for `burnBatch` as well due to rules establishing \n/// appropriate equivance between `burn` and `burnBatch` methods.\nrule burnAmountProportionalToBalanceReduction {\n    storage beforeBurn = lastStorage;\n    env e;\n    \n    address holder; uint256 token;\n    mathint startingBalance = balanceOf(holder, token);\n    uint256 smallBurn; uint256 largeBurn;\n    require smallBurn < largeBurn;\n\n    // smaller burn amount\n    burn(e, holder, token, smallBurn) at beforeBurn;\n    mathint smallBurnBalanceChange = startingBalance - balanceOf(holder, token);\n    // larger burn amount\n    burn(e, holder, token, largeBurn) at beforeBurn;\n    mathint largeBurnBalanceChange = startingBalance - balanceOf(holder, token);\n    assert smallBurnBalanceChange < largeBurnBalanceChange, \n        \"A larger burn must lead to a larger decrease in balance\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "holds",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf"
            ],
            "start_line": 24,
            "end_line": 45,
            "block_hash": "be8ac5a4e06b236877dbcaff1ad69184"
        }
    },
    {
        "id": "ERC1155Burnable_holds_8dbc56a7",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burn",
        "text_chunk": "    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n",
        "formal_property": "/// This rule holds for `burnBatch` as well due to rules establishing \n/// appropriate equivance between `burn` and `burnBatch` methods.\nrule sequentialBurnsEquivalentToSingleBurnOfSum {\n    storage beforeBurns = lastStorage;\n    env e;\n\n    address holder; uint256 token;\n    mathint startingBalance = balanceOf(holder, token);\n    uint256 firstBurn; uint256 secondBurn; uint256 sumBurn;\n    require sumBurn == firstBurn + secondBurn;\n    // sequential burns\n    burn(e, holder, token, firstBurn) at beforeBurns;\n    burn(e, holder, token, secondBurn);\n    mathint sequentialBurnsBalanceChange = startingBalance - balanceOf(holder, token);\n    // burn of sum of sequential burns\n    burn(e, holder, token, sumBurn) at beforeBurns;\n    mathint sumBurnBalanceChange = startingBalance - balanceOf(holder, token);\n    assert sequentialBurnsBalanceChange == sumBurnBalanceChange, \n        \"Sequential burns must be equivalent to a burn of their sum\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "holds",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf"
            ],
            "start_line": 49,
            "end_line": 71,
            "block_hash": "8dbc56a783a5fc4b36d4da802036498d"
        }
    },
    {
        "id": "ERC1155Burnable_singleTokenBurnBurnBatchEquivalence_b36c808e",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burn/burnBatch",
        "text_chunk": "    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n",
        "formal_property": "rule singleTokenBurnBurnBatchEquivalence {\n    storage beforeBurn = lastStorage;\n    env e;\n\n    address holder;\n    uint256 token; uint256 burnAmount;\n    uint256[] tokens; uint256[] burnAmounts;\n    mathint startingBalance = balanceOf(holder, token);\n    require tokens.length == 1; require burnAmounts.length == 1;\n    require tokens[0] == token; require burnAmounts[0] == burnAmount;\n    // burning via burn\n    burn(e, holder, token, burnAmount) at beforeBurn;\n    mathint burnBalanceChange = startingBalance - balanceOf(holder, token);\n    // burning via burnBatch\n    burnBatch(e, holder, tokens, burnAmounts) at beforeBurn;\n    mathint burnBatchBalanceChange = startingBalance - balanceOf(holder, token);\n    assert burnBalanceChange == burnBatchBalanceChange, \n        \"Burning a single token via burn or burnBatch must be equivalent\";\n}   \n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "singleTokenBurnBurnBatchEquivalence",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf"
            ],
            "start_line": 75,
            "end_line": 98,
            "block_hash": "b36c808e5929b289985dd52ef07ecb44"
        }
    },
    {
        "id": "ERC1155Burnable_multipleTokenBurnBurnBatchEquivalence_910a5d21",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burn/burnBatch",
        "text_chunk": "    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n",
        "formal_property": "rule multipleTokenBurnBurnBatchEquivalence {\n    storage beforeBurns = lastStorage;\n    env e;\n\n    address holder;\n    uint256 tokenA; uint256 tokenB; uint256 tokenC;\n    uint256 burnAmountA; uint256 burnAmountB; uint256 burnAmountC;\n    uint256[] tokens; uint256[] burnAmounts;\n    mathint startingBalanceA = balanceOf(holder, tokenA);\n    mathint startingBalanceB = balanceOf(holder, tokenB);\n    mathint startingBalanceC = balanceOf(holder, tokenC);\n    require tokens.length == 3; require burnAmounts.length == 3;\n    require tokens[0] == tokenA; require burnAmounts[0] == burnAmountA;\n    require tokens[1] == tokenB; require burnAmounts[1] == burnAmountB;\n    require tokens[2] == tokenC; require burnAmounts[2] == burnAmountC;\n    // burning via burn\n    burn(e, holder, tokenA, burnAmountA) at beforeBurns;\n    burn(e, holder, tokenB, burnAmountB);\n    burn(e, holder, tokenC, burnAmountC);\n    mathint burnBalanceChangeA = startingBalanceA - balanceOf(holder, tokenA);\n    mathint burnBalanceChangeB = startingBalanceB - balanceOf(holder, tokenB);\n    mathint burnBalanceChangeC = startingBalanceC - balanceOf(holder, tokenC);\n    // burning via burnBatch\n    burnBatch(e, holder, tokens, burnAmounts) at beforeBurns;\n    mathint burnBatchBalanceChangeA = startingBalanceA - balanceOf(holder, tokenA);\n    mathint burnBatchBalanceChangeB = startingBalanceB - balanceOf(holder, tokenB);\n    mathint burnBatchBalanceChangeC = startingBalanceC - balanceOf(holder, tokenC);\n    assert burnBalanceChangeA == burnBatchBalanceChangeA\n        && burnBalanceChangeB == burnBatchBalanceChangeB\n        && burnBalanceChangeC == burnBatchBalanceChangeC, \n        \"Burning multiple tokens via burn or burnBatch must be equivalent\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "multipleTokenBurnBurnBatchEquivalence",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf"
            ],
            "start_line": 102,
            "end_line": 138,
            "block_hash": "910a5d2195a02737956a9660023e47e4"
        }
    },
    {
        "id": "ERC1155Burnable_burnBatchOnEmptyArraysChangesNothing_1e0543c1",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burnBatch",
        "text_chunk": "    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n",
        "formal_property": "rule burnBatchOnEmptyArraysChangesNothing {\n    uint256 token; address nonHolderA; address nonHolderB;\n\n    uint256 startingBalance = balanceOf(nonHolderA, token);\n    bool startingPermission = isApprovedForAll(nonHolderA, nonHolderB);\n    env e; address holder; uint256[] noTokens; uint256[] noBurnAmounts;\n    require noTokens.length == 0; require noBurnAmounts.length == 0;\n    burnBatch(e, holder, noTokens, noBurnAmounts);\n    \n    uint256 endingBalance = balanceOf(nonHolderA, token);\n    bool endingPermission = isApprovedForAll(nonHolderA, nonHolderB);\n    assert startingBalance == endingBalance, \n        \"burnBatch must not change token balances if passed empty arrays\";\n    assert startingPermission == endingPermission, \n        \"burnBatch must not change account permissions if passed empty arrays\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burnBatchOnEmptyArraysChangesNothing",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [
                "balanceOf",
                "isApprovedForAll"
            ],
            "start_line": 142,
            "end_line": 160,
            "block_hash": "1e0543c135155bb4e5be455688fa2007"
        }
    },
    {
        "id": "ERC1155Burnable_should_450cab67",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n",
        "formal_property": "/// This rule should always fail.\nrule sanity {\n    method f; env e; calldataarg args;\n\n    f(e, args);\n    assert false, \n        \"This rule should always fail\";\n}\n",
        "nl_summary": "",
        "metadata": {
            "rule_name": "should",
            "rule_type": "rule",
            "modifies_state": false,
            "methods_in_block": [],
            "start_line": 163,
            "end_line": 171,
            "block_hash": "450cab677b62d88c95aed0ef1036d926"
        }
    }
]