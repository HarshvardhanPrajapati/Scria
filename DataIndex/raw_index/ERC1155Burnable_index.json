[
    {
        "id": "ERC1155Burnable_contract_context",
        "chunk_type": "CONTRACT_CONTEXT",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "ALL",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\n/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n",
        "formal_property": null,
        "nl_summary": "",
        "metadata": {
            "function_list": [
                "burn",
                "burnBatch"
            ],
            "is_standard": "UNKNOWN"
        }
    },
    {
        "id": "ERC1155Burnable_burnAmountProportionalToBalanceReduction",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burn",
        "text_chunk": "function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }",
        "formal_property": "rule burnAmountProportionalToBalanceReduction {\n    storage beforeBurn = lastStorage;\n    env e;\n    \n    address holder; uint256 token;\n    mathint startingBalance = balanceOf(holder, token);\n    uint256 smallBurn; uint256 largeBurn;\n    require smallBurn < largeBurn;\n\n    // smaller burn amount\n    burn(e, holder, token, smallBurn) at beforeBurn;\n    mathint smallBurnBalanceChange = startingBalance - balanceOf(holder, token);\n\n    // larger burn amount\n    burn(e, holder, token, largeBurn) at beforeBurn;\n    mathint largeBurnBalanceChange = startingBalance - balanceOf(holder, token);\n\n    assert smallBurnBalanceChange < largeBurnBalanceChange, \n        \"A larger burn must lead to a larger decrease in balance\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burnAmountProportionalToBalanceReduction",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155Burnable_sequentialBurnsEquivalentToSingleBurnOfSum",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burn",
        "text_chunk": "function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }",
        "formal_property": "rule sequentialBurnsEquivalentToSingleBurnOfSum {\n    storage beforeBurns = lastStorage;\n    env e;\n\n    address holder; uint256 token;\n    mathint startingBalance = balanceOf(holder, token);\n    uint256 firstBurn; uint256 secondBurn; uint256 sumBurn;\n    require sumBurn == firstBurn + secondBurn;\n\n    // sequential burns\n    burn(e, holder, token, firstBurn) at beforeBurns;\n    burn(e, holder, token, secondBurn);\n    mathint sequentialBurnsBalanceChange = startingBalance - balanceOf(holder, token);\n\n    // burn of sum of sequential burns\n    burn(e, holder, token, sumBurn) at beforeBurns;\n    mathint sumBurnBalanceChange = startingBalance - balanceOf(holder, token);\n\n    assert sequentialBurnsBalanceChange == sumBurnBalanceChange, \n        \"Sequential burns must be equivalent to a burn of their sum\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sequentialBurnsEquivalentToSingleBurnOfSum",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155Burnable_singleTokenBurnBurnBatchEquivalence",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burn/burnbatch",
        "text_chunk": "function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }",
        "formal_property": "rule singleTokenBurnBurnBatchEquivalence {\n    storage beforeBurn = lastStorage;\n    env e;\n\n    address holder;\n    uint256 token; uint256 burnAmount;\n    uint256[] tokens; uint256[] burnAmounts;\n\n    mathint startingBalance = balanceOf(holder, token);\n\n    require tokens.length == 1; require burnAmounts.length == 1;\n    require tokens[0] == token; require burnAmounts[0] == burnAmount;\n\n    // burning via burn\n    burn(e, holder, token, burnAmount) at beforeBurn;\n    mathint burnBalanceChange = startingBalance - balanceOf(holder, token);\n\n    // burning via burnBatch\n    burnBatch(e, holder, tokens, burnAmounts) at beforeBurn;\n    mathint burnBatchBalanceChange = startingBalance - balanceOf(holder, token);\n\n    assert burnBalanceChange == burnBatchBalanceChange, \n        \"Burning a single token via burn or burnBatch must be equivalent\";\n}   \n\n/// The results of burning multiple tokens must be equivalent whether done \n/// separately via burn or together via burnBatch.\nrule multipleTokenBurnBurnBatchEquivalence {\n    storage beforeBurns = lastStorage;\n    env e;\n\n    address holder;\n    uint256 tokenA; uint256 tokenB; uint256 tokenC;\n    uint256 burnAmountA; uint256 burnAmountB; uint256 burnAmountC;\n    uint256[] tokens; uint256[] burnAmounts;\n\n    mathint startingBalanceA = balanceOf(holder, tokenA);\n    mathint startingBalanceB = balanceOf(holder, tokenB);\n    mathint startingBalanceC = balanceOf(holder, tokenC);\n\n    require tokens.length == 3; require burnAmounts.length == 3;\n    require tokens[0] == tokenA; require burnAmounts[0] == burnAmountA;\n    require tokens[1] == tokenB; require burnAmounts[1] == burnAmountB;\n    require tokens[2] == tokenC; require burnAmounts[2] == burnAmountC;\n\n    // burning via burn\n    burn(e, holder, tokenA, burnAmountA) at beforeBurns;\n    burn(e, holder, tokenB, burnAmountB);\n    burn(e, holder, tokenC, burnAmountC);\n    mathint burnBalanceChangeA = startingBalanceA - balanceOf(holder, tokenA);\n    mathint burnBalanceChangeB = startingBalanceB - balanceOf(holder, tokenB);\n    mathint burnBalanceChangeC = startingBalanceC - balanceOf(holder, tokenC);\n\n    // burning via burnBatch\n    burnBatch(e, holder, tokens, burnAmounts) at beforeBurns;\n    mathint burnBatchBalanceChangeA = startingBalanceA - balanceOf(holder, tokenA);\n    mathint burnBatchBalanceChangeB = startingBalanceB - balanceOf(holder, tokenB);\n    mathint burnBatchBalanceChangeC = startingBalanceC - balanceOf(holder, tokenC);\n\n    assert burnBalanceChangeA == burnBatchBalanceChangeA\n        && burnBalanceChangeB == burnBatchBalanceChangeB\n        && burnBalanceChangeC == burnBatchBalanceChangeC, \n        \"Burning multiple tokens via burn or burnBatch must be equivalent\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "singleTokenBurnBurnBatchEquivalence",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155Burnable_burnBatchOnEmptyArraysChangesNothing",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "burnbatch",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\n/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n",
        "formal_property": "rule burnBatchOnEmptyArraysChangesNothing {\n    uint256 token; address nonHolderA; address nonHolderB;\n\n    uint256 startingBalance = balanceOf(nonHolderA, token);\n    bool startingPermission = isApprovedForAll(nonHolderA, nonHolderB);\n\n    env e; address holder; uint256[] noTokens; uint256[] noBurnAmounts;\n    require noTokens.length == 0; require noBurnAmounts.length == 0;\n\n    burnBatch(e, holder, noTokens, noBurnAmounts);\n    \n    uint256 endingBalance = balanceOf(nonHolderA, token);\n    bool endingPermission = isApprovedForAll(nonHolderA, nonHolderB);\n\n    assert startingBalance == endingBalance, \n        \"burnBatch must not change token balances if passed empty arrays\";\n    assert startingPermission == endingPermission, \n        \"burnBatch must not change account permissions if passed empty arrays\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "burnBatchOnEmptyArraysChangesNothing",
            "rule_type": "RULE"
        }
    },
    {
        "id": "ERC1155Burnable_sanity",
        "chunk_type": "FUNCTION_RULE",
        "source_contract": "ERC1155Burnable.sol",
        "target_function": "UNKNOWN",
        "text_chunk": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\n/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n",
        "formal_property": "rule sanity {\n    method f; env e; calldataarg args;\n\n    f(e, args);\n\n    assert false, \n        \"This rule should always fail\";\n}",
        "nl_summary": "",
        "metadata": {
            "rule_name": "sanity",
            "rule_type": "RULE"
        }
    }
]